<!DOCTYPE>
<html>

<head>
  <!-- Google tag (gtag.js) -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-J7404418VP"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag() { dataLayer.push(arguments); }
    gtag('js', new Date());

    gtag('config', 'G-J7404418VP');
  </script>

  <title>MaterialX Learn - Graph Visualizer </title>
  <link rel="icon" href="./images/logo3d_icon.png" type="image/x-icon" />

  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/css/bootstrap.min.css" rel="stylesheet"
    integrity="sha384-rbsA2VBKQhggwzxH7pPCaAqO46MgnOM80zW1RWuH61DGLwZJEdK2Kadq2F9CUG65" crossorigin="anonymous">

  <link rel="stylesheet" href="css/style.css">


  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Roboto&display=swap" rel="stylesheet">

</head>

<body class="min-vh-100">

  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/js/bootstrap.bundle.min.js"
    integrity="sha384-kenU1KFdBIe4zVF0s0G1M5b4hcpxyD9F7jL+jjXkk+Q2h455rYXK/7HAuoJl+0I4"
    crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
  <script> mermaid.initialize({ startOnLoad: true, theme: document.body.classList.contains("vscode-dark") || document.body.classList.contains("vscode-high-contras") ? "dark" : "forest" }); </script>

  <!-- Navigation  -->
  <nav class="navbar sticky-top navbar-expand-lg bg-light">
    <div class="container-md container-fluid">
      <a class="navbar-brand" href="../index.html">
        <h4><img src="images/logo3d_2_small.png" alt="MaterialX Learn" class="d-inline-block align-text-center"
            width="60">
          MaterialX Learn</h4>
      </a>
      <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#mainMenuContent"
        aria-controls="mainMenuContent" aria-expanded="false" aria-label="Toggle top menu">
        <span class="navbar-toggler-icon"></span>
      </button>
      <div class="collapse navbar-collapse" id="mainMenuContent">
        <ul class="navbar-nav ms-auto mb-2 mb-lg-0">

          <li class="nav-item dropdown">
            <a class="nav-link" href="../index.html" role="button">
              Home
            </a>
          </li>

          <li class="nav-item dropdown">
            <a class="nav-link dropdown-toggle" href="#" role="button" data-bs-toggle="dropdown" aria-expanded="false">
              Learn
            </a>
            <ul class="dropdown-menu">
              <li>
                <a class="dropdown-item" href="nodes_and_nodegraphs.html">
                  Nodes and Graphs
                </a>
              </li>
              <li>
                <a class="dropdown-item" href="node_definitions.html">
                  Node Definitions
                </a>
              </li>
              <li>
                <a class="dropdown-item" href="documents.html">
                  Documents
                </a>
              </li>
            </ul>
          </li>

          <li class="nav-item dropdown">
            <a class="nav-link dropdown-toggle" href="#" role="button" data-bs-toggle="dropdown" aria-expanded="false">
              Reference
            </a>
            <ul class="dropdown-menu">
              <li>
                <a class="dropdown-item" href="definitions/definitions_by_group.html">
                  Library (By Group)
                </a>
              </li>
              <li>
                <a class="dropdown-item" href="definitions/all_definitions.html">
                  Library (All)
                </a>
              </li>
              <li>
                <a class="dropdown-item" href="definitions/library_glossary.html">
                  Library Glossary
                </a>
              </li>
              <li>
                <a class="dropdown-item" href="https://materialx.org/docs/api/annotated.html" target="_blank">
                  <img src="images/MaterialXLogo_200x155.png" style="width:20px"> C++ API
                </a>
              </li>
              <div class="dropdown-divider"></div>
              <li>
                <a class="dropdown-item" href="using_library.html">
                  <img src="images/info-circle.svg"> Library User Guide
                </a>
              </li>
            </ul>
          </li>

          <li class="nav-item dropdown">
            <a class="nav-link dropdown-toggle" href="#" role="button" data-bs-toggle="dropdown"
              aria-expanded="false">Utilities</a>
            <ul class="dropdown-menu">
              <li>
                <a class="dropdown-item" href="mermaidChecker.html">
                  Graph Visualizer
                </a>
              </li>
            </ul>
          </li>

          <li class="nav-item dropdown">
            <a class="nav-link dropdown-toggle" href="#" role="button" data-bs-toggle="dropdown"
              aria-expanded="false">Develop</a>
            <ul class="dropdown-menu">
              <li>
                <a class="dropdown-item" href="python_MaterialX.html">
                  Tutorials
                </a>
              </li>
              <li>
                <a class="dropdown-item" href="jupyter_example.html">
                  Examples
                </a>
              </li>
            </ul>
          </li>

          <li class="nav-item dropdown">
            <a class="nav-link dropdown-toggle" href="#" role="button" data-bs-toggle="dropdown"
              aria-expanded="false">Workflows</a>
            <ul class="dropdown-menu">
              <li>
                <a class="dropdown-item" href="workflows.html">
                  Interop Workflows
                </a>
              </li>
            </ul>
          </li>

          <li class="nav-item dropdown">
            <a class="nav-link dropdown-toggle" href="#" role="button" data-bs-toggle="dropdown"
              aria-expanded="false">Design</a>
            <ul class="dropdown-menu">
              <li>
                <a class="dropdown-item" href="design.html">
                  UX Design
                </a>
              </li>
              <li>
                <a class="dropdown-item" href="implementation.html">
                  Implementation
                </a>
              </li>
            </ul>
          </li>

          <li class="nav-item dropdown">
            <a class="nav-link" href="about.html" role="button">
              About
            </a>
          </li>
          </li>
        </ul>
      </div>
    </div>
  </nav>

  <div class="container-fluid ">
    <div class="row flex-nowrap">
      <div class="col-12 p-4 pt-2 pl-2">
        <div class="card border-primary border mb-4">
          <div class="card-body">

            <h2>1. MaterialX and Usd</h2>

            <img src="images/usd_materialx_interop.png" width="40%">
            <p>The <a href="../pymaterialx/mtlx_usd_notebook.html">Usd / MaterialX notebook</a>
              examines the
              interoperability of material / shader graphs between <code>Usd</code> and <code>MaterialX</code>.</p>
            <p>The following is summary of observations.</p>

            <h3>Hierarchy</h3>
            <p>Currently Usd can support arbitrary nesting of graphs. The MaterialX specification also denotes this
              support but this has not been implemented at the time of writing.</p>
            <p>Usd will "flatten" nested graphs to a single level, but this
              functionally does not seem to be exposed via a public API.</p>
            <p>For example the following graphs nodegraph "childNG" has to be re-parented to be under the 
              nodegraph "parentNG" in order to be supported in MaterialX.
              <img src="images/nested_nodegraphs.png" width="70%">
            </p>
            <p>It is possible to "flatten" graphs within MaterialX, but no such
              utility / API is provided by default.</p>
            <p>In Usd, for encapsulation, shader graphs are children of a Usd material with reuse via referencing. In
              MaterialX materials are not parents of the graphs they reference. That is, no parent-child hierarchy / grouping
              is enforced. (For more see the <a href="#materials">Materials</a> section) </p>
            <p><em>There is currently a  
              <a href="https://github.com/AcademySoftwareFoundation/MaterialX/issues/1272">proposal</a>
              to support MaterialX node graph hierarchies</em>. 
              For such a change it would be useful to revisit how "top" or Document level
              graphs behave. MaterialX Documents and child nodegraphs are both considered to be "graph elements" 
              but Documents specify sepcial semantic meanings fo output ports (are treated as AOVs) and disallows
              input ports. A uniform treatment could provide a closer match with Usd,
              especially if parenting a MaterialX derived graph within a Usd hierarchy</p>

            <h3>Paths and Connections</h3>
            <ul>
              <li>Usd specifies explicit output ports on nodes and graphs. MaterialX only does this for nodegraphs,
                requiring complex logic to discover and extract node output information.</li>
              <li>There is no uniform nor formal connection "API" in MaterialX as with Usd. This could be added to
                MaterialX to mask out the complexities due to the next point:</li>
              <li>There is no uniform syntax for specifying connections between
                ports and nodes in a MaterialX graph resulting in the 
                requirement to examine multiple meta-data attributes in order to "compose" a path.
                Variants result from:
                <ul>
                <li>from differences in handling input output ports for nodes versus nodegraphs </li>
                <li>from differences in handling nodegraph (interface) inputs / outputs vs node inputs and outputs.</li>
                <li>handling of implicit channel extraction via additional meta-data attributes. Note that this does not exist in Usd. 
                </ul>
              </li>
              <li>
                <p>MaterialX has no concept of absolute vs relative path notation to specify port paths. Note that 
                  these paths are not geometric dag paths used for material assignment
                </p>
              </li>
            </ul>
            <p>This contrasts with Usd which simply uses absolute path syntax for all connections (e.g. '/a/b/c') 
              specified on input ports. Such path reference output ports which are always explicitly specified.</p>
            <p>A "path" API in Usd has no correspondance in MaterialX. A MaterialX <code>FilePath</code> can be used 
              in lieu of this, or path modification can be done via string changes.</p>

              <p>Note that MaterialX uses relative paths to form connections and does not allow for parent path syntax
              (such as "../"). This has the advantage of assuring that no connections are ever formed between ports
              which do not have the same parent. This rule appears for Usd as well, but it is possible to have
              absoluate paths which specify a connection to ports outside the parent scope.</p>
            <p>There is a connection <code>edge</code> construct in MaterialX but this is only available within upstream
              traversal within an iterator.</p>
            <p>Downstream traversal is available in MaterialX relies on a caching system which is always dirtied on
              arbitrary attribute changes and not just connection changes.</p>

            <h3 id="materials">Materials</h3>
            <p>Usd represents a material as a node graph (container). This allows for arbitrary inputs and outputs to
              exist, with connections being made to ports on child nodes under the material.</p>
            <p>MaterialX used to have a similar concept for materials but only
              to provide a material "collection". As of version 1.38.6, this was replaced with material nodes 
              with two specific variants:
              <ul>
                <li>Surface materials: <code>surfacematerial</code> </li>
                <li>Volumetric materials: and <code>volumematerial</code></li>
              </ul>               
              These constructs more closely match existing DCC concepts such as "shading engines" in Maya.</p>
            <p>If bidirectional interop between Usd and MaterialX is performed, the question arises as to how handle the
              mapping between Usd and MaterialX materials.
            </p>
            <p>
              The following diagram shows the class hierarchy for Usd and MaterialX. It is mostly the discrepancy between
              have one (Usd) as a graph and the other (MaterialX) as a pair of atomic nodes that allows for different 
              approaches to mapping.
              <img src="images/usd_material_vs_mtlx_material.png" width="80%">
            </p>
            <p>Applications like Maya and Houdini use "graph containers" which more closely match a node graph.
              <ul>
              <li><p>If a Usd material graph is mapped to a MaterialX material node then arbitrary inputs and outputs have no place to map to 
              and the interop is lossy. 
              </p>
              <p>Additionally, the Usd material ports are <strong>output</strong> ports while 
              which need to be mapped to Materialx node <strong>input</strong> ports.
                That is, in Usd, these are output-to-output connections (as would occur in a MaterialX node-to-nodegraph)
                instead of input-to-output connections occurs with MaterialX node-to-node connections. The notebook shows the
                added logic complexity.</p>
              <li><p>If a Usd material graph is mapped to a MaterialX nodegraph then it is no longer distinguishable as a "material".
                though Usd input and output ports are easily mappable to MaterialX.</p>
                <li>An interesting issue is what to do with MaterialX material nodes? These nodes cannot 
                  be children of a translated Usd material and have no natural port connection in Usd. 
                  For conversion from Usd this could be handled as additional terminal material nodes 
                  which reference the same child shader graph. 
                  This is a rather unconvential mapping and makes it difficult to perform the reverse mapping
                  back to Usd.
                  </ul>
               </p>
              </p>
              

            <h3>Ports</h3>
            <p>For the most parts Usd ports correspond 1:1 with MaterialX ports. At the time of writing MaterialX 
              <code>tokens</code> do not appear to be supported in Usd. There are Usd <code>token</code> types but this has nothing to with
              the MaterialX concept which is tokens used for string substiton on geometric and file name
              identifiers and can be connectable similar to how ports can be connected.</p>
            <p>Some differences of note:</p> 
            <ul>
              <li>There is a superset of possible types in Usd versus MaterialX. This includes types which indicate
                precision (e.g. half-float vs float), signed and unsigned types, and various array types.
                Usage of Usd with MaterialX definitions should avoid any type mapping issues for interop.
              </li>
              <li>Usd uses <code>asset</code> references vs MaterialX which has only file name references for image resources. At
                the current time binary resource references are not supported in MaterialX.</li>
              <li>Usd uses <code>token</code> to represent shader ports on materials.
                This requires additional parsing of the port name to discover if the port maps to a surface,
                displacement, or volume shader type in MaterialX. </li>
              <li>There is some minor string syntax difference for representing tuples in Usd versus MaterialX which requires
                some extra mapping logic.
              </li>
            </ul>

            <h3>Supported Nodes</h3>
            <p>Usd supports nodes which are not defined in MaterialX.
              As such there is no way to map these to MaterialX unless "dummy" nodes are added. </p>
            <p>If MaterialX and non-MaterialX graphs are under the same parent, if they do not reference each other,
              it is possible to extract MaterialX subgraphs out and seems possible to re-parent them back in to
              a Usd hierarchy. Note that this was not attempted in the notebook example.</p>

            <h3>Material Assignment</h3>
            <p>Though MaterialX can support material assignments via it's <code>look</code> API, this was not examined
              as the intent is to have Usd perform this role with the <code>look</code> interfaces being optional going
              forward with the 1.39 release.</p>

            <h3>Usd-based versus Material-based Integrations</h3>
            <p>As part of the <a href="../pymaterialx/mtlx_definitions_libraries_notebook.html">
              Libraries / Definitions</a> notebook export was examined for Maya and Houdini. 
              Currently they both reside within the context of integration with Usd.</p>
            <p>Of note is that for Maya graphs that MaterialX material nodes are currently disallowed but sub-graphs are
              allowed, while for Houdini material nodes and sub-graphs are allowed are both are not exportable.<br>
              <img src="images/houdini_disallowed_nodes.png" width="60%">
            </p>
            <p>This could be a cause for some confusion without clarification on how these map to MaterialX. (At time of
              writing Maya does not support MaterialX export). It will be interesting to see how
              each approach progresses, and also to see the approach taken by Blender for MaterialX / Usd mapping.</p>
            <p>Currently <b>only the MaterialX Graph Editor</b> works <em>without</em> the notion of mapping to a Usd "container"
              (material graph). <br>
              Below is a diagram with configurations which could cause "issues". This includes 
              having a material node in a node graph, and having next graphs.
              <img src="images/graph_editor_supported.png" width="60%">
              <br>
              For an integration, if MaterialX import is supported it is possible that these or
              other graph configurations created may either be not supportable or require some type of
              transformation such as "flattening" or remapping.
              </p>
              <p>There can arise additional
              complications if these are MaterialX functional graphs used by a node definition
              as it is only at implementation usage time that an issue can arise. For example,
              during shader generation within a render delegate</p>
            <p>These are still "early days" and will be interesting to see how
              this all works out.</p>

            <h2>2. MaterialX and glTF</h2>
            <p><img src="https://raw.githubusercontent.com/kwokcb/glTF_MaterialX/main/docs/bidirectional_workflow.png"
                width="80%"></p>
            <p>Bi-directional conversion between MaterialX and glTF is available via the library and utilities found in
              <a href="https://github.com/kwokcb/glTF_MaterialX" target="_blank">this repo.</a>
            </p>
            <p>As MaterialX supports the glTF PBR surface shading model directly
              as of version 1.38.6, the mapping from a glTF surface shader
              to MaterialX is fairly straight forward. Supplementary nodes which match the glTF image mapping logic are
              provided as
              part of the MaterialX standard library and are used during translation.</p>
            <p>The reverse process which is the more natural one requires "distilling" a MaterialX shading graph down to
              a glTF one.</p>
            <p>If users an use only the MaterialX nodes supported which correspond to glTF then this mapping is more
              straight-forward.
              If not then a "baking" step is required to convert all upstream connected graphs into a single image, and
              if a non-glTF shading model is used then "shader translation" is required.
              <p>
                Below is an example of the "Brick" example shader which uses "Autodesk standard surface" which is mapped to
                a glTF PBR surface material and the result of baking a "ORM" map (along with other maps). 
                <br>
                <img src="images/Brick_ORM_baking.png" width="40%">
              </p>
            </p>
            <p>Fortunately, translation and baking are provided as part of the code API. What is not currently handled
              however is merging of multiple images into single images such as for <code>ORM</code> images used by glTF
              shaders. This would be a useful utility, and could actually be done as a MaterialX shader graph.</p>

            <p>Much discussion is occuring around Usd / glTF interop, but an interesting point
              to raise is whether MaterialX should be the intermedary representation and if so
              what role and tooling is useful. For example is baking via MaterialX useful when 
              this can be done via Usd.
            </p>

            <h2>3. MaterialX Libraries</h2>
            <p>The creation of custom definitions is being done by a few integrations such as for Maya, Houdini, and
              appears to be the direction for Blender.</p>
            <p>Agreement on semantics and syntax is under discussion. The
              <code>Libraries and Definitions</code> notebook contains some current workflow investigations.
            </p>
            <p>Note: This section is still WIP and will be filled in with more information based on
              findings from the notebook exploration and related discussions within the MaterialX TSC.
            </p>
          </div>
        </div>
      </div>
    </div>
  </div>

</body>

</html>