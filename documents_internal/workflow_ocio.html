<!--Start-->
<div class="container-fluid p-0">
  <div class="row flex-nowrap">
    <div class="col-12 p-0 pt-2 pl-2">
      <div class="card border-secondary shadow border mb-4">
        <div class="card-body">

          <h2 id="materialx-and-opencolorio">MaterialX and OpenColorIO</h2>
          <h3 id="introduction">Introduction</h3>
          <p>MaterialX code generation currently supports a &quot;default&quot; set of color space transforms via it's
            &quot;default color management&quot; mechanism.</p>
          <p>This includes a subset of those specified by the <code>AcesCg</code> (Academy Color Encoding System Color
            Grading) configuration which is included by default with <a
              href="https://opencolorio.readthedocs.io/en/latest/configurations/aces_cg.html"
              target="_blank">OpenColorIO</a> (OCIO) (as of version 2.2).</p>
          <p>The current <code>colorspace</code> attribute which can be used on color3 and color4 inputs as well as
            file name inputs matches either a color space name or one of it's aliases as defined in the AcesCg
            configuration.</p>
          <p>Additionally, there are node definitions which can be used to specify the color space transform to be
            used for a given input. They are named as follows:</p>
          <pre class="hljs"><code><div>&lt;source_colorspace&gt;_to_&lt;target_colorspace&gt;
</div></code></pre>
          <p>where <code>source_colorspace</code> is the source and <code>target_colorspace</code> is the target color
            space.</p>
          <p>These are hard-coded and are do not actually reference any config file for correctness.</p>
          <h3 id="code-generation-support">Code Generation Support</h3>
          <p>Support entails providing implementation of color space transforms either as shader source code or as
            functional node graphs. ( The latter available as of MaterialX 1.38.6 ).</p>
          <p>MaterialX code generation allows for the insertion of color space transform code during generation when
            it encounters <code>colorspace</code> attributes.</p>
          <h3 id="integrations">Integrations</h3>
          <p>Insertion is more suitable for hardware renderers that for software renderers, as they will tend to
            perform the color space transform itself such as pre-transforming input images using the <a
              href="https://sites.google.com/site/openimageio/home" target="_blank">OpenImageIO</a> library (which can
            include OpenColorIO support).</p>
          <p>An example are renderers which consume the <code>OSL</code> shading language. In this case code
            generation simply passes the <code>colorspace</code> information onwards as meta-data within the shader
            code.</p>
          <p>As noted not all color space transforms are specified within MaterialX, so<br>
            if a <code>colorspace</code> attribute is specified which is not supported then the<br>
            integration needs to handle such cases appropriately. For instance a <code>USD HDStorm</code> render
            delegate could use `OpenImageIO`` to perform these transforms, while using code generation for those that
            are supported.</p>
          <h3 id="opencolorio-for-materialx-transform-creation">OpenColorIO for MaterialX Transform Creation</h3>
          <p>Below is a diagram of a possible workflow to generate MaterialX color space transforms using the
            OpenColorIO API.</p>
          <img src="../pymaterialx/notebooks/images/OCIO_MaterialX_Workflow.png " alt="MaterialX and OCIO" width="100%" />
          <p>The top portion (green boxes) shows the path for source code implementations while the middle left boxes
            represent the path for functional graph implementations.</p>
          <p>Common to both is that the definition interfaces (<code>nodedef</code>s) are the same.</p>
          <h3 id="source-code-generation">Source Code Generation</h3>
          <p>Source code can be generated by OCIO, which can then be used to create appropriate MaterialX nodes
            definitions. This is demonstrated in the<br>
            <a href="../pymaterialx/mtlx_ocio_notebook.html" target="_blank">OCIO notebook</a>.
          </p>
          <p>A standalone Python utility is also provided in the <a
              href="https://github.com/kwokcb/MaterialX_Learn/blob/main/pymaterialx/genOCIODefinitions.py"
              target="_blank">here</a>. The results of running this utility are provided <a
              href="https://github.com/kwokcb/MaterialX_Learn/tree/main/pymaterialx/OCIO_output"
              target="_blank">here</a>.</p>
          <p>
            Below is a screenshot of definitions being available in <code>MaterialX Graph Editor</code>,
            though the definitions could be used for any integration.
            <img src="images/ocio_transforms_in_grapheditor.png" width="80%">
          </p>
          <p>Some generation issues of note include:</p>
          <ol>
            <li>Reliance on texture lookups for color space transforms. Though it's possible to support the current
              color management system in MaterialX would need to have custom logic added. Additionally reliance on
              these lookups reduces portability to mobile and web platforms.</li>
            <li>The export of a single block of source code. If this is a single function then reuse is not an issue,
              but secondary functions may be added which could be duplications.</li>
            <li>Lack of support for code generation backends supported by MaterialX such as NVIDIA <code>MDL</code>
              and current versions of <code>OSL</code>.</li>
          </ol>
          <h3 id="functional-graph-generation">Functional Graph Generation</h3>
          <p>From a MaterialX perspective implementing color space transforms as a set of node graphs is the most
            portable and maintainable approach.</p>
          <p>As graphs, there is no need to write implementations for new code generation backends, and integrations
            which do not use code generation (such as <code>VEX</code> or <code>Unreal</code>) can just map their
            existing implementations of the nodes used to compose the graph.</p>
          <p>This is still an area of discussion and investigation.</p>

        </div>
      </div>
    </div>
  </div>
</div>
<!--End-->