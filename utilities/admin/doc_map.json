{
  "classes": {
    "MaterialX::AggregateTypeSyntax": "Specialization of TypeSyntax for aggregate types.",
    "MaterialX::AggregateValue": "A subclass for aggregate values with multiple members.",
    "MaterialX::AttributeDef": "An attribute definition element within a Document.",
    "MaterialX::Backdrop": "A layout element used to contain, group and document nodes within a graph.",
    "MaterialX::Camera": "A simple camera class, supporting transform matrices and arcball functionality for object-viewing applications.",
    "MaterialX::CgltfLoader": "Wrapper for loader to read in GLTF files using the Cgltf library.",
    "MaterialX::Collection": "A collection element within a Document.",
    "MaterialX::Color3": "A three-component color value.",
    "MaterialX::Color3d": "A three-component color value (double-precision)",
    "MaterialX::Color4": "A four-component color value.",
    "MaterialX::ColorManagementSystem": "Abstract base class for color management systems.",
    "MaterialX::CommentElement": "An element representing a block of descriptive text within a document, which will be stored a comment when the document is written out.\n\nThe comment text may be accessed with the methods Element::setDocString and Element::getDocString.",
    "MaterialX::CompoundNode": "Compound node implementation.",
    "MaterialX::DefaultColorManagementSystem": "Class for a default color management system.",
    "MaterialX::Document": "A MaterialX document, which represents the top-level element in the MaterialX ownership hierarchy.\n\nUse the factory function createDocument() to create a Document instance.",
    "MaterialX::Edge": "An edge between two connected Elements, returned during graph traversal.",
    "MaterialX::Element": "The base class for MaterialX elements.\n\nAn Element is a named object within a Document, which may possess any number of child elements and attributes.",
    "MaterialX::ElementEquivalenceOptions": "A set of options for comparing the functional equivalence of elements.",
    "MaterialX::EsslShaderGenerator": "An ESSL (OpenGL ES Shading Language) shader generator.",
    "MaterialX::EsslSyntax": "Syntax class for ESSL (OpenGL ES Shading Language)",
    "MaterialX::Exception": "The base class for exceptions that are propagated from the MaterialX library to the client application.",
    "MaterialX::ExceptionFileMissing": "An exception that is thrown when a requested file cannot be opened.",
    "MaterialX::ExceptionFoundCycle": "An exception that is thrown when a traversal call encounters a cycle.",
    "MaterialX::ExceptionOrphanedElement": "An exception that is thrown when an ElementPtr is used after its owning Document has gone out of scope.",
    "MaterialX::ExceptionParseError": "An exception that is thrown when a requested document cannot be parsed.",
    "MaterialX::ExceptionRenderError": "An exception that is thrown when a rendering operation fails.\n\nOptionally stores an additional error log, which can be used to store and retrieve shader compilation errors.",
    "MaterialX::ExceptionShaderGenError": "An exception that is thrown when shader generation fails.",
    "MaterialX::ExceptionTypeError": "An exception that is thrown when a type mismatch is encountered.",
    "MaterialX::Factory": "Factory class for creating instances of classes given their type name.",
    "MaterialX::FilePath": "A generic file path, supporting both syntactic and file system operations.",
    "MaterialX::FileSearchPath": "A sequence of file paths, which may be queried to find the first instance of a given filename on the file system.",
    "MaterialX::GenericElement": "A generic element subclass, for instantiating elements with unrecognized categories.",
    "MaterialX::GenContext": "A context class for shader generation.\n\nUsed for thread local storage of data needed during shader generation.",
    "MaterialX::GenMdlOptions": "Generator context data class to pass strings.",
    "MaterialX::GenOptions": "Class holding options to configure shader generation.",
    "MaterialX::GenUserData": "Base class for custom user data needed during shader generation.",
    "MaterialX::GeometryHandler": "Class which holds a set of geometry loaders.\n\nEach loader is associated with a given set of file extensions.",
    "MaterialX::GeometryLoader": "Base class representing a geometry loader.\n\nA loader can be associated with one or more file extensions.",
    "MaterialX::GeomElement": "The base class for geometric elements, which support bindings to geometries and geometric collections.",
    "MaterialX::GeomInfo": "A geometry info element within a Document.",
    "MaterialX::GeomPath": "A MaterialX geometry path, representing the hierarchical location expressed by a geometry name.",
    "MaterialX::GeomProp": "A geometric property element within a GeomInfo.",
    "MaterialX::GeomPropDef": "An element representing a declaration of geometric property data.\n\nA GeomPropDef element contains a reference to a geometric node and a set of modifiers for that node. For example, a world-space normal can be declared as a reference to the \"normal\" geometric node with a space setting of \"world\", or a specific set of texture coordinates can be declared as a reference to the \"texcoord\" geometric node with an index setting of \"1\".",
    "MaterialX::GlslMaterial": "Helper class for GLSL generation and rendering of a material.",
    "MaterialX::GlslProgram": "A class representing an executable GLSL program.\n\nThere are two main interfaces which can be used. One which takes in a HwShader and one which allows for explicit setting of shader stage code.",
    "MaterialX::GlslRenderer": "Helper class for rendering generated GLSL code to produce images.\n\nThere are two main interfaces which can be used. One which takes in a HwShader and one which allows for explicit setting of shader stage code.\n\nThe main services provided are: Validation: All shader stages are compiled and atteched to a GLSL shader program. Introspection: The compiled shader program is examined for uniforms and attributes. Binding: Uniforms and attributes which match the predefined variables generated the GLSL code generator will have values assigned to this. This includes matrices, attribute streams, and textures. Rendering: The program with bound inputs will be used to drawing geometry to an offscreen buffer. An interface is provided to save this offscreen buffer to disk using an externally defined image handler.",
    "MaterialX::GlslResourceBindingContext": "Class representing a resource binding for Glsl shader resources.",
    "MaterialX::GlslShaderGenerator": "Base class for GLSL (OpenGL Shading Language) code generation.\n\nA generator for a specific GLSL target should be derived from this class.",
    "MaterialX::GlslStructTypeSyntax": "Specialization of TypeSyntax for aggregate types.",
    "MaterialX::GlslSyntax": "Syntax class for GLSL (OpenGL Shading Language)",
    "MaterialX::GraphElement": "The base class for graph elements such as NodeGraph and Document.",
    "MaterialX::GraphIterator": "An iterator object representing the state of an upstream graph traversal.",
    "MaterialX::GLContext": "An OpenGL context singleton.",
    "MaterialX::GLFramebuffer": "Wrapper for an OpenGL framebuffer.",
    "MaterialX::GLTextureHandler": "An OpenGL texture handler class.",
    "MaterialX::Half": "A lightweight 16-bit half-precision float class.\n\nBased on the public-domain implementation by Paul Tessier.",
    "MaterialX::Image": "Class representing an image in system memory.",
    "MaterialX::ImageHandler": "Base image handler class.\n\nKeeps track of images which are loaded from disk via supplied ImageLoader. Derived classes are responsible for determining how to perform the logic for \"binding\" of these resources for a given target (such as a given shading language).",
    "MaterialX::ImageLoader": "Abstract base class for file-system image loaders.",
    "MaterialX::ImageSamplingProperties": "Interface to describe sampling properties for images.",
    "MaterialX::Implementation": "An implementation element within a Document.\n\nAn Implementation is used to associate external source code with a specific NodeDef, providing a definition for the node that may either be universal or restricted to a specific target.",
    "MaterialX::InheritanceIterator": "An iterator object representing the current state of an inheritance traversal.",
    "MaterialX::Input": "An input element within a Node or NodeDef.\n\nAn Input holds either a uniform value or a connection to a spatially-varying Output, either of which may be modified within the scope of a Material.",
    "MaterialX::InterfaceElement": "The base class for interface elements such as Node, NodeDef, and NodeGraph.\n\nAn InterfaceElement supports a set of Input and Output elements, with an API for setting their values.",
    "MaterialX::LightHandler": "Utility light handler for creating and providing light data for shader binding.",
    "MaterialX::LinearUnitConverter": "A converter class for linear units that require only a scalar multiplication.",
    "MaterialX::Look": "A look element within a Document.",
    "MaterialX::LookGroup": "A look group element within a Document.",
    "MaterialX::MaterialAssign": "A material assignment element within a Look.",
    "MaterialX::MaterialNode": "Material node implementation.",
    "MaterialX::Matrix33": "A 3x3 matrix of floating-point values.\n\nVector transformation methods follow the row-vector convention, with matrix-vector multiplication computed as v' = vM.",
    "MaterialX::Matrix44": "A 4x4 matrix of floating-point values.\n\nVector transformation methods follow the row-vector convention, with matrix-vector multiplication computed as v' = vM.",
    "MaterialX::MatrixBase": "The base class for square matrices of scalar values.",
    "MaterialX::MatrixN": "The class template for square matrices of scalar values.\n\nInherited by Matrix33 and Matrix44.\n\nThe elements of a MatrixN are stored in row-major order, and may be accessed using the syntax matrix[row][column].\n\nTemplate parameter M is the matrix subclass, S is the scalar element type, and N is the number of rows and columns in the matrix.",
    "MaterialX::MdlShaderGenerator": "Shader generator for MDL (Material Definition Language).",
    "MaterialX::MdlStructTypeSyntax": "Specialization of TypeSyntax for aggregate types.",
    "MaterialX::MdlSyntax": "Syntax class for MDL (Material Definition Language)",
    "MaterialX::Member": "A member element within a TypeDef.",
    "MaterialX::Mesh": "Container for mesh data.",
    "MaterialX::MeshPartition": "Class that describes a sub-region of a mesh using vertex indexing.\n\nNote that a face is considered to be a triangle.",
    "MaterialX::MeshStream": "Class to represent a mesh data stream.",
    "MaterialX::NewlineElement": "An element representing a newline within a document.",
    "MaterialX::Node": "A node element within a NodeGraph or Document.\n\nA Node represents an instance of a NodeDef within a graph, and its Input elements apply specific values and connections to that instance.",
    "MaterialX::NodeDef": "A node definition element within a Document.\n\nA NodeDef provides the declaration of a node interface, which may then be instantiated as a Node.",
    "MaterialX::NodeGraph": "A node graph element within a Document.",
    "MaterialX::NopNode": "A no operation node, to be used for organizational nodes that has no code to execute.",
    "MaterialX::OslRenderer": "Helper class for rendering generated OSL code to produce images.\n\nThe main services provided are: Source code validation: Use of \"oslc\" to compile and test output results Introspection check: None at this time. Binding: None at this time. Render validation: Use of \"testrender\" to output rendered images. Assumes source compilation was success as it depends on the existence of corresponding .oso files.",
    "MaterialX::OslShaderGenerator": "Base class for OSL (Open Shading Language) shader generators.\n\nA generator for a specific OSL target should be derived from this class.",
    "MaterialX::OslSyntax": "Syntax class for OSL (Open Shading Language)",
    "MaterialX::Output": "A spatially-varying output element within a NodeGraph or NodeDef.",
    "MaterialX::PortElement": "The base class for port elements such as Input and Output.\n\nPort elements support spatially-varying upstream connections to nodes.",
    "MaterialX::Property": "A property element within a PropertySet.",
    "MaterialX::PropertyAssign": "A property assignment element within a Look.",
    "MaterialX::PropertySet": "A property set element within a Document.",
    "MaterialX::PropertySetAssign": "A property set assignment element within a Look.",
    "MaterialX::Quaternion": "A quaternion vector.",
    "MaterialX::ScalarTypeSyntax": "Specialization of TypeSyntax for scalar types.",
    "MaterialX::ScopedFloatFormatting": "An RAII class for controlling the float formatting of values.",
    "MaterialX::ScopedSetVariableName": "A RAII class for overriding port variable names.",
    "MaterialX::ScopedTimer": "A class for scoped event timing.",
    "MaterialX::Shader": "Class containing all data needed during shader generation.\n\nAfter generation is completed it will contain the resulting source code emitted by shader generators.\n\nThe class contains a default implementation using a single shader stage. Derived shaders can override this, as well as overriding all methods that add code to the shader.",
    "MaterialX::ShaderGenerator": "Base class for shader generators All third-party shader generators should derive from this class.\n\nDerived classes should use DECLARE_SHADER_GENERATOR / DEFINE_SHADER_GENERATOR in their declaration / definition, and register with the Registry class.",
    "MaterialX::ShaderGraph": "Class representing a graph (DAG) for shader generation.",
    "MaterialX::ShaderGraphEdge": "An edge returned during shader graph traversal.",
    "MaterialX::ShaderGraphEdgeIterator": "Iterator class for traversing edges between nodes in a shader graph.",
    "MaterialX::ShaderInput": "An input on a ShaderNode.",
    "MaterialX::ShaderMaterial": "Abstract class for shader generation and rendering of a ShaderMaterial.",
    "MaterialX::ShaderMetadataRegistry": "A registry for metadata that will be exported to the generated shader if found on nodes and inputs during shader generation.",
    "MaterialX::ShaderNode": "Class representing a node in the shader generation DAG.",
    "MaterialX::ShaderNode::Classification": "Flags for classifying nodes into different categories.",
    "MaterialX::ShaderNodeImpl": "Class handling the shader generation implementation for a node.\n\nResponsible for emitting the function definition and function call that is the node implementation.",
    "MaterialX::ShaderOutput": "An output on a ShaderNode.",
    "MaterialX::ShaderPort": "An input or output port on a ShaderNode.",
    "MaterialX::ShaderPortFlag": "Flags set on shader ports.",
    "MaterialX::ShaderRenderer": "Base class for renderers that generate shader code to produce images.",
    "MaterialX::ShaderStage": "A shader stage, containing the state and resulting source code for the stage.",
    "MaterialX::ShaderTranslator": "A helper class for translating content between shading models.",
    "MaterialX::ShadowState": "Helper class representing shadow rendering state.",
    "MaterialX::ShCoeffs": "Class template for a vector of spherical harmonic coefficients.\n\nTemplate parameter C is the coefficient type (e.g. double, Color3). Template parameter B is the number of spherical harmonic bands.",
    "MaterialX::SimpleWindow": "A platform-independent window class.\n\nPlaform-specific resources are encapsulated by a WindowWrapper instance.",
    "MaterialX::SourceCodeNode": "Implementation for a node using data-driven static source code.\n\nThis is the default implementation used for all nodes that do not have a custom ShaderNodeImpl class.",
    "MaterialX::StbImageLoader": "Stb image file loader.",
    "MaterialX::StringResolver": "A helper object for applying string modifiers to data values in the context of a specific element and geometry.\n\nA StringResolver may be constructed through the Element::createStringResolver method, which initializes it in the context of a specific element, geometry, and material.\n\nCalling the StringResolver::resolve method applies all modifiers to a particular string value.\n\nMethods such as StringResolver::setFilePrefix may be used to edit the stored string modifiers before calling StringResolver::resolve.",
    "MaterialX::StringTypeSyntax": "Specialization of TypeSyntax for string types.",
    "MaterialX::StructMemberDesc": "Type descriptor for member of a struct type.",
    "MaterialX::StructTypeSyntax": "Specialization of TypeSyntax for struct types.",
    "MaterialX::Syntax": "Base class for syntax objects used by shader generators to emit code with correct syntax for each language.",
    "MaterialX::TargetDef": "A definition of an implementation target.",
    "MaterialX::TextureBaker": "A helper class for baking procedural material content to textures.\n\nTODO: Add support for graphs containing geometric nodes such as position and normal.",
    "MaterialX::TextureBakerGlsl": "An implementation of TextureBaker based on GLSL shader generation.",
    "MaterialX::TinyObjLoader": "Wrapper for geometry loader to read in OBJ files using the TinyObj library.",
    "MaterialX::Token": "A token element representing a string value.\n\nToken elements are used to define input and output values for string substitutions in image filenames.",
    "MaterialX::TreeIterator": "An iterator object representing the state of a tree traversal.",
    "MaterialX::TypedElement": "The base class for typed elements.",
    "MaterialX::TypedValue": "The class template for typed subclasses of Value.",
    "MaterialX::TypeDef": "A type definition element within a Document.",
    "MaterialX::TypeDesc": "A type descriptor for MaterialX data types.\n\nAll types need to have a type descriptor registered in order for shader generators to know about the type. It can be used for type comparisons as well as getting more information about the type. Type descriptors for all standard library data types are defined by default and can be accessed from the Type namespace, e.g. Type::FLOAT. Custom struct types defined through typedef elements in a data library are loaded in and registered by calling the ShaderGenerator::registerTypeDefs method. The TypeSystem class, see below, is used to manage all type descriptions. It can be used to query the registered types.",
    "MaterialX::TypeDesc::DataBlock": "Data block holding large data needed by the type description.",
    "MaterialX::TypeSyntax": "Base class for syntax handling of types.",
    "MaterialX::TypeSystem": "Class handling registration, storage and query of type descriptions.",
    "MaterialX::Uninit": "A tag class for constructing vectors and matrices without initialization.",
    "MaterialX::Unit": "A unit declaration within a UnitDef.",
    "MaterialX::UnitConverter": "An abstract base class for unit converters.\n\nEach unit converter instance is responsible for a single unit type.",
    "MaterialX::UnitConverterRegistry": "A registry for unit converters.",
    "MaterialX::UnitDef": "A unit definition element within a Document.",
    "MaterialX::UnitSystem": "Base unit system support.",
    "MaterialX::UnitTypeDef": "A unit type definition element within a Document.",
    "MaterialX::Value": "A generic, discriminated value, whose type may be queried dynamically.",
    "MaterialX::ValueElement": "The base class for elements that support typed values.",
    "MaterialX::VariableBlock": "A block of variables in a shader stage.",
    "MaterialX::Variant": "A variant element within a VariantSet.",
    "MaterialX::VariantAssign": "A variant assignment element within a Look.",
    "MaterialX::VariantSet": "A variant set element within a Document.",
    "MaterialX::Vector2": "A vector of two floating-point values.",
    "MaterialX::Vector3": "A vector of three floating-point values.",
    "MaterialX::Vector3d": "A vector of three floating-point values (double-precision)",
    "MaterialX::Vector4": "A vector of four floating-point values.",
    "MaterialX::Vector4d": "A vector of four floating-point values (double-precision)",
    "MaterialX::VectorBase": "The base class for vectors of scalar values.",
    "MaterialX::VectorN": "The class template for vectors of scalar values.\n\nInherited by Vector2, Vector3, Vector4, Color3, and Color4.\n\nTemplate parameter V is the vector subclass, S is the scalar element type, and N is the number of scalar elements in the vector.",
    "MaterialX::VectorN::Hash": "Function object for hashing vectors.",
    "MaterialX::Visibility": "A visibility element within a Look.\n\nA Visibility describes the visibility relationship between two geometries or geometric collections.",
    "MaterialX::VkResourceBindingContext": "Class representing a resource binding for Vulkan Glsl shader resources.",
    "MaterialX::VkShaderGenerator": "A Vulkan GLSL shader generator.",
    "MaterialX::VkSyntax": "Syntax class for Vulkan GLSL.",
    "MaterialX::WgslResourceBindingContext": "Class representing a resource binding for Vulkan Glsl shader resources.",
    "MaterialX::WgslShaderGenerator": "WGSL Flavor of Vulkan GLSL shader generator",
    "MaterialX::WgslSyntax": "Syntax class for Wgsl GLSL.",
    "MaterialX::WindowWrapper": "Generic wrapper for encapsulating a \"window\" construct.\n\nEach supported platform will have specific storage and management logic.",
    "MaterialX::XmlReadOptions": "A set of options for controlling the behavior of XML read functions.",
    "MaterialX::XmlWriteOptions": "A set of options for controlling the behavior of XML write functions.",
    "MaterialX::ColorSpaceTransform": "Structure that represents color space transform information.",
    "MaterialX::GlslProgram::Input": "Structure to hold information about program inputs.\n\nThe structure is populated by directly scanning the program so may not contain some inputs listed on any associated HwShader as those inputs may have been optimized out if they are unused.",
    "MaterialX::ImageSamplingKeyHasher": "Class used for hashing ImageSamplingProperties in an unordered_map.",
    "MaterialX::ShaderMetadata": "Metadata to be exported to generated shader.",
    "MaterialX::TypeDesc::Hasher": "Hash operator.",
    "MaterialX::UnitTransform": "Structure that represents unit transform information.",
    "MaterialX::UIProperties": "Set of possible UI properties for an element.",
    "MaterialX::UIPropertyItem": "Interface for holding the UI properties associated shader port."
  },
  "functions": {
    "MaterialX::AggregateTypeSyntax::AggregateTypeSyntax": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const Syntax *parent,const string &name,const string &defaultValue,const string &uniformDefaultValue,const string &typeAlias=EMPTY_STRING,const string &typeDefinition=EMPTY_STRING,const StringVec &members=EMPTY_MEMBERS)"
    },
    "MaterialX::AggregateTypeSyntax::getValue": {
      "brief": "Returns a value formatted according to this type syntax.",
      "detail": "The value is constructed from the given value object.",
      "params": {},
      "returns": "",
      "args_sig": "(const Value &value,bool uniform) const override"
    },
    "MaterialX::AggregateValue::AggregateValue": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &typeName)"
    },
    "MaterialX::AggregateValue::~AggregateValue": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::AggregateValue::copy": {
      "brief": "Create a deep copy of the value.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const override"
    },
    "MaterialX::AggregateValue::appendValue": {
      "brief": "Append a member value to the aggregate.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(ConstValuePtr valuePtr)"
    },
    "MaterialX::AggregateValue::getMembers": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::AggregateValue::getMemberValue": {
      "brief": "Query an indexed member value from the aggregate.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(size_t index) const"
    },
    "MaterialX::AggregateValue::getTypeString": {
      "brief": "Return type string.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const override"
    },
    "MaterialX::AggregateValue::getValueString": {
      "brief": "Return value string.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const override"
    },
    "MaterialX::AggregateValue::isEqual": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(ConstValuePtr other) const override"
    },
    "MaterialX::AggregateValue::createAggregateValue": {
      "brief": "Create a new value from an object of any valid MaterialX type.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &typeName)"
    },
    "MaterialX::AggregateValue::createAggregateValueFromString": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &value,const string &type,ConstTypeDefPtr typeDefPtr)"
    },
    "MaterialX::AttributeDef::setAttrName": {
      "brief": "Set the element's attrname string.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &name)"
    },
    "MaterialX::AttributeDef::hasAttrName": {
      "brief": "Return true if this element has an attrname string.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::AttributeDef::getAttrName": {
      "brief": "Return the element's attrname string.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::AttributeDef::setValueString": {
      "brief": "Set the value string of an element.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &value)"
    },
    "MaterialX::AttributeDef::hasValueString": {
      "brief": "Return true if the given element has a value string.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::AttributeDef::getValueString": {
      "brief": "Get the value string of a element.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::AttributeDef::setValue": {
      "brief": "Set the typed value of an element from a C-style string.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const char *value,const string &type=EMPTY_STRING)"
    },
    "MaterialX::AttributeDef::hasValue": {
      "brief": "Return true if the element possesses a typed value.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::AttributeDef::getValue": {
      "brief": "Return the typed value of an element as a generic value object, which may be queried to access its data.",
      "detail": "",
      "params": {},
      "returns": "A shared pointer to the typed value of this element, or an empty shared pointer if no value is present.",
      "args_sig": "() const"
    },
    "MaterialX::AttributeDef::setElements": {
      "brief": "Set the element's elements string.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &elements)"
    },
    "MaterialX::AttributeDef::hasElements": {
      "brief": "Return true if the element has an elements string.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::AttributeDef::getElements": {
      "brief": "Return the element's elements string.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::AttributeDef::setExportable": {
      "brief": "Set the exportable boolean for the element.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(bool value)"
    },
    "MaterialX::AttributeDef::getExportable": {
      "brief": "Return the exportable boolean for the element.",
      "detail": "Defaults to false if exportable is not set.",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::AttributeDef::AttributeDef": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(ElementPtr parent,const string &name)"
    },
    "MaterialX::AttributeDef::~AttributeDef": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::Backdrop::setContainsString": {
      "brief": "Set the contains string for this backdrop.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &contains)"
    },
    "MaterialX::Backdrop::hasContainsString": {
      "brief": "Return true if this backdrop has a contains string.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::Backdrop::getContainsString": {
      "brief": "Return the contains string for this backdrop.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::Backdrop::setWidth": {
      "brief": "Set the width attribute of the backdrop.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(float width)"
    },
    "MaterialX::Backdrop::hasWidth": {
      "brief": "Return true if this backdrop has a width attribute.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::Backdrop::getWidth": {
      "brief": "Return the width attribute of the backdrop.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::Backdrop::setHeight": {
      "brief": "Set the height attribute of the backdrop.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(float height)"
    },
    "MaterialX::Backdrop::hasHeight": {
      "brief": "Return true if this backdrop has a height attribute.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::Backdrop::getHeight": {
      "brief": "Return the height attribute of the backdrop.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::Backdrop::setContainsElements": {
      "brief": "Set the vector of elements that this backdrop contains.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const vector< ConstTypedElementPtr > &nodes)"
    },
    "MaterialX::Backdrop::getContainsElements": {
      "brief": "Return the vector of elements that this backdrop contains.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::Backdrop::validate": {
      "brief": "Validate that the given element tree, including all descendants, is consistent with the MaterialX specification.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(string *message=nullptr) const override"
    },
    "MaterialX::Backdrop::Backdrop": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(ElementPtr parent,const string &name)"
    },
    "MaterialX::Backdrop::~Backdrop": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::Camera::setWorldMatrix": {
      "brief": "Set the world matrix.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const Matrix44 &mat)"
    },
    "MaterialX::Camera::getWorldMatrix": {
      "brief": "Return the world matrix.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::Camera::setViewMatrix": {
      "brief": "Set the view matrix.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const Matrix44 &mat)"
    },
    "MaterialX::Camera::getViewMatrix": {
      "brief": "Return the view matrix.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::Camera::setProjectionMatrix": {
      "brief": "Set the projection matrix.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const Matrix44 &mat)"
    },
    "MaterialX::Camera::getProjectionMatrix": {
      "brief": "Return the projection matrix.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::Camera::getWorldViewProjMatrix": {
      "brief": "Compute our full model-view-projection matrix.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::Camera::getViewPosition": {
      "brief": "Derive viewer position from the view matrix.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::Camera::getViewDirection": {
      "brief": "Derive viewer direction from the view matrix.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::Camera::setViewportSize": {
      "brief": "Set the size of the viewport window.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const Vector2 &size)"
    },
    "MaterialX::Camera::getViewportSize": {
      "brief": "Return the size of the viewport window.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::Camera::projectToViewport": {
      "brief": "Project a position from object to viewport space.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(Vector3 v)"
    },
    "MaterialX::Camera::unprojectFromViewport": {
      "brief": "Unproject a position from viewport to object space.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(Vector3 v)"
    },
    "MaterialX::Camera::arcballButtonEvent": {
      "brief": "Indicates a button state change, with pos being the instantaneous location of the mouse.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const Vector2 &pos,bool pressed)"
    },
    "MaterialX::Camera::applyArcballMotion": {
      "brief": "Apply mouse motion to the arcball state.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const Vector2 &pos)"
    },
    "MaterialX::Camera::arcballMatrix": {
      "brief": "Return the arcball matrix.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::Camera::createViewMatrix": {
      "brief": "Create a view matrix given an eye position, a target position and an up vector.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const Vector3 &eye,const Vector3 &target,const Vector3 &up)"
    },
    "MaterialX::Camera::createPerspectiveMatrix": {
      "brief": "Create a perspective projection matrix given a set of clip planes with [-1,1] projected Z.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(float left,float right,float bottom,float top,float nearP,float farP)"
    },
    "MaterialX::Camera::createOrthographicMatrix": {
      "brief": "Create an orthographic projection matrix given a set of clip planes with [-1,1] projected Z.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(float left,float right,float bottom,float top,float nearP,float farP)"
    },
    "MaterialX::Camera::createPerspectiveMatrixZP": {
      "brief": "Create a perspective projection matrix given a set of clip planes with [0,1] projected Z.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(float left,float right,float bottom,float top,float nearP,float farP)"
    },
    "MaterialX::Camera::createOrthographicMatrixZP": {
      "brief": "Create an orthographic projection matrix given a set of clip planes with [0,1] projected Z.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(float left,float right,float bottom,float top,float nearP,float farP)"
    },
    "MaterialX::Camera::transformPointPerspective": {
      "brief": "Apply a perspective transform to the given 3D point, performing a homogeneous divide on the transformed result.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const Matrix44 &m,const Vector3 &v)"
    },
    "MaterialX::Camera::Camera": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::Camera::~Camera": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()=default"
    },
    "MaterialX::Camera::create": {
      "brief": "Create a new camera.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::CgltfLoader::CgltfLoader": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::CgltfLoader::~CgltfLoader": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::CgltfLoader::load": {
      "brief": "Load geometry from file path.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const FilePath &filePath,MeshList &meshList,bool texcoordVerticalFlip=false) override"
    },
    "MaterialX::CgltfLoader::create": {
      "brief": "Create a new loader.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::Collection::setIncludeGeom": {
      "brief": "Set the include geometry string of this element.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &geom)"
    },
    "MaterialX::Collection::hasIncludeGeom": {
      "brief": "Return true if this element has an include geometry string.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::Collection::getIncludeGeom": {
      "brief": "Return the include geometry string of this element.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::Collection::getActiveIncludeGeom": {
      "brief": "Return the active include geometry string of this element, taking all geometry string substitutions at this scope into account.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::Collection::setExcludeGeom": {
      "brief": "Set the exclude geometry string of this element.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &geom)"
    },
    "MaterialX::Collection::hasExcludeGeom": {
      "brief": "Return true if this element has an exclude geometry string.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::Collection::getExcludeGeom": {
      "brief": "Return the exclude geometry string of this element.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::Collection::getActiveExcludeGeom": {
      "brief": "Return the active exclude geometry string of this element, taking all geometry string substitutions at this scope into account.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::Collection::setIncludeCollectionString": {
      "brief": "Set the include collection string of this element.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &collection)"
    },
    "MaterialX::Collection::hasIncludeCollectionString": {
      "brief": "Return true if this element has an include collection string.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::Collection::getIncludeCollectionString": {
      "brief": "Return the include collection string of this element.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::Collection::setIncludeCollection": {
      "brief": "Set the collection that is directly included by this element.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(ConstCollectionPtr collection)"
    },
    "MaterialX::Collection::setIncludeCollections": {
      "brief": "Set the vector of collections that are directly included by this element.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const vector< ConstCollectionPtr > &collections)"
    },
    "MaterialX::Collection::getIncludeCollections": {
      "brief": "Return the vector of collections that are directly included by this element.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::Collection::hasIncludeCycle": {
      "brief": "Return true if the include chain for this element contains a cycle.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::Collection::matchesGeomString": {
      "brief": "Return true if this collection and the given geometry string have any geometries in common.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &geom) const"
    },
    "MaterialX::Collection::validate": {
      "brief": "Validate that the given element tree, including all descendants, is consistent with the MaterialX specification.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(string *message=nullptr) const override"
    },
    "MaterialX::Collection::Collection": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(ElementPtr parent,const string &name)"
    },
    "MaterialX::Collection::~Collection": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::Color3::Color3": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(float r,float g,float b)"
    },
    "MaterialX::Color3::linearToSrgb": {
      "brief": "Transform the given color from linear RGB to the sRGB encoding, returning the result as a new value.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::Color3::srgbToLinear": {
      "brief": "Transform the given color from the sRGB encoding to linear RGB, returning the result as a new value.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::Color3d::Color3d": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(double r,double g,double b)"
    },
    "MaterialX::Color4::Color4": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(float r,float g,float b,float a)"
    },
    "MaterialX::ColorManagementSystem::~ColorManagementSystem": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::ColorManagementSystem::getName": {
      "brief": "Return the ColorManagementSystem name.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const =0"
    },
    "MaterialX::ColorManagementSystem::loadLibrary": {
      "brief": "Load a library of implementations from the provided document, replacing any previously loaded content.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(DocumentPtr document)"
    },
    "MaterialX::ColorManagementSystem::supportsTransform": {
      "brief": "Returns whether this color management system supports a provided transform.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const ColorSpaceTransform &transform) const"
    },
    "MaterialX::ColorManagementSystem::createNode": {
      "brief": "Create a node to use to perform the given color space transformation.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const ShaderGraph *parent,const ColorSpaceTransform &transform,const string &name,GenContext &context) const"
    },
    "MaterialX::ColorManagementSystem::hasImplementation": {
      "brief": "Returns true if the CMS can create a shader node implementation for a locally managed CMS transform.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &) const"
    },
    "MaterialX::ColorManagementSystem::createImplementation": {
      "brief": "Create an CMS node implementation for a locally managed transform.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &) const"
    },
    "MaterialX::ColorManagementSystem::ColorManagementSystem": {
      "brief": "Protected constructor.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::ColorManagementSystem::getNodeDef": {
      "brief": "Returns a nodedef for a given transform.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const ColorSpaceTransform &transform) const =0"
    },
    "MaterialX::CommentElement::CommentElement": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(ElementPtr parent,const string &name)"
    },
    "MaterialX::CommentElement::~CommentElement": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::CompoundNode::create": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::CompoundNode::initialize": {
      "brief": "Initialize with the given implementation element.",
      "detail": "Initialization must set the name and hash for the implementation, as well as any other data needed to emit code for the node.",
      "params": {},
      "returns": "",
      "args_sig": "(const InterfaceElement &element,GenContext &context) override"
    },
    "MaterialX::CompoundNode::addClassification": {
      "brief": "Add additional classifications on a node.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(ShaderNode &node) const override"
    },
    "MaterialX::CompoundNode::createVariables": {
      "brief": "Create shader variables needed for the implementation of this node (e.g.",
      "detail": "uniforms, inputs and outputs). Used if the node requires input data from the application.",
      "params": {},
      "returns": "",
      "args_sig": "(const ShaderNode &node,GenContext &context,Shader &shader) const override"
    },
    "MaterialX::CompoundNode::emitFunctionDefinition": {
      "brief": "Emit function definition for the given node instance.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const ShaderNode &node,GenContext &context,ShaderStage &stage) const override"
    },
    "MaterialX::CompoundNode::emitFunctionCall": {
      "brief": "Emit the function call or inline source code for given node instance in the given context.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const ShaderNode &node,GenContext &context,ShaderStage &stage) const override"
    },
    "MaterialX::CompoundNode::getGraph": {
      "brief": "Return a pointer to the graph if this implementation is using a graph, or returns nullptr otherwise.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const override"
    },
    "MaterialX::DefaultColorManagementSystem::~DefaultColorManagementSystem": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::DefaultColorManagementSystem::getName": {
      "brief": "Return the DefaultColorManagementSystem name.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const override"
    },
    "MaterialX::DefaultColorManagementSystem::create": {
      "brief": "Create a new DefaultColorManagementSystem.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &target)"
    },
    "MaterialX::DefaultColorManagementSystem::getNodeDef": {
      "brief": "Returns a nodedef for a given transform.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const ColorSpaceTransform &transform) const override"
    },
    "MaterialX::DefaultColorManagementSystem::DefaultColorManagementSystem": {
      "brief": "Protected constructor.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &target)"
    },
    "MaterialX::Document::setDataLibrary": {
      "brief": "Store a reference to a data library in this document.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(ConstDocumentPtr dataLibrary)"
    },
    "MaterialX::Document::hasDataLibrary": {
      "brief": "Return true if this document has a data library.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::Document::getDataLibrary": {
      "brief": "Return the data library, if any, referenced by this document.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::Document::importLibrary": {
      "brief": "Import the given data library into this document.",
      "detail": "",
      "params": {
        "library": "The data library to be imported."
      },
      "returns": "",
      "args_sig": "(const ConstDocumentPtr &library)"
    },
    "MaterialX::Document::addNodeGraph": {
      "brief": "Add a NodeGraph to the document.",
      "detail": "",
      "params": {
        "name": "The name of the new NodeGraph. If no name is specified, then a unique name will automatically be generated."
      },
      "returns": "A shared pointer to the new NodeGraph.",
      "args_sig": "(const string &name=EMPTY_STRING)"
    },
    "MaterialX::Document::getNodeGraph": {
      "brief": "Return the NodeGraph, if any, with the given name.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &name) const"
    },
    "MaterialX::Document::getNodeGraphs": {
      "brief": "Return a vector of all NodeGraph elements in the document.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::Document::removeNodeGraph": {
      "brief": "Remove the NodeGraph, if any, with the given name.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &name)"
    },
    "MaterialX::Document::getMatchingPorts": {
      "brief": "Return a vector of all port elements that match the given node name.",
      "detail": "Port elements support spatially-varying upstream connections to nodes, and include both Input and Output elements.",
      "params": {},
      "returns": "",
      "args_sig": "(const string &nodeName) const"
    },
    "MaterialX::Document::addGeomInfo": {
      "brief": "Add a GeomInfo to the document.",
      "detail": "",
      "params": {
        "name": "The name of the new GeomInfo. If no name is specified, then a unique name will automatically be generated.",
        "geom": "An optional geometry string for the GeomInfo."
      },
      "returns": "A shared pointer to the new GeomInfo.",
      "args_sig": "(const string &name=EMPTY_STRING,const string &geom=UNIVERSAL_GEOM_NAME)"
    },
    "MaterialX::Document::getGeomInfo": {
      "brief": "Return the GeomInfo, if any, with the given name.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &name) const"
    },
    "MaterialX::Document::getGeomInfos": {
      "brief": "Return a vector of all GeomInfo elements in the document.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::Document::removeGeomInfo": {
      "brief": "Remove the GeomInfo, if any, with the given name.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &name)"
    },
    "MaterialX::Document::getGeomPropValue": {
      "brief": "Return the value of a geometric property for the given geometry string.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &geomPropName,const string &geom=UNIVERSAL_GEOM_NAME) const"
    },
    "MaterialX::Document::addGeomPropDef": {
      "brief": "Add a GeomPropDef to the document.",
      "detail": "",
      "params": {
        "name": "The name of the new GeomPropDef.",
        "geomprop": "The geometric property to use for the GeomPropDef."
      },
      "returns": "A shared pointer to the new GeomPropDef.",
      "args_sig": "(const string &name,const string &geomprop)"
    },
    "MaterialX::Document::getGeomPropDef": {
      "brief": "Return the GeomPropDef, if any, with the given name.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &name) const"
    },
    "MaterialX::Document::getGeomPropDefs": {
      "brief": "Return a vector of all GeomPropDef elements in the document.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::Document::removeGeomPropDef": {
      "brief": "Remove the GeomPropDef, if any, with the given name.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &name)"
    },
    "MaterialX::Document::getMaterialOutputs": {
      "brief": "Return material-type outputs for all nodegraphs in the document.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::Document::addLook": {
      "brief": "Add a Look to the document.",
      "detail": "",
      "params": {
        "name": "The name of the new Look. If no name is specified, then a unique name will automatically be generated."
      },
      "returns": "A shared pointer to the new Look.",
      "args_sig": "(const string &name=EMPTY_STRING)"
    },
    "MaterialX::Document::getLook": {
      "brief": "Return the Look, if any, with the given name.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &name) const"
    },
    "MaterialX::Document::getLooks": {
      "brief": "Return a vector of all Look elements in the document.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::Document::removeLook": {
      "brief": "Remove the Look, if any, with the given name.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &name)"
    },
    "MaterialX::Document::addLookGroup": {
      "brief": "Add a LookGroup to the document.",
      "detail": "",
      "params": {
        "name": "The name of the new LookGroup. If no name is specified, then a unique name will automatically be generated."
      },
      "returns": "A shared pointer to the new LookGroup.",
      "args_sig": "(const string &name=EMPTY_STRING)"
    },
    "MaterialX::Document::getLookGroup": {
      "brief": "Return the LookGroup, if any, with the given name.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &name) const"
    },
    "MaterialX::Document::getLookGroups": {
      "brief": "Return a vector of all LookGroup elements in the document.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::Document::removeLookGroup": {
      "brief": "Remove the LookGroup, if any, with the given name.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &name)"
    },
    "MaterialX::Document::addCollection": {
      "brief": "Add a Collection to the document.",
      "detail": "",
      "params": {
        "name": "The name of the new Collection. If no name is specified, then a unique name will automatically be generated."
      },
      "returns": "A shared pointer to the new Collection.",
      "args_sig": "(const string &name=EMPTY_STRING)"
    },
    "MaterialX::Document::getCollection": {
      "brief": "Return the Collection, if any, with the given name.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &name) const"
    },
    "MaterialX::Document::getCollections": {
      "brief": "Return a vector of all Collection elements in the document.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::Document::removeCollection": {
      "brief": "Remove the Collection, if any, with the given name.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &name)"
    },
    "MaterialX::Document::addTypeDef": {
      "brief": "Add a TypeDef to the document.",
      "detail": "",
      "params": {
        "name": "The name of the new TypeDef. If no name is specified, then a unique name will automatically be generated."
      },
      "returns": "A shared pointer to the new TypeDef.",
      "args_sig": "(const string &name)"
    },
    "MaterialX::Document::getTypeDef": {
      "brief": "Return the TypeDef, if any, with the given name.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &name) const"
    },
    "MaterialX::Document::getTypeDefs": {
      "brief": "Return a vector of all TypeDef elements in the document.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::Document::removeTypeDef": {
      "brief": "Remove the TypeDef, if any, with the given name.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &name)"
    },
    "MaterialX::Document::addNodeDef": {
      "brief": "Add a NodeDef to the document.",
      "detail": "",
      "params": {
        "name": "The name of the new NodeDef. If no name is specified, then a unique name will automatically be generated.",
        "type": "An optional type string. If specified, then the new NodeDef will be assigned an Output of the given type.",
        "node": "An optional node string."
      },
      "returns": "A shared pointer to the new NodeDef.",
      "args_sig": "(const string &name=EMPTY_STRING,const string &type=DEFAULT_TYPE_STRING,const string &node=EMPTY_STRING)"
    },
    "MaterialX::Document::addNodeDefFromGraph": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(NodeGraphPtr nodeGraph,const string &nodeDefName,const string &node,const string &version,bool isDefaultVersion,const string &nodeGroup,const string &newGraphName)"
    },
    "MaterialX::Document::getNodeDef": {
      "brief": "Return the NodeDef, if any, with the given name.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &name) const"
    },
    "MaterialX::Document::getNodeDefs": {
      "brief": "Return a vector of all NodeDef elements in the document.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::Document::removeNodeDef": {
      "brief": "Remove the NodeDef, if any, with the given name.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &name)"
    },
    "MaterialX::Document::getMatchingNodeDefs": {
      "brief": "Return a vector of all NodeDef elements that match the given node name.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &nodeName) const"
    },
    "MaterialX::Document::addAttributeDef": {
      "brief": "Add an AttributeDef to the document.",
      "detail": "",
      "params": {
        "name": "The name of the new AttributeDef. If no name is specified, then a unique name will automatically be generated."
      },
      "returns": "A shared pointer to the new AttributeDef.",
      "args_sig": "(const string &name=EMPTY_STRING)"
    },
    "MaterialX::Document::getAttributeDef": {
      "brief": "Return the AttributeDef, if any, with the given name.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &name) const"
    },
    "MaterialX::Document::getAttributeDefs": {
      "brief": "Return a vector of all AttributeDef elements in the document.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::Document::removeAttributeDef": {
      "brief": "Remove the AttributeDef, if any, with the given name.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &name)"
    },
    "MaterialX::Document::addTargetDef": {
      "brief": "Add an TargetDef to the document.",
      "detail": "",
      "params": {
        "name": "The name of the new TargetDef. If no name is specified, then a unique name will automatically be generated."
      },
      "returns": "A shared pointer to the new TargetDef.",
      "args_sig": "(const string &name=EMPTY_STRING)"
    },
    "MaterialX::Document::getTargetDef": {
      "brief": "Return the AttributeDef, if any, with the given name.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &name) const"
    },
    "MaterialX::Document::getTargetDefs": {
      "brief": "Return a vector of all TargetDef elements in the document.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::Document::removeTargetDef": {
      "brief": "Remove the TargetDef, if any, with the given name.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &name)"
    },
    "MaterialX::Document::addPropertySet": {
      "brief": "Add a PropertySet to the document.",
      "detail": "",
      "params": {
        "name": "The name of the new PropertySet. If no name is specified, then a unique name will automatically be generated."
      },
      "returns": "A shared pointer to the new PropertySet.",
      "args_sig": "(const string &name=EMPTY_STRING)"
    },
    "MaterialX::Document::getPropertySet": {
      "brief": "Return the PropertySet, if any, with the given name.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &name) const"
    },
    "MaterialX::Document::getPropertySets": {
      "brief": "Return a vector of all PropertySet elements in the document.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::Document::removePropertySet": {
      "brief": "Remove the PropertySet, if any, with the given name.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &name)"
    },
    "MaterialX::Document::addVariantSet": {
      "brief": "Add a VariantSet to the document.",
      "detail": "",
      "params": {
        "name": "The name of the new VariantSet. If no name is specified, then a unique name will automatically be generated."
      },
      "returns": "A shared pointer to the new VariantSet.",
      "args_sig": "(const string &name=EMPTY_STRING)"
    },
    "MaterialX::Document::getVariantSet": {
      "brief": "Return the VariantSet, if any, with the given name.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &name) const"
    },
    "MaterialX::Document::getVariantSets": {
      "brief": "Return a vector of all VariantSet elements in the document.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::Document::removeVariantSet": {
      "brief": "Remove the VariantSet, if any, with the given name.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &name)"
    },
    "MaterialX::Document::addImplementation": {
      "brief": "Add an Implementation to the document.",
      "detail": "",
      "params": {
        "name": "The name of the new Implementation. If no name is specified, then a unique name will automatically be generated."
      },
      "returns": "A shared pointer to the new Implementation.",
      "args_sig": "(const string &name=EMPTY_STRING)"
    },
    "MaterialX::Document::getImplementation": {
      "brief": "Return the Implementation, if any, with the given name.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &name) const"
    },
    "MaterialX::Document::getImplementations": {
      "brief": "Return a vector of all Implementation elements in the document.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::Document::removeImplementation": {
      "brief": "Remove the Implementation, if any, with the given name.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &name)"
    },
    "MaterialX::Document::getMatchingImplementations": {
      "brief": "Return a vector of all node implementations that match the given NodeDef string.",
      "detail": "Note that a node implementation may be either an Implementation element or NodeGraph element.",
      "params": {},
      "returns": "",
      "args_sig": "(const string &nodeDef) const"
    },
    "MaterialX::Document::addUnitDef": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &name)"
    },
    "MaterialX::Document::getUnitDef": {
      "brief": "Return the UnitDef, if any, with the given name.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &name) const"
    },
    "MaterialX::Document::getUnitDefs": {
      "brief": "Return a vector of all Member elements in the TypeDef.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::Document::removeUnitDef": {
      "brief": "Remove the UnitDef, if any, with the given name.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &name)"
    },
    "MaterialX::Document::addUnitTypeDef": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &name)"
    },
    "MaterialX::Document::getUnitTypeDef": {
      "brief": "Return the UnitTypeDef, if any, with the given name.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &name) const"
    },
    "MaterialX::Document::getUnitTypeDefs": {
      "brief": "Return a vector of all UnitTypeDef elements in the document.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::Document::removeUnitTypeDef": {
      "brief": "Remove the UnitTypeDef, if any, with the given name.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &name)"
    },
    "MaterialX::Document::getVersionIntegers": {
      "brief": "Return the major and minor versions as an integer pair.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const override"
    },
    "MaterialX::Document::upgradeVersion": {
      "brief": "Upgrade the content of this document from earlier supported versions to the library version.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::Document::setColorManagementSystem": {
      "brief": "Set the color management system string.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &cms)"
    },
    "MaterialX::Document::hasColorManagementSystem": {
      "brief": "Return true if a color management system string has been set.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::Document::getColorManagementSystem": {
      "brief": "Return the color management system string.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::Document::setColorManagementConfig": {
      "brief": "Set the color management config string.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &cmsConfig)"
    },
    "MaterialX::Document::hasColorManagementConfig": {
      "brief": "Return true if a color management config string has been set.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::Document::getColorManagementConfig": {
      "brief": "Return the color management config string.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::Document::validate": {
      "brief": "Validate that the given document is consistent with the MaterialX specification.",
      "detail": "",
      "params": {
        "message": "An optional output string, to which a description of each error will be appended."
      },
      "returns": "True if the document passes all tests, false otherwise.",
      "args_sig": "(string *message=nullptr) const override"
    },
    "MaterialX::Document::invalidateCache": {
      "brief": "Invalidate cached data for optimized lookups within the given document.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::Document::Document": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(ElementPtr parent,const string &name)"
    },
    "MaterialX::Document::~Document": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::Document::initialize": {
      "brief": "Initialize the document, removing any existing content.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::Document::copy": {
      "brief": "Create a deep copy of the document.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::Document::getReferencedSourceUris": {
      "brief": "Get a list of source URIs referenced by the document.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::Document::createDocument": {
      "brief": "Create a new document of the given subclass.",
      "detail": "Create a new Document.",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::Edge::Edge": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(ElementPtr elemDown,ElementPtr elemConnect,ElementPtr elemUp)"
    },
    "MaterialX::Edge::~Edge": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()=default"
    },
    "MaterialX::Edge::operator==": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const Edge &rhs) const"
    },
    "MaterialX::Edge::operator!=": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const Edge &rhs) const"
    },
    "MaterialX::Edge::operator<": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const Edge &rhs) const"
    },
    "MaterialX::Edge::operator bool": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::Edge::getDownstreamElement": {
      "brief": "Return the downstream element of the edge.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::Edge::getConnectingElement": {
      "brief": "Return the connecting element of the edge, if any.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::Edge::getUpstreamElement": {
      "brief": "Return the upstream element of the edge.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::Edge::getName": {
      "brief": "Return the name of this edge, if any.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::Element::setCategory": {
      "brief": "Set the element's category string.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &category)"
    },
    "MaterialX::Element::getCategory": {
      "brief": "Return the element's category string.",
      "detail": "The category of a MaterialX element represents its role within the document, with common examples being \"material\", \"nodegraph\", and \"image\".",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::Element::setName": {
      "brief": "Set the element's name string.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &name)"
    },
    "MaterialX::Element::getName": {
      "brief": "Return the element's name string.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::Element::getNamePath": {
      "brief": "Return the element's hierarchical name path, relative to the root document.",
      "detail": "",
      "params": {
        "relativeTo": "If a valid ancestor element is specified, then the returned path will be relative to this ancestor."
      },
      "returns": "",
      "args_sig": "(ConstElementPtr relativeTo=nullptr) const"
    },
    "MaterialX::Element::getDescendant": {
      "brief": "Return the element specified by the given hierarchical name path, relative to the current element.",
      "detail": "",
      "params": {
        "namePath": "The relative name path of the specified element."
      },
      "returns": "",
      "args_sig": "(const string &namePath) const"
    },
    "MaterialX::Element::setFilePrefix": {
      "brief": "Set the element's file prefix string.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &prefix)"
    },
    "MaterialX::Element::hasFilePrefix": {
      "brief": "Return true if the given element has a file prefix string.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::Element::getFilePrefix": {
      "brief": "Return the element's file prefix string.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::Element::getActiveFilePrefix": {
      "brief": "Return the file prefix string that is active at the scope of this element, taking all ancestor elements into account.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::Element::setGeomPrefix": {
      "brief": "Set the element's geom prefix string.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &prefix)"
    },
    "MaterialX::Element::hasGeomPrefix": {
      "brief": "Return true if the given element has a geom prefix string.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::Element::getGeomPrefix": {
      "brief": "Return the element's geom prefix string.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::Element::getActiveGeomPrefix": {
      "brief": "Return the geom prefix string that is active at the scope of this element, taking all ancestor elements into account.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::Element::setColorSpace": {
      "brief": "Set the element's color space string.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &colorSpace)"
    },
    "MaterialX::Element::hasColorSpace": {
      "brief": "Return true if the given element has a color space string.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::Element::getColorSpace": {
      "brief": "Return the element's color space string.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::Element::getActiveColorSpace": {
      "brief": "Return the color space string that is active at the scope of this element, taking all ancestor elements into account.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::Element::setInheritString": {
      "brief": "Set the inherit string of this element.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &inherit)"
    },
    "MaterialX::Element::hasInheritString": {
      "brief": "Return true if this element has an inherit string.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::Element::getInheritString": {
      "brief": "Return the inherit string of this element.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::Element::setInheritsFrom": {
      "brief": "Set the element that this one directly inherits from.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(ConstElementPtr super)"
    },
    "MaterialX::Element::getInheritsFrom": {
      "brief": "Return the element, if any, that this one directly inherits from.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::Element::hasInheritedBase": {
      "brief": "Return true if this element has the given element as an inherited base, taking the full inheritance chain into account.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(ConstElementPtr base) const"
    },
    "MaterialX::Element::hasInheritanceCycle": {
      "brief": "Return true if the inheritance chain for this element contains a cycle.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::Element::setNamespace": {
      "brief": "Set the namespace string of this element.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &space)"
    },
    "MaterialX::Element::hasNamespace": {
      "brief": "Return true if this element has a namespace string.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::Element::getNamespace": {
      "brief": "Return the namespace string of this element.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::Element::getQualifiedName": {
      "brief": "Return a qualified version of the given name, taking the namespace at the scope of this element into account.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &name) const"
    },
    "MaterialX::Element::setDocString": {
      "brief": "Set the documentation string of this element.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &doc)"
    },
    "MaterialX::Element::getDocString": {
      "brief": "Return the documentation string of this element.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::Element::isA": {
      "brief": "Return true if this element belongs to the given subclass.",
      "detail": "If a category string is specified, then both subclass and category matches are required.",
      "params": {},
      "returns": "",
      "args_sig": "(const string &category=EMPTY_STRING) const"
    },
    "MaterialX::Element::asA": {
      "brief": "Dynamic cast to a const instance of the given subclass.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::Element::addChild": {
      "brief": "Add a child element of the given subclass and name.",
      "detail": "",
      "params": {
        "name": "The name of the new child element. If no name is specified, then a unique name will automatically be generated."
      },
      "returns": "A shared pointer to the new child element.",
      "args_sig": "(const string &name=EMPTY_STRING)"
    },
    "MaterialX::Element::addChildOfCategory": {
      "brief": "Add a child element of the given category and name.",
      "detail": "",
      "params": {
        "category": "The category string of the new child element. If the category string is recognized, then the corresponding Element subclass is generated; otherwise, a GenericElement is generated.",
        "name": "The name of the new child element. If no name is specified, then a unique name will automatically be generated."
      },
      "returns": "A shared pointer to the new child element.",
      "args_sig": "(const string &category,string name=EMPTY_STRING)"
    },
    "MaterialX::Element::changeChildCategory": {
      "brief": "Change the category of the given child element.",
      "detail": "",
      "params": {
        "child": "The child element that will be modified.",
        "category": "The new category string for the child element."
      },
      "returns": "A shared pointer to a new child element, containing the contents of the original child but with a new category and subclass.",
      "args_sig": "(ElementPtr child,const string &category)"
    },
    "MaterialX::Element::getChild": {
      "brief": "Return the child element, if any, with the given name.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &name) const"
    },
    "MaterialX::Element::getChildOfType": {
      "brief": "Return the child element, if any, with the given name and subclass.",
      "detail": "If a child with the given name exists, but belongs to a different subclass, then an empty shared pointer is returned.",
      "params": {},
      "returns": "",
      "args_sig": "(const string &name) const"
    },
    "MaterialX::Element::getChildren": {
      "brief": "Return a constant vector of all child elements.",
      "detail": "The returned vector maintains the order in which children were added.",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::Element::getChildrenOfType": {
      "brief": "Return a vector of all child elements that are instances of the given subclass, optionally filtered by the given category string.",
      "detail": "The returned vector maintains the order in which children were added.",
      "params": {},
      "returns": "",
      "args_sig": "(const string &category=EMPTY_STRING) const"
    },
    "MaterialX::Element::setChildIndex": {
      "brief": "Set the index of the child, if any, with the given name.",
      "detail": "If the given index is out of bounds, then an exception is thrown.",
      "params": {},
      "returns": "",
      "args_sig": "(const string &name,int index)"
    },
    "MaterialX::Element::getChildIndex": {
      "brief": "Return the index of the child, if any, with the given name.",
      "detail": "If no child with the given name is found, then -1 is returned.",
      "params": {},
      "returns": "",
      "args_sig": "(const string &name) const"
    },
    "MaterialX::Element::removeChild": {
      "brief": "Remove the child element, if any, with the given name.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &name)"
    },
    "MaterialX::Element::removeChildOfType": {
      "brief": "Remove the child element, if any, with the given name and subclass.",
      "detail": "If a child with the given name exists, but belongs to a different subclass, then this method has no effect.",
      "params": {},
      "returns": "",
      "args_sig": "(const string &name)"
    },
    "MaterialX::Element::setAttribute": {
      "brief": "Set the value string of the given attribute.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &attrib,const string &value)"
    },
    "MaterialX::Element::hasAttribute": {
      "brief": "Return true if the given attribute is present.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &attrib) const"
    },
    "MaterialX::Element::getAttribute": {
      "brief": "Return the value string of the given attribute.",
      "detail": "If the given attribute is not present, then an empty string is returned.",
      "params": {},
      "returns": "",
      "args_sig": "(const string &attrib) const"
    },
    "MaterialX::Element::getAttributeNames": {
      "brief": "Return a vector of stored attribute names, in the order they were set.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::Element::setTypedAttribute": {
      "brief": "Set the value of an implicitly typed attribute.",
      "detail": "Since an attribute stores no explicit type, the same type argument must be used in corresponding calls to getTypedAttribute.",
      "params": {},
      "returns": "",
      "args_sig": "(const string &attrib,const T &data)"
    },
    "MaterialX::Element::getTypedAttribute": {
      "brief": "Return the value of an implicitly typed attribute.",
      "detail": "If the given attribute is not present, or cannot be converted to the given data type, then the zero value for the data type is returned.",
      "params": {},
      "returns": "",
      "args_sig": "(const string &attrib) const"
    },
    "MaterialX::Element::removeAttribute": {
      "brief": "Remove the given attribute, if present.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &attrib)"
    },
    "MaterialX::Element::getSelf": {
      "brief": "Return our self pointer.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::Element::getParent": {
      "brief": "Return our parent element.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::Element::getRoot": {
      "brief": "Return the root element of our tree.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::Element::getDocument": {
      "brief": "Return the root document of our tree.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::Element::getAncestorOfType": {
      "brief": "Return the first ancestor of the given subclass, or an empty shared pointer if no ancestor of this subclass is found.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::Element::isEquivalent": {
      "brief": "Return true if the given element tree, including all descendents, is considered to be equivalent to this one based on the equivalence criteria provided.",
      "detail": "",
      "params": {
        "rhs": "Element to compare against",
        "options": "Equivalence criteria",
        "message": "Optional text description of differences"
      },
      "returns": "True if the elements are equivalent. False otherwise.",
      "args_sig": "(ConstElementPtr rhs,const ElementEquivalenceOptions &options,string *message=nullptr) const"
    },
    "MaterialX::Element::isAttributeEquivalent": {
      "brief": "Return true if the attribute on a given element is equivalent based on the equivalence criteria provided.",
      "detail": "",
      "params": {
        "rhs": "Element to compare against",
        "attributeName": "Name of attribute to compare",
        "options": "Equivalence criteria",
        "message": "Optional text description of differences"
      },
      "returns": "True if the attribute on the elements are equivalent. False otherwise.",
      "args_sig": "(ConstElementPtr rhs,const string &attributeName,const ElementEquivalenceOptions &options,string *message=nullptr) const"
    },
    "MaterialX::Element::traverseTree": {
      "brief": "Traverse the tree from the given element to each of its descendants in depth-first order, using pre-order visitation.",
      "detail": "",
      "params": {},
      "returns": "A TreeIterator object.",
      "args_sig": "() const"
    },
    "MaterialX::Element::traverseGraph": {
      "brief": "Traverse the dataflow graph from the given element to each of its upstream sources in depth-first order, using pre-order visitation.",
      "detail": "",
      "params": {},
      "returns": "A GraphIterator object.",
      "args_sig": "() const"
    },
    "MaterialX::Element::getUpstreamEdge": {
      "brief": "Return the Edge with the given index that lies directly upstream from this element in the dataflow graph.",
      "detail": "",
      "params": {
        "index": "An optional index of the edge to be returned, where the valid index range may be determined with getUpstreamEdgeCount."
      },
      "returns": "The upstream Edge, if valid, or an empty Edge object.",
      "args_sig": "(size_t index=0) const"
    },
    "MaterialX::Element::getUpstreamEdgeCount": {
      "brief": "Return the number of queryable upstream edges for this element.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::Element::getUpstreamElement": {
      "brief": "Return the Element with the given index that lies directly upstream from this one in the dataflow graph.",
      "detail": "",
      "params": {
        "index": "An optional index of the element to be returned, where the valid index range may be determined with getUpstreamEdgeCount."
      },
      "returns": "The upstream Element, if valid, or an empty ElementPtr.",
      "args_sig": "(size_t index=0) const"
    },
    "MaterialX::Element::traverseInheritance": {
      "brief": "Traverse the inheritance chain from the given element to each element from which it inherits.",
      "detail": "",
      "params": {},
      "returns": "An InheritanceIterator object.",
      "args_sig": "() const"
    },
    "MaterialX::Element::setSourceUri": {
      "brief": "Set the element's source URI.",
      "detail": "",
      "params": {
        "sourceUri": "A URI string representing the resource from which this element originates. This string may be used by serialization and deserialization routines to maintain hierarchies of include references."
      },
      "returns": "",
      "args_sig": "(const string &sourceUri)"
    },
    "MaterialX::Element::hasSourceUri": {
      "brief": "Return true if this element has a source URI.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::Element::getSourceUri": {
      "brief": "Return the element's source URI.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::Element::getActiveSourceUri": {
      "brief": "Return the source URI that is active at the scope of this element, taking all ancestor elements into account.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::Element::validate": {
      "brief": "Validate that the given element tree, including all descendants, is consistent with the MaterialX specification.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(string *message=nullptr) const"
    },
    "MaterialX::Element::copyContentFrom": {
      "brief": "Copy all attributes and descendants from the given element to this one.",
      "detail": "",
      "params": {
        "source": "The element from which content is copied."
      },
      "returns": "",
      "args_sig": "(const ConstElementPtr &source)"
    },
    "MaterialX::Element::clearContent": {
      "brief": "Clear all attributes and descendants from this element.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::Element::createValidChildName": {
      "brief": "Using the input name as a starting point, modify it to create a valid, unique name for a child element.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(string name) const"
    },
    "MaterialX::Element::createStringResolver": {
      "brief": "Construct a StringResolver at the scope of this element.",
      "detail": "",
      "params": {
        "geom": "An optional geometry name, which will be used to select the applicable set of geometry token substitutions. By default, no geometry token substitutions are applied. If the universal geometry name \"/\" is given, then all geometry token substitutions are applied,"
      },
      "returns": "A shared pointer to a StringResolver.",
      "args_sig": "(const string &geom=EMPTY_STRING) const"
    },
    "MaterialX::Element::asString": {
      "brief": "Return a single-line description of this element, including its category, name, and attributes.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::Element::Element": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const Element &)=delete"
    },
    "MaterialX::Element::resolveNameReference": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &name,ConstElementPtr parent=nullptr) const"
    },
    "MaterialX::Element::validateRequire": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(bool expression,bool &res,string *message,const string &errorDesc) const"
    },
    "MaterialX::Element::registerChildElement": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(ElementPtr child)"
    },
    "MaterialX::Element::unregisterChildElement": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(ElementPtr child)"
    },
    "MaterialX::Element::getSelfNonConst": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::Element::~Element": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::Element::operator=": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const Element &)=delete"
    },
    "MaterialX::Element::operator==": {
      "brief": "Return true if the given element tree, including all descendants, is identical to this one.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const Element &rhs) const"
    },
    "MaterialX::Element::operator!=": {
      "brief": "Return true if the given element tree, including all descendants, differs from this one.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const Element &rhs) const"
    },
    "MaterialX::Element::createElement": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(ElementPtr parent,const string &name)"
    },
    "MaterialX::ElementEquivalenceOptions::ElementEquivalenceOptions": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::ElementEquivalenceOptions::~ElementEquivalenceOptions": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()=default"
    },
    "MaterialX::EsslShaderGenerator::EsslShaderGenerator": {
      "brief": "Constructor.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(TypeSystemPtr typeSystem)"
    },
    "MaterialX::EsslShaderGenerator::getTarget": {
      "brief": "Return a unique identifier for the target this generator is for.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const override"
    },
    "MaterialX::EsslShaderGenerator::getVersion": {
      "brief": "Return the version string for the ESSL version this generator is for.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const override"
    },
    "MaterialX::EsslShaderGenerator::getVertexDataPrefix": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const VariableBlock &vertexData) const override"
    },
    "MaterialX::EsslShaderGenerator::create": {
      "brief": "Creator function.",
      "detail": "If a TypeSystem is not provided it will be created internally. Optionally pass in an externally created TypeSystem here, if you want to keep type descriptions alive after the lifetime of the shader generator.",
      "params": {},
      "returns": "",
      "args_sig": "(TypeSystemPtr typeSystem=nullptr)"
    },
    "MaterialX::EsslShaderGenerator::emitDirectives": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(GenContext &context,ShaderStage &stage) const override"
    },
    "MaterialX::EsslShaderGenerator::emitUniforms": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(GenContext &context,ShaderStage &stage) const override"
    },
    "MaterialX::EsslShaderGenerator::emitInputs": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(GenContext &context,ShaderStage &stage) const override"
    },
    "MaterialX::EsslShaderGenerator::emitOutputs": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(GenContext &context,ShaderStage &stage) const override"
    },
    "MaterialX::EsslShaderGenerator::getResourceBindingContext": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(GenContext &context) const override"
    },
    "MaterialX::EsslSyntax::EsslSyntax": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(TypeSystemPtr typeSystem)"
    },
    "MaterialX::EsslSyntax::create": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(TypeSystemPtr typeSystem)"
    },
    "MaterialX::Exception::Exception": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const Exception &e)"
    },
    "MaterialX::Exception::operator=": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const Exception &e)"
    },
    "MaterialX::Exception::~Exception": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() noexcept"
    },
    "MaterialX::Exception::what": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const noexcept override"
    },
    "MaterialX::ExceptionFileMissing::Exception": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const Exception &e)"
    },
    "MaterialX::ExceptionFoundCycle::Exception": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const Exception &e)"
    },
    "MaterialX::ExceptionOrphanedElement::Exception": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const Exception &e)"
    },
    "MaterialX::ExceptionParseError::Exception": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const Exception &e)"
    },
    "MaterialX::ExceptionRenderError::ExceptionRenderError": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const ExceptionRenderError &e)"
    },
    "MaterialX::ExceptionRenderError::operator=": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const ExceptionRenderError &e)"
    },
    "MaterialX::ExceptionRenderError::errorLog": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::ExceptionShaderGenError::Exception": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const Exception &e)"
    },
    "MaterialX::ExceptionTypeError::Exception": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const Exception &e)"
    },
    "MaterialX::Factory::registerClass": {
      "brief": "Register a new class given a unique type name and a creator function for the class.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &typeName,CreatorFunction f)"
    },
    "MaterialX::Factory::classRegistered": {
      "brief": "Determine if a class has been registered for a type name.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &typeName) const"
    },
    "MaterialX::Factory::unregisterClass": {
      "brief": "Unregister a registered class.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &typeName)"
    },
    "MaterialX::Factory::create": {
      "brief": "Create a new instance of the class with given type name.",
      "detail": "Returns nullptr if no class with given name is registered.",
      "params": {},
      "returns": "",
      "args_sig": "(const string &typeName) const"
    },
    "MaterialX::FilePath::FilePath": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::FilePath::operator string": {
      "brief": "Convert a path to a standard string.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::FilePath::assign": {
      "brief": "Assign a path from a standard string.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &str)"
    },
    "MaterialX::FilePath::asString": {
      "brief": "Return this path as a standard string with the given format.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(Format format=FormatNative) const"
    },
    "MaterialX::FilePath::isEmpty": {
      "brief": "Return true if the given path is empty.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::FilePath::isAbsolute": {
      "brief": "Return true if the given path is absolute.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::FilePath::getBaseName": {
      "brief": "Return the base name of the given path, with leading directory information removed.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::FilePath::getParentPath": {
      "brief": "Return the parent directory of the given path, if any.",
      "detail": "If no parent directory is present, then the empty path is returned.",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::FilePath::getExtension": {
      "brief": "Return the file extension of the given path.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::FilePath::addExtension": {
      "brief": "Add a file extension to the given path.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &ext)"
    },
    "MaterialX::FilePath::removeExtension": {
      "brief": "Remove the file extension, if any, from the given path.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::FilePath::operator/": {
      "brief": "Concatenate two paths with a directory separator, returning the combined path.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const FilePath &rhs) const"
    },
    "MaterialX::FilePath::size": {
      "brief": "Return the number of strings in the path.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::FilePath::operator[]": {
      "brief": "Return the const string at the given index.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(size_t index) const"
    },
    "MaterialX::FilePath::getNormalized": {
      "brief": "Return a normalized version of the given path, collapsing current path and parent path references so that 'a/.",
      "detail": "/b' and 'c/../d/../a/b' become 'a/b'.",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::FilePath::exists": {
      "brief": "Return true if the given path exists on the file system.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::FilePath::isDirectory": {
      "brief": "Return true if the given path is a directory on the file system.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::FilePath::getFilesInDirectory": {
      "brief": "Return a vector of all files in the given directory with the given extension.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &extension) const"
    },
    "MaterialX::FilePath::getSubDirectories": {
      "brief": "Return a vector of all directories at or beneath the given path.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::FilePath::createDirectory": {
      "brief": "Create a directory on the file system at the given path.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::FilePath::setCurrentPath": {
      "brief": "Set the current working directory of the file system.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::FilePath::~FilePath": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()=default"
    },
    "MaterialX::FilePath::operator==": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const FilePath &rhs) const"
    },
    "MaterialX::FilePath::operator!=": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const FilePath &rhs) const"
    },
    "MaterialX::FilePath::getCurrentPath": {
      "brief": "Return the current working directory of the file system.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::FilePath::getModulePath": {
      "brief": "Return the directory containing the executable module.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::FileSearchPath::begin": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::FileSearchPath::end": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::FileSearchPath::FileSearchPath": {
      "brief": "Construct a search path from a string.",
      "detail": "",
      "params": {
        "searchPath": "A string containing a sequence of file paths joined by separator characters.",
        "sep": "The set of separator characters used in the search path. Defaults to the PATH_LIST_SEPARATOR character."
      },
      "returns": "",
      "args_sig": "(const string &searchPath,const string &sep=PATH_LIST_SEPARATOR)"
    },
    "MaterialX::FileSearchPath::asString": {
      "brief": "Convert this sequence to a string using the given separator.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &sep=PATH_LIST_SEPARATOR) const"
    },
    "MaterialX::FileSearchPath::append": {
      "brief": "Append the given search path to the sequence.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const FileSearchPath &searchPath)"
    },
    "MaterialX::FileSearchPath::prepend": {
      "brief": "Prepend the given path to the sequence.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const FilePath &path)"
    },
    "MaterialX::FileSearchPath::clear": {
      "brief": "Clear all paths from the sequence.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::FileSearchPath::size": {
      "brief": "Return the number of paths in the sequence.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::FileSearchPath::isEmpty": {
      "brief": "Return true if the search path is empty.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::FileSearchPath::operator[]": {
      "brief": "Return the const path at the given index.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(size_t index) const"
    },
    "MaterialX::FileSearchPath::find": {
      "brief": "Given an input filename, iterate through each path in this sequence, returning the first combined path found on the file system.",
      "detail": "On success, the combined path is returned; otherwise the original filename is returned unmodified.",
      "params": {},
      "returns": "",
      "args_sig": "(const FilePath &filename) const"
    },
    "MaterialX::GenericElement::GenericElement": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(ElementPtr parent,const string &name)"
    },
    "MaterialX::GenericElement::~GenericElement": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::GenContext::GenContext": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()=delete"
    },
    "MaterialX::GenContext::getShaderGenerator": {
      "brief": "Return shader generatior.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::GenContext::getOptions": {
      "brief": "Return shader generation options.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::GenContext::getTypeDesc": {
      "brief": "Return a TypeDesc for the given type name.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &name) const"
    },
    "MaterialX::GenContext::registerSourceCodeSearchPath": {
      "brief": "Register a user search path for finding source code during code generation.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const FileSearchPath &path)"
    },
    "MaterialX::GenContext::resolveSourceFile": {
      "brief": "Resolve a source code filename, first checking the given local path then checking any file paths registered by the user.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const FilePath &filename,const FilePath &localPath) const"
    },
    "MaterialX::GenContext::addReservedWords": {
      "brief": "Add reserved words that should not be used as identifiers during code generation.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const StringSet &names)"
    },
    "MaterialX::GenContext::getReservedWords": {
      "brief": "Return the set of reserved words that should not be used as identifiers during code generation.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::GenContext::addNodeImplementation": {
      "brief": "Cache a shader node implementation.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &name,ShaderNodeImplPtr impl)"
    },
    "MaterialX::GenContext::findNodeImplementation": {
      "brief": "Find and return a cached shader node implementation, or return nullptr if no implementation is found.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &name) const"
    },
    "MaterialX::GenContext::getNodeImplementationNames": {
      "brief": "Get the names of all cached node implementations.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(StringSet &names)"
    },
    "MaterialX::GenContext::clearNodeImplementations": {
      "brief": "Clear all cached shader node implementation.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::GenContext::pushParentNode": {
      "brief": "Push a parent node onto the stack.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(ConstNodePtr node)"
    },
    "MaterialX::GenContext::popParentNode": {
      "brief": "Pop the current parent node from the stack.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::GenContext::getParentNodes": {
      "brief": "Return the current stack of parent nodes.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::GenContext::pushUserData": {
      "brief": "Add user data to the context to make it available during shader generator.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &name,GenUserDataPtr data)"
    },
    "MaterialX::GenContext::popUserData": {
      "brief": "Remove user data from the context.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &name)"
    },
    "MaterialX::GenContext::clearUserData": {
      "brief": "Clear all user data from the context.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::GenContext::getUserData": {
      "brief": "Return user data with given name, or nullptr if no data is found.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &name)"
    },
    "MaterialX::GenContext::addInputSuffix": {
      "brief": "Add an input suffix to be used for the input in this context.",
      "detail": "",
      "params": {
        "input": "Node input",
        "suffix": "Suffix string"
      },
      "returns": "",
      "args_sig": "(const ShaderInput *input,const string &suffix)"
    },
    "MaterialX::GenContext::removeInputSuffix": {
      "brief": "Remove an input suffix to be used for the input in this context.",
      "detail": "",
      "params": {
        "input": "Node input"
      },
      "returns": "",
      "args_sig": "(const ShaderInput *input)"
    },
    "MaterialX::GenContext::getInputSuffix": {
      "brief": "Get an input suffix to be used for the input in this context.",
      "detail": "",
      "params": {
        "input": "Node input",
        "suffix": "Suffix string returned. Is empty if not found."
      },
      "returns": "",
      "args_sig": "(const ShaderInput *input,string &suffix) const"
    },
    "MaterialX::GenContext::addOutputSuffix": {
      "brief": "Add an output suffix to be used for the output in this context.",
      "detail": "",
      "params": {
        "output": "Node output",
        "suffix": "Suffix string"
      },
      "returns": "",
      "args_sig": "(const ShaderOutput *output,const string &suffix)"
    },
    "MaterialX::GenContext::removeOutputSuffix": {
      "brief": "Remove an output suffix to be used for the output in this context.",
      "detail": "",
      "params": {
        "output": "Node output"
      },
      "returns": "",
      "args_sig": "(const ShaderOutput *output)"
    },
    "MaterialX::GenContext::getOutputSuffix": {
      "brief": "Get an output suffix to be used for the output in this context.",
      "detail": "",
      "params": {
        "output": "Node output",
        "suffix": "Suffix string returned. Is empty if not found."
      },
      "returns": "",
      "args_sig": "(const ShaderOutput *output,string &suffix) const"
    },
    "MaterialX::GenContext::setApplicationVariableHandler": {
      "brief": "Set handler for application variables.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(ApplicationVariableHandler handler)"
    },
    "MaterialX::GenContext::getApplicationVariableHandler": {
      "brief": "Get handler for application variables.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::GenMdlOptions::GenMdlOptions": {
      "brief": "Create MDL code generator options with default values.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::GenOptions::GenOptions": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::GenOptions::~GenOptions": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::GenUserData::~GenUserData": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::GenUserData::getSelf": {
      "brief": "Return a shared pointer for this object.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::GenUserData::asA": {
      "brief": "Return this object cast to a templated type.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::GenUserData::GenUserData": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::GeometryHandler::GeometryHandler": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::GeometryHandler::~GeometryHandler": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::GeometryHandler::addLoader": {
      "brief": "Add a geometry loader.",
      "detail": "",
      "params": {
        "loader": "Loader to add to list of available loaders."
      },
      "returns": "",
      "args_sig": "(GeometryLoaderPtr loader)"
    },
    "MaterialX::GeometryHandler::supportedExtensions": {
      "brief": "Get a list of extensions supported by the handler.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(StringSet &extensions)"
    },
    "MaterialX::GeometryHandler::clearGeometry": {
      "brief": "Clear all loaded geometry.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::GeometryHandler::hasGeometry": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &location)"
    },
    "MaterialX::GeometryHandler::getGeometry": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(MeshList &meshes,const string &location)"
    },
    "MaterialX::GeometryHandler::loadGeometry": {
      "brief": "Load geometry from a given location.",
      "detail": "",
      "params": {
        "filePath": "Path to geometry",
        "texcoordVerticalFlip": "Flip texture coordinates in V. Default is to not flip."
      },
      "returns": "",
      "args_sig": "(const FilePath &filePath,bool texcoordVerticalFlip=false)"
    },
    "MaterialX::GeometryHandler::getMeshes": {
      "brief": "Get list of meshes.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::GeometryHandler::findParentMesh": {
      "brief": "Return the first mesh in our list containing the given partition.",
      "detail": "If no matching mesh is found, then nullptr is returned.",
      "params": {},
      "returns": "",
      "args_sig": "(MeshPartitionPtr part)"
    },
    "MaterialX::GeometryHandler::getMinimumBounds": {
      "brief": "Return the minimum bounds for all meshes.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::GeometryHandler::getMaximumBounds": {
      "brief": "Return the minimum bounds for all meshes.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::GeometryHandler::create": {
      "brief": "Create a new geometry handler.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::GeometryHandler::createQuadMesh": {
      "brief": "Utility to create a quad mesh.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const Vector2 &uvMin=Vector2(0.0f,0.0f),const Vector2 &uvMax=Vector2(1.0f,1.0f),bool flipTexCoordsHorizontally=false)"
    },
    "MaterialX::GeometryHandler::computeBounds": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::GeometryLoader::GeometryLoader": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::GeometryLoader::~GeometryLoader": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::GeometryLoader::supportedExtensions": {
      "brief": "Returns a list of supported extensions.",
      "detail": "",
      "params": {},
      "returns": "List of support extensions",
      "args_sig": "() const"
    },
    "MaterialX::GeometryLoader::load": {
      "brief": "Load geometry from disk.",
      "detail": "",
      "params": {
        "filePath": "Path to file to load",
        "meshList": "List of meshes to update",
        "texcoordVerticalFlip": "Flip texture coordinates in V when loading"
      },
      "returns": "True if load was successful",
      "args_sig": "(const FilePath &filePath,MeshList &meshList,bool texcoordVerticalFlip=false)=0"
    },
    "MaterialX::GeomElement::setGeom": {
      "brief": "Set the geometry string of this element.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &geom)"
    },
    "MaterialX::GeomElement::hasGeom": {
      "brief": "Return true if this element has a geometry string.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::GeomElement::getGeom": {
      "brief": "Return the geometry string of this element.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::GeomElement::getActiveGeom": {
      "brief": "Return the active geometry string of this element, taking all geometry string substitutions at this scope into account.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::GeomElement::setCollectionString": {
      "brief": "Set the collection string of this element.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &collection)"
    },
    "MaterialX::GeomElement::hasCollectionString": {
      "brief": "Return true if this element has a collection string.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::GeomElement::getCollectionString": {
      "brief": "Return the collection string of this element.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::GeomElement::setCollection": {
      "brief": "Assign a Collection to this element.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(ConstCollectionPtr collection)"
    },
    "MaterialX::GeomElement::getCollection": {
      "brief": "Return the Collection that is assigned to this element.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::GeomElement::validate": {
      "brief": "Validate that the given element tree, including all descendants, is consistent with the MaterialX specification.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(string *message=nullptr) const override"
    },
    "MaterialX::GeomElement::GeomElement": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(ElementPtr parent,const string &category,const string &name)"
    },
    "MaterialX::GeomElement::~GeomElement": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::GeomInfo::addGeomProp": {
      "brief": "Add a GeomProp to this element.",
      "detail": "",
      "params": {
        "name": "The name of the new GeomProp. If no name is specified, then a unique name will automatically be generated."
      },
      "returns": "A shared pointer to the new GeomProp.",
      "args_sig": "(const string &name=EMPTY_STRING)"
    },
    "MaterialX::GeomInfo::getGeomProp": {
      "brief": "Return the GeomProp, if any, with the given name.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &name) const"
    },
    "MaterialX::GeomInfo::getGeomProps": {
      "brief": "Return a vector of all GeomProp elements.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::GeomInfo::removeGeomProp": {
      "brief": "Remove the GeomProp, if any, with the given name.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &name)"
    },
    "MaterialX::GeomInfo::addToken": {
      "brief": "Add a Token to this element.",
      "detail": "",
      "params": {
        "name": "The name of the new Token. If no name is specified, then a unique name will automatically be generated."
      },
      "returns": "A shared pointer to the new Token.",
      "args_sig": "(const string &name=EMPTY_STRING)"
    },
    "MaterialX::GeomInfo::getToken": {
      "brief": "Return the Token, if any, with the given name.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &name) const"
    },
    "MaterialX::GeomInfo::getTokens": {
      "brief": "Return a vector of all Token elements.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::GeomInfo::removeToken": {
      "brief": "Remove the Token, if any, with the given name.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &name)"
    },
    "MaterialX::GeomInfo::setGeomPropValue": {
      "brief": "Set the value of a GeomProp by its name, creating a child element to hold the GeomProp if needed.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &name,const T &value,const string &type=EMPTY_STRING)"
    },
    "MaterialX::GeomInfo::setTokenValue": {
      "brief": "Set the string value of a Token by its name, creating a child element to hold the Token if needed.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &name,const string &value)"
    },
    "MaterialX::GeomInfo::GeomInfo": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(ElementPtr parent,const string &name)"
    },
    "MaterialX::GeomInfo::~GeomInfo": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::GeomPath::GeomPath": {
      "brief": "Construct a path from a geometry name string.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &geom)"
    },
    "MaterialX::GeomPath::~GeomPath": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()=default"
    },
    "MaterialX::GeomPath::operator==": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const GeomPath &rhs) const"
    },
    "MaterialX::GeomPath::operator!=": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const GeomPath &rhs) const"
    },
    "MaterialX::GeomPath::operator string": {
      "brief": "Convert a path to a geometry name string.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::GeomPath::isMatching": {
      "brief": "Return true if there is any geometry in common between the two paths.",
      "detail": "",
      "params": {
        "rhs": "A second geometry path to be compared with this one",
        "contains": "If true, then we require that the first path completely contains the second one."
      },
      "returns": "",
      "args_sig": "(const GeomPath &rhs,bool contains=false) const"
    },
    "MaterialX::GeomPath::isEmpty": {
      "brief": "Return true if this geometry path is empty.",
      "detail": "An empty path matches no other geometry paths.",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::GeomPath::isUniversal": {
      "brief": "Return true if this geometry path is universal.",
      "detail": "A universal path matches all non-empty geometry paths.",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::GeomProp::GeomProp": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(ElementPtr parent,const string &name)"
    },
    "MaterialX::GeomProp::~GeomProp": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::GeomPropDef::setGeomProp": {
      "brief": "Set the geometric property string of this element.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &node)"
    },
    "MaterialX::GeomPropDef::hasGeomProp": {
      "brief": "Return true if this element has a geometric property string.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::GeomPropDef::getGeomProp": {
      "brief": "Return the geometric property string of this element.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::GeomPropDef::setSpace": {
      "brief": "Set the geometric space string of this element.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &space)"
    },
    "MaterialX::GeomPropDef::hasSpace": {
      "brief": "Return true if this element has a geometric space string.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::GeomPropDef::getSpace": {
      "brief": "Return the geometric space string of this element.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::GeomPropDef::setIndex": {
      "brief": "Set the index string of this element.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &space)"
    },
    "MaterialX::GeomPropDef::hasIndex": {
      "brief": "Return true if this element has an index string.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::GeomPropDef::getIndex": {
      "brief": "Return the index string of this element.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::GeomPropDef::GeomPropDef": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(ElementPtr parent,const string &name)"
    },
    "MaterialX::GeomPropDef::~GeomPropDef": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::GlslMaterial::GlslMaterial": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::GlslMaterial::~GlslMaterial": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::GlslMaterial::loadSource": {
      "brief": "Load shader source from file.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const FilePath &vertexShaderFile,const FilePath &pixelShaderFile,bool hasTransparency) override"
    },
    "MaterialX::GlslMaterial::generateShader": {
      "brief": "Generate a shader from the given hardware shader.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(ShaderPtr hwShader) override"
    },
    "MaterialX::GlslMaterial::copyShader": {
      "brief": "Copy shader from one material to this one.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(MaterialPtr material) override"
    },
    "MaterialX::GlslMaterial::getProgram": {
      "brief": "Return the underlying GLSL program.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::GlslMaterial::bindShader": {
      "brief": "Bind shader.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const override"
    },
    "MaterialX::GlslMaterial::bindViewInformation": {
      "brief": "Bind viewing information for this material.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(CameraPtr camera) override"
    },
    "MaterialX::GlslMaterial::bindImages": {
      "brief": "Bind all images for this material.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(ImageHandlerPtr imageHandler,const FileSearchPath &searchPath,bool enableMipmaps=true) override"
    },
    "MaterialX::GlslMaterial::unbindImages": {
      "brief": "Unbbind all images for this material.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(ImageHandlerPtr imageHandler) override"
    },
    "MaterialX::GlslMaterial::bindImage": {
      "brief": "Bind a single image.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const FilePath &filePath,const std::string &uniformName,ImageHandlerPtr imageHandler,const ImageSamplingProperties &samplingProperties) override"
    },
    "MaterialX::GlslMaterial::bindLighting": {
      "brief": "Bind lights to shader.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(LightHandlerPtr lightHandler,ImageHandlerPtr imageHandler,const ShadowState &shadowState) override"
    },
    "MaterialX::GlslMaterial::bindMesh": {
      "brief": "Bind the given mesh to this material.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(MeshPtr mesh) override"
    },
    "MaterialX::GlslMaterial::bindPartition": {
      "brief": "Bind a mesh partition to this material.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(MeshPartitionPtr part) const override"
    },
    "MaterialX::GlslMaterial::drawPartition": {
      "brief": "Draw the given mesh partition.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(MeshPartitionPtr part) const override"
    },
    "MaterialX::GlslMaterial::unbindGeometry": {
      "brief": "Unbind all geometry from this material.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() override"
    },
    "MaterialX::GlslMaterial::getPublicUniforms": {
      "brief": "Return the block of public uniforms for this material.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const override"
    },
    "MaterialX::GlslMaterial::findUniform": {
      "brief": "Find a public uniform from its MaterialX path.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const std::string &path) const override"
    },
    "MaterialX::GlslMaterial::modifyUniform": {
      "brief": "Modify the value of the uniform with the given path.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const std::string &path,ConstValuePtr value,std::string valueString=EMPTY_STRING) override"
    },
    "MaterialX::GlslMaterial::create": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::GlslMaterial::clearShader": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() override"
    },
    "MaterialX::GlslProgram::getUniformsList": {
      "brief": "Get list of program input uniforms.",
      "detail": "",
      "params": {},
      "returns": "Program uniforms list.",
      "args_sig": "()"
    },
    "MaterialX::GlslProgram::getAttributesList": {
      "brief": "Get list of program input attributes.",
      "detail": "",
      "params": {},
      "returns": "Program attributes list.",
      "args_sig": "()"
    },
    "MaterialX::GlslProgram::findInputs": {
      "brief": "Find the locations in the program which starts with a given variable name.",
      "detail": "",
      "params": {
        "variable": "Variable to search for",
        "variableList": "List of program inputs to search",
        "foundList": "Returned list of found program inputs. Empty if none found.",
        "exactMatch": "Search for exact variable name match."
      },
      "returns": "",
      "args_sig": "(const string &variable,const InputMap &variableList,InputMap &foundList,bool exactMatch)"
    },
    "MaterialX::GlslProgram::setStages": {
      "brief": "Set up code stages to validate based on an input hardware shader.",
      "detail": "",
      "params": {
        "shader": "Hardware shader to use"
      },
      "returns": "",
      "args_sig": "(ShaderPtr shader)"
    },
    "MaterialX::GlslProgram::addStage": {
      "brief": "Set the code stages based on a list of stage strings.",
      "detail": "",
      "params": {
        "stage": "Name of the shader stage.",
        "sourceCode": "Source code of the shader stage."
      },
      "returns": "",
      "args_sig": "(const string &stage,const string &sourceCode)"
    },
    "MaterialX::GlslProgram::getStageSourceCode": {
      "brief": "Get source code string for a given stage.",
      "detail": "",
      "params": {},
      "returns": "Shader stage string. String is empty if not found.",
      "args_sig": "(const string &stage) const"
    },
    "MaterialX::GlslProgram::getShader": {
      "brief": "Return the shader, if any, used to generate this program.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::GlslProgram::build": {
      "brief": "Build shader program data from the source code set for each shader stage.",
      "detail": "An exception is thrown if the program cannot be built. The exception will contain a list of compilation errors.",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::GlslProgram::hasBuiltData": {
      "brief": "Return true if built shader program data is present.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::GlslProgram::clearBuiltData": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::GlslProgram::bind": {
      "brief": "Bind the program.",
      "detail": "",
      "params": {},
      "returns": "False if failed",
      "args_sig": "()"
    },
    "MaterialX::GlslProgram::hasActiveAttributes": {
      "brief": "Return true if the program has active attributes.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::GlslProgram::hasUniform": {
      "brief": "Return true if a uniform with the given name is present.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &name)"
    },
    "MaterialX::GlslProgram::bindUniform": {
      "brief": "Bind a value to the uniform with the given name.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &name,ConstValuePtr value,bool errorIfMissing=true)"
    },
    "MaterialX::GlslProgram::bindAttribute": {
      "brief": "Bind attribute buffers to attribute inputs.",
      "detail": "",
      "params": {
        "inputs": "Attribute inputs to bind to",
        "mesh": "Mesh containing streams to bind"
      },
      "returns": "",
      "args_sig": "(const GlslProgram::InputMap &inputs,MeshPtr mesh)"
    },
    "MaterialX::GlslProgram::bindPartition": {
      "brief": "Bind input geometry partition (indexing)",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(MeshPartitionPtr partition)"
    },
    "MaterialX::GlslProgram::bindMesh": {
      "brief": "Bind input geometry streams.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(MeshPtr mesh)"
    },
    "MaterialX::GlslProgram::unbindGeometry": {
      "brief": "Unbind any bound geometry.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::GlslProgram::bindTextures": {
      "brief": "Bind any input textures.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(ImageHandlerPtr imageHandler)"
    },
    "MaterialX::GlslProgram::bindLighting": {
      "brief": "Bind lighting.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(LightHandlerPtr lightHandler,ImageHandlerPtr imageHandler)"
    },
    "MaterialX::GlslProgram::bindViewInformation": {
      "brief": "Bind view information.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(CameraPtr camera)"
    },
    "MaterialX::GlslProgram::bindTimeAndFrame": {
      "brief": "Bind time and frame.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(float time=0.0f,float frame=1.0f)"
    },
    "MaterialX::GlslProgram::unbind": {
      "brief": "Unbind the program. Equivalent to binding no program.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::GlslProgram::printUniforms": {
      "brief": "Print all uniforms to the given stream.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(std::ostream &outputStream)"
    },
    "MaterialX::GlslProgram::printAttributes": {
      "brief": "Print all attributes to the given stream.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(std::ostream &outputStream)"
    },
    "MaterialX::GlslProgram::create": {
      "brief": "Create a GLSL program instance.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::GlslProgram::~GlslProgram": {
      "brief": "Destructor.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::GlslProgram::GlslProgram": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::GlslProgram::updateUniformsList": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::GlslProgram::updateAttributesList": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::GlslProgram::findUniformValue": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &uniformName,const InputMap &uniformList)"
    },
    "MaterialX::GlslProgram::bindTexture": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(unsigned int uniformType,int uniformLocation,const FilePath &filePath,ImageHandlerPtr imageHandler,const ImageSamplingProperties &imageProperties)"
    },
    "MaterialX::GlslProgram::bindUniformLocation": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(int location,ConstValuePtr value)"
    },
    "MaterialX::GlslProgram::mapTypeToOpenGLType": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(TypeDesc type)"
    },
    "MaterialX::GlslRenderer::initialize": {
      "brief": "Internal initialization of stages and OpenGL constructs required for program validation and rendering.",
      "detail": "",
      "params": {
        "renderContextHandle": "allows initializing the GlslRenderer with a Shared OpenGL Context"
      },
      "returns": "",
      "args_sig": "(RenderContextHandle renderContextHandle=nullptr) override"
    },
    "MaterialX::GlslRenderer::createProgram": {
      "brief": "Create GLSL program based on shader stage source code.",
      "detail": "",
      "params": {
        "stages": "Map of name and source code for the shader stages."
      },
      "returns": "",
      "args_sig": "(const StageMap &stages) override"
    },
    "MaterialX::GlslRenderer::validateInputs": {
      "brief": "Validate inputs for the program.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() override"
    },
    "MaterialX::GlslRenderer::updateUniform": {
      "brief": "Update the program with value of the uniform.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &name,ConstValuePtr value) override"
    },
    "MaterialX::GlslRenderer::setSize": {
      "brief": "Set the size of the rendered image.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(unsigned int width,unsigned int height) override"
    },
    "MaterialX::GlslRenderer::render": {
      "brief": "Render the current program to an offscreen buffer.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() override"
    },
    "MaterialX::GlslRenderer::renderTextureSpace": {
      "brief": "Render the current program in texture space to an off-screen buffer.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const Vector2 &uvMin,const Vector2 &uvMax)"
    },
    "MaterialX::GlslRenderer::captureImage": {
      "brief": "Capture the current contents of the off-screen hardware buffer as an image.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(ImagePtr image=nullptr) override"
    },
    "MaterialX::GlslRenderer::getFramebuffer": {
      "brief": "Return the GL frame buffer.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::GlslRenderer::getProgram": {
      "brief": "Return the GLSL program.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::GlslRenderer::drawScreenSpaceQuad": {
      "brief": "Submit geometry for a screen-space quad.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const Vector2 &uvMin=Vector2(0.0f),const Vector2 &uvMax=Vector2(1.0f))"
    },
    "MaterialX::GlslRenderer::setScreenColor": {
      "brief": "Set the screen background color.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const Color3 &screenColor)"
    },
    "MaterialX::GlslRenderer::getScreenColor": {
      "brief": "Return the screen background color.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::GlslRenderer::create": {
      "brief": "Create a GLSL renderer instance.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(unsigned int width=512,unsigned int height=512,Image::BaseType baseType=Image::BaseType::UINT8)"
    },
    "MaterialX::GlslRenderer::createImageHandler": {
      "brief": "Create a texture handler for OpenGL textures.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(ImageLoaderPtr imageLoader)"
    },
    "MaterialX::GlslRenderer::~GlslRenderer": {
      "brief": "Destructor.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::GlslRenderer::GlslRenderer": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(unsigned int width,unsigned int height,Image::BaseType baseType)"
    },
    "MaterialX::GlslResourceBindingContext::GlslResourceBindingContext": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(size_t uniformBindingLocation,size_t samplerBindingLocation)"
    },
    "MaterialX::GlslResourceBindingContext::initialize": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() override"
    },
    "MaterialX::GlslResourceBindingContext::emitDirectives": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(GenContext &context,ShaderStage &stage) override"
    },
    "MaterialX::GlslResourceBindingContext::emitResourceBindings": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(GenContext &context,const VariableBlock &uniforms,ShaderStage &stage) override"
    },
    "MaterialX::GlslResourceBindingContext::emitStructuredResourceBindings": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(GenContext &context,const VariableBlock &uniforms,ShaderStage &stage,const std::string &structInstanceName,const std::string &arraySuffix) override"
    },
    "MaterialX::GlslResourceBindingContext::enableSeparateBindingLocations": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(bool separateBindingLocation)"
    },
    "MaterialX::GlslResourceBindingContext::create": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(size_t uniformBindingLocation=0,size_t samplerBindingLocation=0)"
    },
    "MaterialX::GlslShaderGenerator::GlslShaderGenerator": {
      "brief": "Constructor.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(TypeSystemPtr typeSystem)"
    },
    "MaterialX::GlslShaderGenerator::generate": {
      "brief": "Generate a shader starting from the given element, translating the element and all dependencies upstream into shader code.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &name,ElementPtr element,GenContext &context) const override"
    },
    "MaterialX::GlslShaderGenerator::getTarget": {
      "brief": "Return a unique identifier for the target this generator is for.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const override"
    },
    "MaterialX::GlslShaderGenerator::getVersion": {
      "brief": "Return the version string for the GLSL version this generator is for.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::GlslShaderGenerator::emitVariableDeclaration": {
      "brief": "Emit a shader variable.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const ShaderPort *variable,const string &qualifier,GenContext &context,ShaderStage &stage,bool assignValue=true) const override"
    },
    "MaterialX::GlslShaderGenerator::getVertexDataPrefix": {
      "brief": "Determine the prefix of vertex data variables.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const VariableBlock &vertexData) const override"
    },
    "MaterialX::GlslShaderGenerator::create": {
      "brief": "Creator function.",
      "detail": "If a TypeSystem is not provided it will be created internally. Optionally pass in an externally created TypeSystem here, if you want to keep type descriptions alive after the lifetime of the shader generator.",
      "params": {},
      "returns": "",
      "args_sig": "(TypeSystemPtr typeSystem=nullptr)"
    },
    "MaterialX::GlslShaderGenerator::emitVertexStage": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const ShaderGraph &graph,GenContext &context,ShaderStage &stage) const"
    },
    "MaterialX::GlslShaderGenerator::emitPixelStage": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const ShaderGraph &graph,GenContext &context,ShaderStage &stage) const"
    },
    "MaterialX::GlslShaderGenerator::emitDirectives": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(GenContext &context,ShaderStage &stage) const"
    },
    "MaterialX::GlslShaderGenerator::emitConstants": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(GenContext &context,ShaderStage &stage) const"
    },
    "MaterialX::GlslShaderGenerator::emitUniforms": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(GenContext &context,ShaderStage &stage) const"
    },
    "MaterialX::GlslShaderGenerator::emitLightData": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(GenContext &context,ShaderStage &stage) const"
    },
    "MaterialX::GlslShaderGenerator::emitInputs": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(GenContext &context,ShaderStage &stage) const"
    },
    "MaterialX::GlslShaderGenerator::emitOutputs": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(GenContext &context,ShaderStage &stage) const"
    },
    "MaterialX::GlslShaderGenerator::getResourceBindingContext": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(GenContext &context) const"
    },
    "MaterialX::GlslShaderGenerator::emitSpecularEnvironment": {
      "brief": "Emit specular environment lookup code.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(GenContext &context,ShaderStage &stage) const"
    },
    "MaterialX::GlslShaderGenerator::emitTransmissionRender": {
      "brief": "Emit transmission rendering code.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(GenContext &context,ShaderStage &stage) const"
    },
    "MaterialX::GlslShaderGenerator::emitLightFunctionDefinitions": {
      "brief": "Emit function definitions for lighting code.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const ShaderGraph &graph,GenContext &context,ShaderStage &stage) const"
    },
    "MaterialX::GlslShaderGenerator::toVec4": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const TypeDesc *type,string &variable)"
    },
    "MaterialX::GlslStructTypeSyntax::getValue": {
      "brief": "Returns a value formatted according to this type syntax.",
      "detail": "The value is constructed from the given value object.",
      "params": {},
      "returns": "",
      "args_sig": "(const Value &value,bool uniform) const override"
    },
    "MaterialX::GlslStructTypeSyntax::StructTypeSyntax": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const Syntax *parent,const string &name,const string &defaultValue,const string &uniformDefaultValue,const string &typeAlias=EMPTY_STRING,const string &typeDefinition=EMPTY_STRING,const StringVec &members=EMPTY_MEMBERS)"
    },
    "MaterialX::GlslSyntax::GlslSyntax": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(TypeSystemPtr typeSystem)"
    },
    "MaterialX::GlslSyntax::getInputQualifier": {
      "brief": "Returns a type qualifier to be used when declaring types for input variables.",
      "detail": "Default implementation returns empty string and derived syntax classes should override this method.",
      "params": {},
      "returns": "",
      "args_sig": "() const override"
    },
    "MaterialX::GlslSyntax::getOutputQualifier": {
      "brief": "Returns a type qualifier to be used when declaring types for output variables.",
      "detail": "Default implementation returns empty string and derived syntax classes should override this method.",
      "params": {},
      "returns": "",
      "args_sig": "() const override"
    },
    "MaterialX::GlslSyntax::getConstantQualifier": {
      "brief": "Get the qualifier used when declaring constant variables.",
      "detail": "Derived classes must define this method.",
      "params": {},
      "returns": "",
      "args_sig": "() const override"
    },
    "MaterialX::GlslSyntax::getUniformQualifier": {
      "brief": "Get the qualifier used when declaring uniform variables.",
      "detail": "Default implementation returns empty string and derived syntax classes should override this method.",
      "params": {},
      "returns": "",
      "args_sig": "() const override"
    },
    "MaterialX::GlslSyntax::getSourceFileExtension": {
      "brief": "Return the file extension used for source code files in this language.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const override"
    },
    "MaterialX::GlslSyntax::typeSupported": {
      "brief": "Query if given type is supported in the syntax.",
      "detail": "By default all types are assumed to be supported.",
      "params": {},
      "returns": "",
      "args_sig": "(const TypeDesc *type) const override"
    },
    "MaterialX::GlslSyntax::remapEnumeration": {
      "brief": "Given an input specification attempt to remap this to an enumeration which is accepted by the shader generator.",
      "detail": "The enumeration may be converted to a different type than the input.",
      "params": {},
      "returns": "",
      "args_sig": "(const string &value,TypeDesc type,const string &enumNames,std::pair< TypeDesc,ValuePtr > &result) const override"
    },
    "MaterialX::GlslSyntax::createStructSyntax": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &structTypeName,const string &defaultValue,const string &uniformDefaultValue,const string &typeAlias,const string &typeDefinition) const override"
    },
    "MaterialX::GlslSyntax::create": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(TypeSystemPtr typeSystem)"
    },
    "MaterialX::GraphElement::addNode": {
      "brief": "Add a Node to the graph.",
      "detail": "",
      "params": {
        "category": "The category of the new Node.",
        "name": "The name of the new Node. If no name is specified, then a unique name will automatically be generated.",
        "type": "An optional type string."
      },
      "returns": "A shared pointer to the new Node.",
      "args_sig": "(const string &category,const string &name=EMPTY_STRING,const string &type=DEFAULT_TYPE_STRING)"
    },
    "MaterialX::GraphElement::addNodeInstance": {
      "brief": "Add a Node that is an instance of the given NodeDef.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(ConstNodeDefPtr nodeDef,const string &name=EMPTY_STRING)"
    },
    "MaterialX::GraphElement::getNode": {
      "brief": "Return the Node, if any, with the given name.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &name) const"
    },
    "MaterialX::GraphElement::getNodes": {
      "brief": "Return a vector of all Nodes in the graph, optionally filtered by the given category string.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &category=EMPTY_STRING) const"
    },
    "MaterialX::GraphElement::getNodesOfType": {
      "brief": "Return a vector of nodes in the graph which have a given type.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &nodeType) const"
    },
    "MaterialX::GraphElement::removeNode": {
      "brief": "Remove the Node, if any, with the given name.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &name)"
    },
    "MaterialX::GraphElement::addMaterialNode": {
      "brief": "Add a material node to the graph, optionally connecting it to the given shader node.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &name=EMPTY_STRING,ConstNodePtr shaderNode=nullptr)"
    },
    "MaterialX::GraphElement::getMaterialNodes": {
      "brief": "Return a vector of all material nodes.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::GraphElement::addBackdrop": {
      "brief": "Add a Backdrop to the graph.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &name=EMPTY_STRING)"
    },
    "MaterialX::GraphElement::getBackdrop": {
      "brief": "Return the Backdrop, if any, with the given name.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &name) const"
    },
    "MaterialX::GraphElement::getBackdrops": {
      "brief": "Return a vector of all Backdrop elements in the graph.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::GraphElement::removeBackdrop": {
      "brief": "Remove the Backdrop, if any, with the given name.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &name)"
    },
    "MaterialX::GraphElement::flattenSubgraphs": {
      "brief": "Flatten all subgraphs at the root scope of this graph element, recursively replacing each graph-defined node with its equivalent node network.",
      "detail": "",
      "params": {
        "target": "An optional target string to be used in specifying which node definitions are used in this process.",
        "filter": "An optional node predicate specifying which nodes should be included and excluded from this process."
      },
      "returns": "",
      "args_sig": "(const string &target=EMPTY_STRING,NodePredicate filter=nullptr)"
    },
    "MaterialX::GraphElement::topologicalSort": {
      "brief": "Return a vector of all children (nodes and outputs) sorted in topological order.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::GraphElement::addGeomNode": {
      "brief": "If not yet present, add a geometry node to this graph matching the given property definition and name prefix.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(ConstGeomPropDefPtr geomPropDef,const string &namePrefix)"
    },
    "MaterialX::GraphElement::asStringDot": {
      "brief": "Convert this graph to a string in the DOT language syntax.",
      "detail": "This can be used to visualise the graph using GraphViz (http://www.graphviz.org).\n\nIf declarations for the contained nodes are provided as nodedefs in the owning document, then they will be used to provide additional formatting details.",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::GraphElement::GraphElement": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(ElementPtr parent,const string &category,const string &name)"
    },
    "MaterialX::GraphElement::~GraphElement": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::GraphIterator::getDownstreamElement": {
      "brief": "Return the downstream element of the current edge.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::GraphIterator::getConnectingElement": {
      "brief": "Return the connecting element, if any, of the current edge.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::GraphIterator::getUpstreamElement": {
      "brief": "Return the upstream element of the current edge.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::GraphIterator::getUpstreamIndex": {
      "brief": "Return the index of the current edge within the range of upstream edges available to the downstream element.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::GraphIterator::getElementDepth": {
      "brief": "Return the element depth of the current traversal, where a single edge between two elements represents a depth of one.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::GraphIterator::getNodeDepth": {
      "brief": "Return the node depth of the current traversal, where a single edge between two nodes represents a depth of one.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::GraphIterator::setPruneSubgraph": {
      "brief": "Set the prune subgraph flag, which controls whether the current subgraph is pruned from traversal.",
      "detail": "",
      "params": {
        "prune": "If set to true, then the current subgraph will be pruned."
      },
      "returns": "",
      "args_sig": "(bool prune)"
    },
    "MaterialX::GraphIterator::getPruneSubgraph": {
      "brief": "Return the prune subgraph flag, which controls whether the current subgraph is pruned from traversal.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::GraphIterator::begin": {
      "brief": "Interpret this object as an iteration range, and return its begin iterator.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(size_t holdCount=0)"
    },
    "MaterialX::GraphIterator::end": {
      "brief": "Return the sentinel end iterator for this class.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::GraphIterator::GraphIterator": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(ElementPtr elem)"
    },
    "MaterialX::GraphIterator::~GraphIterator": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()=default"
    },
    "MaterialX::GraphIterator::operator==": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const GraphIterator &rhs) const"
    },
    "MaterialX::GraphIterator::operator!=": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const GraphIterator &rhs) const"
    },
    "MaterialX::GraphIterator::operator*": {
      "brief": "Dereference this iterator, returning the current edge in the traversal.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::GraphIterator::operator++": {
      "brief": "Iterate to the next edge in the traversal.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::GraphIterator::extendPathUpstream": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(ElementPtr upstreamElem,ElementPtr connectingElem)"
    },
    "MaterialX::GraphIterator::returnPathDownstream": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(ElementPtr upstreamElem)"
    },
    "MaterialX::GraphIterator::skipOrMarkAsVisited": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const Edge &)"
    },
    "MaterialX::GLContext::create": {
      "brief": "Create a new context.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(SimpleWindowPtr window,HardwareContextHandle context={})"
    },
    "MaterialX::GLContext::~GLContext": {
      "brief": "Default destructor.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::GLContext::contextHandle": {
      "brief": "Return OpenGL context handle.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::GLContext::isValid": {
      "brief": "Return if context is valid.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::GLContext::makeCurrent": {
      "brief": "Make the context \"current\" before execution of OpenGL operations.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::GLContext::GLContext": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(SimpleWindowPtr window,HardwareContextHandle context=0)"
    },
    "MaterialX::GLFramebuffer::create": {
      "brief": "Create a new framebuffer.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(unsigned int width,unsigned int height,unsigned int channelCount,Image::BaseType baseType)"
    },
    "MaterialX::GLFramebuffer::~GLFramebuffer": {
      "brief": "Destructor.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::GLFramebuffer::getWidth": {
      "brief": "Return the width of the framebuffer.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::GLFramebuffer::getHeight": {
      "brief": "Return the height of the framebuffer.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::GLFramebuffer::setEncodeSrgb": {
      "brief": "Set the encode sRGB flag, which controls whether values written to the framebuffer are encoded to the sRGB color space.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(bool encode)"
    },
    "MaterialX::GLFramebuffer::getEncodeSrgb": {
      "brief": "Return the encode sRGB flag.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::GLFramebuffer::bind": {
      "brief": "Bind the framebuffer for rendering.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::GLFramebuffer::unbind": {
      "brief": "Unbind the frame buffer after rendering.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::GLFramebuffer::getColorTexture": {
      "brief": "Return our color texture handle.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::GLFramebuffer::getDepthTexture": {
      "brief": "Return our depth texture handle.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::GLFramebuffer::getColorImage": {
      "brief": "Return the color data of this framebuffer as an image.",
      "detail": "If an input image is provided, it will be used to store the color data; otherwise a new image of the required format will be created.",
      "params": {},
      "returns": "",
      "args_sig": "(ImagePtr image=nullptr)"
    },
    "MaterialX::GLFramebuffer::blit": {
      "brief": "Blit our color texture to the back buffer.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::GLFramebuffer::GLFramebuffer": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(unsigned int width,unsigned int height,unsigned int channelCount,Image::BaseType baseType)"
    },
    "MaterialX::GLTextureHandler::create": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(ImageLoaderPtr imageLoader)"
    },
    "MaterialX::GLTextureHandler::mapAddressModeToGL": {
      "brief": "Utility to map an address mode enumeration to an OpenGL address mode.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(ImageSamplingProperties::AddressMode addressModeEnum)"
    },
    "MaterialX::GLTextureHandler::mapFilterTypeToGL": {
      "brief": "Utility to map a filter type enumeration to an OpenGL filter type.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(ImageSamplingProperties::FilterType filterTypeEnum,bool enableMipmaps=false)"
    },
    "MaterialX::GLTextureHandler::mapTextureFormatToGL": {
      "brief": "Utility to map generic texture properties to OpenGL texture formats.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(Image::BaseType baseType,unsigned int channelCount,bool srgb,int &glType,int &glFormat,int &glInternalFormat)"
    },
    "MaterialX::GLTextureHandler::bindImage": {
      "brief": "Bind an image.",
      "detail": "This method will bind the texture to an active texture unit as defined by the corresponding image description. The method will fail if there are not enough available image units to bind to.",
      "params": {},
      "returns": "",
      "args_sig": "(ImagePtr image,const ImageSamplingProperties &samplingProperties) override"
    },
    "MaterialX::GLTextureHandler::unbindImage": {
      "brief": "Unbind an image.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(ImagePtr image) override"
    },
    "MaterialX::GLTextureHandler::createRenderResources": {
      "brief": "Create rendering resources for the given image.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(ImagePtr image,bool generateMipMaps,bool useAsRenderTarget=false) override"
    },
    "MaterialX::GLTextureHandler::releaseRenderResources": {
      "brief": "Release rendering resources for the given image, or for all cached images if no image pointer is specified.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(ImagePtr image=nullptr) override"
    },
    "MaterialX::GLTextureHandler::getBoundTextureLocation": {
      "brief": "Return the bound texture location for a given resource.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(unsigned int resourceId)"
    },
    "MaterialX::GLTextureHandler::GLTextureHandler": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(ImageLoaderPtr imageLoader)"
    },
    "MaterialX::GLTextureHandler::getNextAvailableTextureLocation": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::Half::Half": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(float value)"
    },
    "MaterialX::Half::operator float": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::Half::operator==": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(Half rhs) const"
    },
    "MaterialX::Half::operator!=": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(Half rhs) const"
    },
    "MaterialX::Half::operator<": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(Half rhs) const"
    },
    "MaterialX::Half::operator>": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(Half rhs) const"
    },
    "MaterialX::Half::operator<=": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(Half rhs) const"
    },
    "MaterialX::Half::operator>=": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(Half rhs) const"
    },
    "MaterialX::Half::operator+": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(Half rhs) const"
    },
    "MaterialX::Half::operator-": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::Half::operator*": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(Half rhs) const"
    },
    "MaterialX::Half::operator/": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(Half rhs) const"
    },
    "MaterialX::Half::operator+=": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(Half rhs)"
    },
    "MaterialX::Half::operator-=": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(Half rhs)"
    },
    "MaterialX::Half::operator*=": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(Half rhs)"
    },
    "MaterialX::Half::operator/=": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(Half rhs)"
    },
    "MaterialX::Half::toFloat16": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(float value)"
    },
    "MaterialX::Half::toFloat32": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(uint16_t value)"
    },
    "MaterialX::Image::getWidth": {
      "brief": "Return the width of the image.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::Image::getHeight": {
      "brief": "Return the height of the image.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::Image::getChannelCount": {
      "brief": "Return the channel count of the image.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::Image::getBaseType": {
      "brief": "Return the base type of the image.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::Image::getBaseStride": {
      "brief": "Return the stride of our base type in bytes.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::Image::getRowStride": {
      "brief": "Return the stride of an image row in bytes.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::Image::getMaxMipCount": {
      "brief": "Return the maximum number of mipmaps for this image.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::Image::setTexelColor": {
      "brief": "Set the texel color at the given coordinates.",
      "detail": "If the coordinates or image resource buffer are invalid, then an exception is thrown.",
      "params": {},
      "returns": "",
      "args_sig": "(unsigned int x,unsigned int y,const Color4 &color)"
    },
    "MaterialX::Image::getTexelColor": {
      "brief": "Return the texel color at the given coordinates.",
      "detail": "If the coordinates or image resource buffer are invalid, then an exception is thrown.",
      "params": {},
      "returns": "",
      "args_sig": "(unsigned int x,unsigned int y) const"
    },
    "MaterialX::Image::getAverageColor": {
      "brief": "Compute the average color of the image.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::Image::isUniformColor": {
      "brief": "Return true if all texels of this image are identical in color.",
      "detail": "",
      "params": {
        "uniformColor": "Return the uniform color of the image, if any."
      },
      "returns": "",
      "args_sig": "(Color4 *uniformColor=nullptr)"
    },
    "MaterialX::Image::setUniformColor": {
      "brief": "Set all texels of this image to a uniform color.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const Color4 &color)"
    },
    "MaterialX::Image::applyMatrixTransform": {
      "brief": "Apply the given matrix transform to all texels of this image.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const Matrix33 &mat)"
    },
    "MaterialX::Image::applyGammaTransform": {
      "brief": "Apply the given gamma transform to all texels of this image.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(float gamma)"
    },
    "MaterialX::Image::copy": {
      "brief": "Create a copy of this image with the given channel count and base type.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(unsigned int channelCount,BaseType baseType) const"
    },
    "MaterialX::Image::applyBoxBlur": {
      "brief": "Apply a 3x3 box blur to this image, returning a new blurred image.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::Image::applyGaussianBlur": {
      "brief": "Apply a 7x7 Gaussian blur to this image, returning a new blurred image.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::Image::applyBoxDownsample": {
      "brief": "Downsample this image by an integer factor using a box filter, returning the new reduced image.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(unsigned int factor)"
    },
    "MaterialX::Image::splitByLuminance": {
      "brief": "Split this image by the given luminance threshold, returning the resulting underflow and overflow images.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(float luminance)"
    },
    "MaterialX::Image::writeTable": {
      "brief": "Save a channel of this image to disk as a text table, in a format that can be used for curve and surface fitting.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const FilePath &filePath,unsigned int channel)"
    },
    "MaterialX::Image::setResourceBuffer": {
      "brief": "Set the resource buffer for this image.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(void *buffer)"
    },
    "MaterialX::Image::getResourceBuffer": {
      "brief": "Return the resource buffer for this image.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::Image::createResourceBuffer": {
      "brief": "Allocate a resource buffer for this image that matches its properties.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::Image::releaseResourceBuffer": {
      "brief": "Release the resource buffer for this image.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::Image::setResourceBufferDeallocator": {
      "brief": "Set the resource buffer deallocator for this image.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(ImageBufferDeallocator deallocator)"
    },
    "MaterialX::Image::getResourceBufferDeallocator": {
      "brief": "Return the resource buffer deallocator for this image.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::Image::setResourceId": {
      "brief": "Set the resource ID for this image.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(unsigned int id)"
    },
    "MaterialX::Image::getResourceId": {
      "brief": "Return the resource ID for this image.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::Image::create": {
      "brief": "Create an empty image with the given properties.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(unsigned int width,unsigned int height,unsigned int channelCount,BaseType baseType=BaseType::UINT8)"
    },
    "MaterialX::Image::~Image": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::Image::Image": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(unsigned int width,unsigned int height,unsigned int channelCount,BaseType baseType)"
    },
    "MaterialX::ImageHandler::create": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(ImageLoaderPtr imageLoader)"
    },
    "MaterialX::ImageHandler::~ImageHandler": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::ImageHandler::addLoader": {
      "brief": "Add another image loader to the handler, which will be invoked if existing loaders cannot load a given image.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(ImageLoaderPtr loader)"
    },
    "MaterialX::ImageHandler::supportedExtensions": {
      "brief": "Get a list of extensions supported by the handler.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::ImageHandler::saveImage": {
      "brief": "Save image to disk.",
      "detail": "",
      "params": {
        "filePath": "File path to be written",
        "image": "The image to be saved",
        "verticalFlip": "Whether the image should be flipped in Y during save"
      },
      "returns": "if save succeeded",
      "args_sig": "(const FilePath &filePath,ConstImagePtr image,bool verticalFlip=false)"
    },
    "MaterialX::ImageHandler::acquireImage": {
      "brief": "Acquire an image from the cache or file system.",
      "detail": "",
      "params": {
        "filePath": "File path of the image.",
        "defaultColor": "Default color to use as a fallback for missing images."
      },
      "returns": "On success, a shared pointer to the acquired image.",
      "args_sig": "(const FilePath &filePath,const Color4 &defaultColor=Color4(0.0f))"
    },
    "MaterialX::ImageHandler::bindImage": {
      "brief": "Bind an image for rendering.",
      "detail": "",
      "params": {
        "image": "The image to bind.",
        "samplingProperties": "Sampling properties for the image."
      },
      "returns": "",
      "args_sig": "(ImagePtr image,const ImageSamplingProperties &samplingProperties)"
    },
    "MaterialX::ImageHandler::unbindImage": {
      "brief": "Unbind an image, making it no longer active for rendering.",
      "detail": "",
      "params": {
        "image": "The image to unbind."
      },
      "returns": "",
      "args_sig": "(ImagePtr image)"
    },
    "MaterialX::ImageHandler::unbindImages": {
      "brief": "Unbind all images that are currently stored in the cache.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::ImageHandler::setSearchPath": {
      "brief": "Set the search path to be used for finding images on the file system.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const FileSearchPath &path)"
    },
    "MaterialX::ImageHandler::getSearchPath": {
      "brief": "Return the image search path.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::ImageHandler::setFilenameResolver": {
      "brief": "Set the filename resolver for images.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(StringResolverPtr resolver)"
    },
    "MaterialX::ImageHandler::getFilenameResolver": {
      "brief": "Return the filename resolver for images.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::ImageHandler::createRenderResources": {
      "brief": "Create rendering resources for the given image.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(ImagePtr image,bool generateMipMaps,bool useAsRenderTarget=false)"
    },
    "MaterialX::ImageHandler::releaseRenderResources": {
      "brief": "Release rendering resources for the given image, or for all cached images if no image pointer is specified.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(ImagePtr image=nullptr)"
    },
    "MaterialX::ImageHandler::clearImageCache": {
      "brief": "Clear the contents of the image cache, first releasing any render resources associated with cached images.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::ImageHandler::getZeroImage": {
      "brief": "Return a fallback image with zeroes in all channels.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::ImageHandler::getReferencedImages": {
      "brief": "Acquire all images referenced by the given document, and return the images in a vector.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(ConstDocumentPtr doc)"
    },
    "MaterialX::ImageHandler::ImageHandler": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(ImageLoaderPtr imageLoader)"
    },
    "MaterialX::ImageHandler::loadImage": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const FilePath &filePath)"
    },
    "MaterialX::ImageHandler::cacheImage": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &filePath,ImagePtr image)"
    },
    "MaterialX::ImageHandler::getCachedImage": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const FilePath &filePath)"
    },
    "MaterialX::ImageLoader::ImageLoader": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::ImageLoader::~ImageLoader": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::ImageLoader::supportedExtensions": {
      "brief": "Returns a list of supported extensions.",
      "detail": "",
      "params": {},
      "returns": "List of support extensions",
      "args_sig": "() const"
    },
    "MaterialX::ImageLoader::saveImage": {
      "brief": "Save an image to the file system.",
      "detail": "",
      "params": {
        "filePath": "File path to be written",
        "image": "The image to be saved",
        "verticalFlip": "Whether the image should be flipped in Y during save"
      },
      "returns": "if save succeeded",
      "args_sig": "(const FilePath &filePath,ConstImagePtr image,bool verticalFlip=false)"
    },
    "MaterialX::ImageLoader::loadImage": {
      "brief": "Load an image from the file system.",
      "detail": "",
      "params": {
        "filePath": "The requested image file path."
      },
      "returns": "On success, a shared pointer to the loaded image; otherwise an empty shared pointer.",
      "args_sig": "(const FilePath &filePath)"
    },
    "MaterialX::ImageSamplingProperties::setProperties": {
      "brief": "Set the properties based on data in a uniform block.",
      "detail": "",
      "params": {
        "fileNameUniform": "Name of the file name uniform. Used to find corresponding sampler data in the uniform block",
        "uniformBlock": "Block containing sampler uniforms"
      },
      "returns": "",
      "args_sig": "(const string &fileNameUniform,const VariableBlock &uniformBlock)"
    },
    "MaterialX::ImageSamplingProperties::operator==": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const ImageSamplingProperties &r) const"
    },
    "MaterialX::Implementation::setFile": {
      "brief": "Set the file string for the Implementation.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &file)"
    },
    "MaterialX::Implementation::hasFile": {
      "brief": "Return true if the given Implementation has a file string.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::Implementation::getFile": {
      "brief": "Return the file string for the Implementation.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::Implementation::setFunction": {
      "brief": "Set the function string for the Implementation.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &function)"
    },
    "MaterialX::Implementation::hasFunction": {
      "brief": "Return true if the given Implementation has a function string.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::Implementation::getFunction": {
      "brief": "Return the function string for the Implementation.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::Implementation::setNodeGraph": {
      "brief": "Set the nodegraph string for the Implementation.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &nodegraph)"
    },
    "MaterialX::Implementation::hasNodeGraph": {
      "brief": "Return true if the given Implementation has a nodegraph string.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::Implementation::getNodeGraph": {
      "brief": "Return the nodegraph string for the Implementation.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::Implementation::setNodeDef": {
      "brief": "Set the NodeDef element referenced by the Implementation.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(ConstNodeDefPtr nodeDef)"
    },
    "MaterialX::Implementation::getNodeDef": {
      "brief": "Return the NodeDef element referenced by the Implementation.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::Implementation::validate": {
      "brief": "Validate that the given element tree, including all descendants, is consistent with the MaterialX specification.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(string *message=nullptr) const override"
    },
    "MaterialX::Implementation::getDeclaration": {
      "brief": "Return the first declaration of this interface, optionally filtered by the given target name.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &target=EMPTY_STRING) const override"
    },
    "MaterialX::Implementation::Implementation": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(ElementPtr parent,const string &name)"
    },
    "MaterialX::Implementation::~Implementation": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::InheritanceIterator::InheritanceIterator": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(ConstElementPtr elem)"
    },
    "MaterialX::InheritanceIterator::~InheritanceIterator": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()=default"
    },
    "MaterialX::InheritanceIterator::operator==": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const InheritanceIterator &rhs) const"
    },
    "MaterialX::InheritanceIterator::operator!=": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const InheritanceIterator &rhs) const"
    },
    "MaterialX::InheritanceIterator::operator*": {
      "brief": "Dereference this iterator, returning the current element in the traversal.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::InheritanceIterator::operator++": {
      "brief": "Iterate to the next element in the traversal.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::InheritanceIterator::begin": {
      "brief": "Interpret this object as an iteration range, and return its begin iterator.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(size_t holdCount=0)"
    },
    "MaterialX::InheritanceIterator::end": {
      "brief": "Return the sentinel end iterator for this class.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::Input::setDefaultGeomPropString": {
      "brief": "Set the defaultgeomprop string for the input.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &geomprop)"
    },
    "MaterialX::Input::hasDefaultGeomPropString": {
      "brief": "Return true if the given input has a defaultgeomprop string.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::Input::getDefaultGeomPropString": {
      "brief": "Return the defaultgeomprop string for the input.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::Input::getDefaultGeomProp": {
      "brief": "Return the GeomPropDef element to use, if defined for this input.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::Input::getConnectedNode": {
      "brief": "Return the node, if any, to which this input is connected.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const override"
    },
    "MaterialX::Input::setConnectedInterfaceName": {
      "brief": "Connects this input to a corresponding interface with the given name.",
      "detail": "If the interface name specified is an empty string then any existing connection is removed.",
      "params": {},
      "returns": "",
      "args_sig": "(const string &interfaceName)"
    },
    "MaterialX::Input::getInterfaceInput": {
      "brief": "Return the input on the parent graph corresponding to the interface name for this input.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::Input::hasHint": {
      "brief": "Return true if the input has a hint.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::Input::getHint": {
      "brief": "Return the code generation hint.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::Input::setHint": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &hint)"
    },
    "MaterialX::Input::validate": {
      "brief": "Validate that the given element tree, including all descendants, is consistent with the MaterialX specification.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(string *message=nullptr) const override"
    },
    "MaterialX::Input::Input": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(ElementPtr parent,const string &name)"
    },
    "MaterialX::Input::~Input": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::InterfaceElement::setNodeDefString": {
      "brief": "Set the NodeDef string for the interface.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &nodeDef)"
    },
    "MaterialX::InterfaceElement::hasNodeDefString": {
      "brief": "Return true if the given interface has a NodeDef string.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::InterfaceElement::getNodeDefString": {
      "brief": "Return the NodeDef string for the interface.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::InterfaceElement::addInput": {
      "brief": "Add an Input to this interface.",
      "detail": "",
      "params": {
        "name": "The name of the new Input. If no name is specified, then a unique name will automatically be generated.",
        "type": "An optional type string."
      },
      "returns": "A shared pointer to the new Input.",
      "args_sig": "(const string &name=EMPTY_STRING,const string &type=DEFAULT_TYPE_STRING)"
    },
    "MaterialX::InterfaceElement::getInput": {
      "brief": "Return the Input, if any, with the given name.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &name) const"
    },
    "MaterialX::InterfaceElement::getInputs": {
      "brief": "Return a vector of all Input elements.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::InterfaceElement::getInputCount": {
      "brief": "Return the number of Input elements.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::InterfaceElement::removeInput": {
      "brief": "Remove the Input, if any, with the given name.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &name)"
    },
    "MaterialX::InterfaceElement::getActiveInput": {
      "brief": "Return the first Input with the given name that belongs to this interface, taking interface inheritance into account.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &name) const"
    },
    "MaterialX::InterfaceElement::getActiveInputs": {
      "brief": "Return a vector of all Input elements that belong to this interface, taking inheritance into account.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::InterfaceElement::addOutput": {
      "brief": "Add an Output to this interface.",
      "detail": "",
      "params": {
        "name": "The name of the new Output. If no name is specified, then a unique name will automatically be generated.",
        "type": "An optional type string."
      },
      "returns": "A shared pointer to the new Output.",
      "args_sig": "(const string &name=EMPTY_STRING,const string &type=DEFAULT_TYPE_STRING)"
    },
    "MaterialX::InterfaceElement::getOutput": {
      "brief": "Return the Output, if any, with the given name.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &name) const"
    },
    "MaterialX::InterfaceElement::getOutputs": {
      "brief": "Return a vector of all Output elements.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::InterfaceElement::getOutputCount": {
      "brief": "Return the number of Output elements.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::InterfaceElement::removeOutput": {
      "brief": "Remove the Output, if any, with the given name.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &name)"
    },
    "MaterialX::InterfaceElement::getActiveOutput": {
      "brief": "Return the first Output with the given name that belongs to this interface, taking interface inheritance into account.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &name) const"
    },
    "MaterialX::InterfaceElement::getActiveOutputs": {
      "brief": "Return a vector of all Output elements that belong to this interface, taking inheritance into account.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::InterfaceElement::setConnectedOutput": {
      "brief": "Set the output to which the given input is connected, creating a child input if needed.",
      "detail": "If the node argument is null, then any existing output connection on the input will be cleared.",
      "params": {},
      "returns": "",
      "args_sig": "(const string &inputName,OutputPtr output)"
    },
    "MaterialX::InterfaceElement::getConnectedOutput": {
      "brief": "Return the output connected to the given input.",
      "detail": "If the given input is not present, then an empty OutputPtr is returned.",
      "params": {},
      "returns": "",
      "args_sig": "(const string &inputName) const"
    },
    "MaterialX::InterfaceElement::addToken": {
      "brief": "Add a Token to this interface.",
      "detail": "",
      "params": {
        "name": "The name of the new Token. If no name is specified, then a unique name will automatically be generated."
      },
      "returns": "A shared pointer to the new Token.",
      "args_sig": "(const string &name=EMPTY_STRING)"
    },
    "MaterialX::InterfaceElement::getToken": {
      "brief": "Return the Token, if any, with the given name.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &name) const"
    },
    "MaterialX::InterfaceElement::getTokens": {
      "brief": "Return a vector of all Token elements.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::InterfaceElement::removeToken": {
      "brief": "Remove the Token, if any, with the given name.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &name)"
    },
    "MaterialX::InterfaceElement::getActiveToken": {
      "brief": "Return the first Token with the given name that belongs to this interface, taking interface inheritance into account.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &name) const"
    },
    "MaterialX::InterfaceElement::getActiveTokens": {
      "brief": "Return a vector of all Token elements that belong to this interface, taking inheritance into account.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::InterfaceElement::getValueElement": {
      "brief": "Return the ValueElement, if any, with the given name.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &name) const"
    },
    "MaterialX::InterfaceElement::getActiveValueElement": {
      "brief": "Return the first value element with the given name that belongs to this interface, taking interface inheritance into account.",
      "detail": "Examples of value elements are Input, Output, and Token.",
      "params": {},
      "returns": "",
      "args_sig": "(const string &name) const"
    },
    "MaterialX::InterfaceElement::getActiveValueElements": {
      "brief": "Return a vector of all value elements that belong to this interface, taking inheritance into account.",
      "detail": "Examples of value elements are Input, Output, and Token.",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::InterfaceElement::setInputValue": {
      "brief": "Set the typed value of an input by its name, creating a child element to hold the input if needed.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &name,const T &value,const string &type=EMPTY_STRING)"
    },
    "MaterialX::InterfaceElement::getInputValue": {
      "brief": "Return the typed value of an input by its name, taking both the calling element and its declaration into account.",
      "detail": "",
      "params": {
        "name": "The name of the input to be evaluated.",
        "target": "An optional target name, which will be used to filter the declarations that are considered."
      },
      "returns": "If the given input is found in this interface or its declaration, then a shared pointer to its value is returned; otherwise, an empty shared pointer is returned.",
      "args_sig": "(const string &name,const string &target=EMPTY_STRING) const"
    },
    "MaterialX::InterfaceElement::setTokenValue": {
      "brief": "Set the string value of a Token by its name, creating a child element to hold the Token if needed.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &name,const string &value)"
    },
    "MaterialX::InterfaceElement::getTokenValue": {
      "brief": "Return the string value of a Token by its name, or an empty string if the given Token is not present.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &name)"
    },
    "MaterialX::InterfaceElement::setTarget": {
      "brief": "Set the target string of this interface.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &target)"
    },
    "MaterialX::InterfaceElement::hasTarget": {
      "brief": "Return true if the given interface has a target string.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::InterfaceElement::getTarget": {
      "brief": "Return the target string of this interface.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::InterfaceElement::setVersionString": {
      "brief": "Set the version string of this interface.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &version)"
    },
    "MaterialX::InterfaceElement::hasVersionString": {
      "brief": "Return true if this interface has a version string.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::InterfaceElement::getVersionString": {
      "brief": "Return the version string of this interface.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::InterfaceElement::setVersionIntegers": {
      "brief": "Set the major and minor versions as an integer pair.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(int majorVersion,int minorVersion)"
    },
    "MaterialX::InterfaceElement::getVersionIntegers": {
      "brief": "Return the major and minor versions as an integer pair.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::InterfaceElement::setDefaultVersion": {
      "brief": "Set the default version flag of this element.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(bool defaultVersion)"
    },
    "MaterialX::InterfaceElement::getDefaultVersion": {
      "brief": "Return the default version flag of this element.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::InterfaceElement::getDeclaration": {
      "brief": "Return the first declaration of this interface, optionally filtered by the given target name.",
      "detail": "",
      "params": {
        "target": "An optional target name, which will be used to filter the declarations that are considered."
      },
      "returns": "A shared pointer to declaration, or an empty shared pointer if no declaration was found.",
      "args_sig": "(const string &target=EMPTY_STRING) const"
    },
    "MaterialX::InterfaceElement::clearContent": {
      "brief": "Clear all attributes and descendants from this element.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() override"
    },
    "MaterialX::InterfaceElement::hasExactInputMatch": {
      "brief": "Return true if this instance has an exact input match with the given declaration, where each input of this the instance corresponds to a declaration input of the same name and type.",
      "detail": "If an exact input match is not found, and the optional message argument is provided, then an error message will be appended to the given string.",
      "params": {},
      "returns": "",
      "args_sig": "(ConstInterfaceElementPtr declaration,string *message=nullptr) const"
    },
    "MaterialX::InterfaceElement::InterfaceElement": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(ElementPtr parent,const string &category,const string &name)"
    },
    "MaterialX::InterfaceElement::registerChildElement": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(ElementPtr child) override"
    },
    "MaterialX::InterfaceElement::unregisterChildElement": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(ElementPtr child) override"
    },
    "MaterialX::InterfaceElement::~InterfaceElement": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::LightHandler::setLightTransform": {
      "brief": "Set the light transform.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const Matrix44 &mat)"
    },
    "MaterialX::LightHandler::getLightTransform": {
      "brief": "Return the light transform.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::LightHandler::setDirectLighting": {
      "brief": "Set whether direct lighting is enabled.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(bool enable)"
    },
    "MaterialX::LightHandler::getDirectLighting": {
      "brief": "Return whether direct lighting is enabled.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::LightHandler::setIndirectLighting": {
      "brief": "Set whether indirect lighting is enabled.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(bool enable)"
    },
    "MaterialX::LightHandler::getIndirectLighting": {
      "brief": "Return whether indirect lighting is enabled.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::LightHandler::setEnvRadianceMap": {
      "brief": "Set the environment radiance map.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(ImagePtr map)"
    },
    "MaterialX::LightHandler::getEnvRadianceMap": {
      "brief": "Return the environment radiance map.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::LightHandler::setEnvPrefilteredMap": {
      "brief": "Set the environment radiance map for the prefiltered environment lighting model.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(ImagePtr map)"
    },
    "MaterialX::LightHandler::getEnvPrefilteredMap": {
      "brief": "Return the environment radiance map for the prefiltered environment lighting model.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::LightHandler::setUsePrefilteredMap": {
      "brief": "Set whether to use the prefiltered environment lighting model.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(bool val)"
    },
    "MaterialX::LightHandler::getUsePrefilteredMap": {
      "brief": "Return whether to use the prefiltered environment lighting model.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::LightHandler::setEnvIrradianceMap": {
      "brief": "Set the environment irradiance map.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(ImagePtr map)"
    },
    "MaterialX::LightHandler::getEnvIrradianceMap": {
      "brief": "Return the environment irradiance map.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::LightHandler::setEnvSampleCount": {
      "brief": "Set the environment lighting sample count.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(int count)"
    },
    "MaterialX::LightHandler::getEnvSampleCount": {
      "brief": "Return the environment lighting sample count.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::LightHandler::setEnvLightIntensity": {
      "brief": "Set the environment light intensity.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const float intensity)"
    },
    "MaterialX::LightHandler::getEnvLightIntensity": {
      "brief": "Return the environment light intensity.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::LightHandler::setRefractionTwoSided": {
      "brief": "Set the two-sided refraction property.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(bool enable)"
    },
    "MaterialX::LightHandler::getRefractionTwoSided": {
      "brief": "Return the two-sided refraction property.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::LightHandler::setAlbedoTable": {
      "brief": "Set the directional albedo table.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(ImagePtr table)"
    },
    "MaterialX::LightHandler::getAlbedoTable": {
      "brief": "Return the directional albedo table.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::LightHandler::addLightSource": {
      "brief": "Add a light source.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(NodePtr node)"
    },
    "MaterialX::LightHandler::setLightSources": {
      "brief": "Set the vector of light sources.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const vector< NodePtr > &lights)"
    },
    "MaterialX::LightHandler::getLightSources": {
      "brief": "Return the vector of light sources.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::LightHandler::getFirstLightOfCategory": {
      "brief": "Return the first light source, if any, of the given category.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &category)"
    },
    "MaterialX::LightHandler::getLightIdMap": {
      "brief": "Get a list of identifiers associated with a given light nodedef.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::LightHandler::computeLightIdMap": {
      "brief": "From a set of nodes, create a mapping of corresponding nodedef identifiers to numbers.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const vector< NodePtr > &nodes)"
    },
    "MaterialX::LightHandler::findLights": {
      "brief": "Find lights to use based on an input document.",
      "detail": "",
      "params": {
        "doc": "Document to scan for lights",
        "lights": "List of lights found in document"
      },
      "returns": "",
      "args_sig": "(DocumentPtr doc,vector< NodePtr > &lights)"
    },
    "MaterialX::LightHandler::registerLights": {
      "brief": "Register light node definitions and light count with a given generation context.",
      "detail": "",
      "params": {
        "doc": "Document containing light nodes and definitions",
        "lights": "Lights to register",
        "context": "Context to update"
      },
      "returns": "",
      "args_sig": "(DocumentPtr doc,const vector< NodePtr > &lights,GenContext &context)"
    },
    "MaterialX::LightHandler::LightHandler": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::LightHandler::~LightHandler": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::LightHandler::create": {
      "brief": "Create a new light handler.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::LinearUnitConverter::getUnitScale": {
      "brief": "Return the mappings from unit names to the scale value defined by a linear converter.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::LinearUnitConverter::conversionRatio": {
      "brief": "Ratio between the given unit to a desired unit.",
      "detail": "",
      "params": {
        "inputUnit": "Unit of input value",
        "outputUnit": "Unit for output value"
      },
      "returns": "",
      "args_sig": "(const string &inputUnit,const string &outputUnit) const"
    },
    "MaterialX::LinearUnitConverter::convert": {
      "brief": "Convert a given value in a given unit to a desired unit.",
      "detail": "",
      "params": {
        "input": "Input value to convert",
        "inputUnit": "Unit of input value",
        "outputUnit": "Unit for output value"
      },
      "returns": "",
      "args_sig": "(const Vector4 &input,const string &inputUnit,const string &outputUnit) const override"
    },
    "MaterialX::LinearUnitConverter::getUnitAsInteger": {
      "brief": "Given a unit name return a value that it can map to as an integer.",
      "detail": "Returns -1 value if not found",
      "params": {},
      "returns": "",
      "args_sig": "(const string &unitName) const override"
    },
    "MaterialX::LinearUnitConverter::getUnitFromInteger": {
      "brief": "Given an integer index return the unit name in the map used by the converter.",
      "detail": "Returns Empty string if not found",
      "params": {},
      "returns": "",
      "args_sig": "(int index) const override"
    },
    "MaterialX::LinearUnitConverter::~LinearUnitConverter": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::LinearUnitConverter::getUnitType": {
      "brief": "Return the unit type string.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::LinearUnitConverter::write": {
      "brief": "Create unit definitions in a document based on the converter.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(DocumentPtr doc) const override"
    },
    "MaterialX::LinearUnitConverter::create": {
      "brief": "Creator.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(UnitTypeDefPtr UnitDef)"
    },
    "MaterialX::LinearUnitConverter::LinearUnitConverter": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(UnitTypeDefPtr UnitDef)"
    },
    "MaterialX::Look::addMaterialAssign": {
      "brief": "Add a MaterialAssign to the look.",
      "detail": "",
      "params": {
        "name": "The name of the new MaterialAssign. If no name is specified, then a unique name will automatically be generated.",
        "material": "An optional material string, which should match the name of the material node to be assigned."
      },
      "returns": "A shared pointer to the new MaterialAssign.",
      "args_sig": "(const string &name=EMPTY_STRING,const string &material=EMPTY_STRING)"
    },
    "MaterialX::Look::getMaterialAssign": {
      "brief": "Return the MaterialAssign, if any, with the given name.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &name) const"
    },
    "MaterialX::Look::getMaterialAssigns": {
      "brief": "Return a vector of all MaterialAssign elements in the look.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::Look::getActiveMaterialAssigns": {
      "brief": "Return a vector of all MaterialAssign elements that belong to this look, taking look inheritance into account.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::Look::removeMaterialAssign": {
      "brief": "Remove the MaterialAssign, if any, with the given name.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &name)"
    },
    "MaterialX::Look::addPropertyAssign": {
      "brief": "Add a PropertyAssign to the look.",
      "detail": "",
      "params": {
        "name": "The name of the new PropertyAssign. If no name is specified, then a unique name will automatically be generated."
      },
      "returns": "A shared pointer to the new PropertyAssign.",
      "args_sig": "(const string &name=EMPTY_STRING)"
    },
    "MaterialX::Look::getPropertyAssign": {
      "brief": "Return the PropertyAssign, if any, with the given name.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &name) const"
    },
    "MaterialX::Look::getPropertyAssigns": {
      "brief": "Return a vector of all PropertyAssign elements in the look.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::Look::getActivePropertyAssigns": {
      "brief": "Return a vector of all PropertyAssign elements that belong to this look, taking look inheritance into account.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::Look::removePropertyAssign": {
      "brief": "Remove the PropertyAssign, if any, with the given name.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &name)"
    },
    "MaterialX::Look::addPropertySetAssign": {
      "brief": "Add a PropertySetAssign to the look.",
      "detail": "",
      "params": {
        "name": "The name of the new PropertySetAssign. If no name is specified, then a unique name will automatically be generated."
      },
      "returns": "A shared pointer to the new PropertySetAssign.",
      "args_sig": "(const string &name=EMPTY_STRING)"
    },
    "MaterialX::Look::getPropertySetAssign": {
      "brief": "Return the PropertySetAssign, if any, with the given name.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &name) const"
    },
    "MaterialX::Look::getPropertySetAssigns": {
      "brief": "Return a vector of all PropertySetAssign elements in the look.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::Look::getActivePropertySetAssigns": {
      "brief": "Return a vector of all PropertySetAssign elements that belong to this look, taking look inheritance into account.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::Look::removePropertySetAssign": {
      "brief": "Remove the PropertySetAssign, if any, with the given name.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &name)"
    },
    "MaterialX::Look::addVariantAssign": {
      "brief": "Add a VariantAssign to the look.",
      "detail": "",
      "params": {
        "name": "The name of the new VariantAssign. If no name is specified, then a unique name will automatically be generated."
      },
      "returns": "A shared pointer to the new VariantAssign.",
      "args_sig": "(const string &name=EMPTY_STRING)"
    },
    "MaterialX::Look::getVariantAssign": {
      "brief": "Return the VariantAssign, if any, with the given name.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &name) const"
    },
    "MaterialX::Look::getVariantAssigns": {
      "brief": "Return a vector of all VariantAssign elements in the look.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::Look::getActiveVariantAssigns": {
      "brief": "Return a vector of all VariantAssign elements that belong to this look, taking look inheritance into account.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::Look::removeVariantAssign": {
      "brief": "Remove the VariantAssign, if any, with the given name.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &name)"
    },
    "MaterialX::Look::addVisibility": {
      "brief": "Add a Visibility to the look.",
      "detail": "",
      "params": {
        "name": "The name of the new Visibility. If no name is specified, then a unique name will automatically be generated."
      },
      "returns": "A shared pointer to the new Visibility.",
      "args_sig": "(const string &name=EMPTY_STRING)"
    },
    "MaterialX::Look::getVisibility": {
      "brief": "Return the Visibility, if any, with the given name.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &name) const"
    },
    "MaterialX::Look::getVisibilities": {
      "brief": "Return a vector of all Visibility elements in the look.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::Look::getActiveVisibilities": {
      "brief": "Return a vector of all Visibility elements that belong to this look, taking look inheritance into account.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::Look::removeVisibility": {
      "brief": "Remove the Visibility, if any, with the given name.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &name)"
    },
    "MaterialX::Look::Look": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(ElementPtr parent,const string &name)"
    },
    "MaterialX::Look::~Look": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::LookGroup::LookGroup": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(ElementPtr parent,const string &name)"
    },
    "MaterialX::LookGroup::~LookGroup": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::LookGroup::setLooks": {
      "brief": "Set comma-separated list of looks.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &looks)"
    },
    "MaterialX::LookGroup::getLooks": {
      "brief": "Get comma-separated list of looks.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::LookGroup::setActiveLook": {
      "brief": "Set the active look.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &look)"
    },
    "MaterialX::LookGroup::getActiveLook": {
      "brief": "Return the active look, if any.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::MaterialAssign::addVariantAssign": {
      "brief": "Add a VariantAssign to the look.",
      "detail": "",
      "params": {
        "name": "The name of the new VariantAssign. If no name is specified, then a unique name will automatically be generated."
      },
      "returns": "A shared pointer to the new VariantAssign.",
      "args_sig": "(const string &name=EMPTY_STRING)"
    },
    "MaterialX::MaterialAssign::getVariantAssign": {
      "brief": "Return the VariantAssign, if any, with the given name.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &name) const"
    },
    "MaterialX::MaterialAssign::getVariantAssigns": {
      "brief": "Return a vector of all VariantAssign elements in the look.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::MaterialAssign::getActiveVariantAssigns": {
      "brief": "Return a vector of all VariantAssign elements that belong to this look, taking look inheritance into account.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::MaterialAssign::removeVariantAssign": {
      "brief": "Remove the VariantAssign, if any, with the given name.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &name)"
    },
    "MaterialX::MaterialAssign::setMaterial": {
      "brief": "Set the material string for the MaterialAssign.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &material)"
    },
    "MaterialX::MaterialAssign::hasMaterial": {
      "brief": "Return true if the given MaterialAssign has a material string.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::MaterialAssign::getMaterial": {
      "brief": "Return the material string for the MaterialAssign.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::MaterialAssign::getMaterialOutputs": {
      "brief": "Return the outputs on any referenced material.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::MaterialAssign::setExclusive": {
      "brief": "Set the exclusive boolean for the MaterialAssign.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(bool value)"
    },
    "MaterialX::MaterialAssign::getExclusive": {
      "brief": "Return the exclusive boolean for the MaterialAssign.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::MaterialAssign::getReferencedMaterial": {
      "brief": "Return the material node, if any, referenced by the MaterialAssign.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::MaterialAssign::MaterialAssign": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(ElementPtr parent,const string &name)"
    },
    "MaterialX::MaterialAssign::~MaterialAssign": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::MaterialNode::create": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::MaterialNode::addClassification": {
      "brief": "Add additional classifications on a node.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(ShaderNode &node) const override"
    },
    "MaterialX::MaterialNode::emitFunctionCall": {
      "brief": "Emit the function call or inline source code for given node instance in the given context.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const ShaderNode &node,GenContext &context,ShaderStage &stage) const override"
    },
    "MaterialX::Matrix33::getTranspose": {
      "brief": "Return the transpose of the matrix.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::Matrix33::getDeterminant": {
      "brief": "Return the determinant of the matrix.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::Matrix33::getAdjugate": {
      "brief": "Return the adjugate of the matrix.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::Matrix33::getInverse": {
      "brief": "Return the inverse of the matrix.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::Matrix33::multiply": {
      "brief": "Return the product of this matrix and a 3D vector.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const Vector3 &v) const"
    },
    "MaterialX::Matrix33::transformPoint": {
      "brief": "Transform the given 2D point.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const Vector2 &v) const"
    },
    "MaterialX::Matrix33::transformVector": {
      "brief": "Transform the given 2D direction vector.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const Vector2 &v) const"
    },
    "MaterialX::Matrix33::transformNormal": {
      "brief": "Transform the given 3D normal vector.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const Vector3 &v) const"
    },
    "MaterialX::Matrix33::createTranslation": {
      "brief": "Create a translation matrix.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const Vector2 &v)"
    },
    "MaterialX::Matrix33::createScale": {
      "brief": "Create a scale matrix.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const Vector2 &v)"
    },
    "MaterialX::Matrix33::createRotation": {
      "brief": "Create a rotation matrix.",
      "detail": "",
      "params": {
        "angle": "Angle in radians"
      },
      "returns": "",
      "args_sig": "(float angle)"
    },
    "MaterialX::Matrix33::Matrix33": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(float m00,float m01,float m02,float m10,float m11,float m12,float m20,float m21,float m22)"
    },
    "MaterialX::Matrix44::getTranspose": {
      "brief": "Return the transpose of the matrix.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::Matrix44::getDeterminant": {
      "brief": "Return the determinant of the matrix.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::Matrix44::getAdjugate": {
      "brief": "Return the adjugate of the matrix.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::Matrix44::getInverse": {
      "brief": "Return the inverse of the matrix.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::Matrix44::multiply": {
      "brief": "Return the product of this matrix and a 4D vector.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const Vector4 &v) const"
    },
    "MaterialX::Matrix44::transformPoint": {
      "brief": "Transform the given 3D point.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const Vector3 &v) const"
    },
    "MaterialX::Matrix44::transformVector": {
      "brief": "Transform the given 3D direction vector.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const Vector3 &v) const"
    },
    "MaterialX::Matrix44::transformNormal": {
      "brief": "Transform the given 3D normal vector.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const Vector3 &v) const"
    },
    "MaterialX::Matrix44::createTranslation": {
      "brief": "Create a translation matrix.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const Vector3 &v)"
    },
    "MaterialX::Matrix44::createScale": {
      "brief": "Create a scale matrix.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const Vector3 &v)"
    },
    "MaterialX::Matrix44::createRotationX": {
      "brief": "Create a rotation matrix about the X-axis.",
      "detail": "",
      "params": {
        "angle": "Angle in radians"
      },
      "returns": "",
      "args_sig": "(float angle)"
    },
    "MaterialX::Matrix44::createRotationY": {
      "brief": "Create a rotation matrix about the Y-axis.",
      "detail": "",
      "params": {
        "angle": "Angle in radians"
      },
      "returns": "",
      "args_sig": "(float angle)"
    },
    "MaterialX::Matrix44::createRotationZ": {
      "brief": "Create a rotation matrix about the Z-axis.",
      "detail": "",
      "params": {
        "angle": "Angle in radians"
      },
      "returns": "",
      "args_sig": "(float angle)"
    },
    "MaterialX::Matrix44::Matrix44": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(float m00,float m01,float m02,float m03,float m10,float m11,float m12,float m13,float m20,float m21,float m22,float m23,float m30,float m31,float m32,float m33)"
    },
    "MaterialX::MatrixN::operator==": {
      "brief": "Return true if the given matrix is identical to this one.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const M &rhs) const"
    },
    "MaterialX::MatrixN::operator!=": {
      "brief": "Return true if the given matrix differs from this one.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const M &rhs) const"
    },
    "MaterialX::MatrixN::isEquivalent": {
      "brief": "Return true if the given matrix is equivalent to this one within a given floating-point tolerance.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const M &rhs,S tolerance) const"
    },
    "MaterialX::MatrixN::operator[]": {
      "brief": "Return the const row array at the given index.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(size_t i) const"
    },
    "MaterialX::MatrixN::operator+": {
      "brief": "Unary plus of a matrix.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::MatrixN::operator+=": {
      "brief": "Component-wise addition of two matrices.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const M &rhs)"
    },
    "MaterialX::MatrixN::operator-": {
      "brief": "Unary negation of a matrix.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::MatrixN::operator-=": {
      "brief": "Component-wise subtraction of two matrices.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const M &rhs)"
    },
    "MaterialX::MatrixN::operator*": {
      "brief": "Compute the matrix product.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const M &rhs) const"
    },
    "MaterialX::MatrixN::operator*=": {
      "brief": "Compute the matrix product.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const M &rhs)"
    },
    "MaterialX::MatrixN::operator/": {
      "brief": "Divide the first matrix by the second (computed as the product of the first matrix and the inverse of the second).",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const M &rhs) const"
    },
    "MaterialX::MatrixN::operator/=": {
      "brief": "Divide the first matrix by the second (computed as the product of the first matrix and the inverse of the second).",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const M &rhs)"
    },
    "MaterialX::MatrixN::begin": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::MatrixN::end": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::MatrixN::data": {
      "brief": "Return a const pointer to the underlying data array.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::MatrixN::numRows": {
      "brief": "Return the number of rows in this matrix.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::MatrixN::numColumns": {
      "brief": "Return the number of columns in this matrix.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::MatrixN::MatrixN": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const S *begin,const S *end)"
    },
    "MaterialX::MdlShaderGenerator::MdlShaderGenerator": {
      "brief": "Constructor.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(TypeSystemPtr typeSystem)"
    },
    "MaterialX::MdlShaderGenerator::getTarget": {
      "brief": "Return a unique identifier for the target this generator is for.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const override"
    },
    "MaterialX::MdlShaderGenerator::generate": {
      "brief": "Generate a shader starting from the given element, translating the element and all dependencies upstream into shader code.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &name,ElementPtr element,GenContext &context) const override"
    },
    "MaterialX::MdlShaderGenerator::createShaderNodeImplForNodeGraph": {
      "brief": "Create the shader node implementation for a nodedef that has a NodeGraph implementation.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const NodeDef &nodedef) const override"
    },
    "MaterialX::MdlShaderGenerator::createShaderNodeImplForImplementation": {
      "brief": "Create the shader node implementation for a nodedef that has a Implementation implementation.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const NodeDef &nodedef) const override"
    },
    "MaterialX::MdlShaderGenerator::getUpstreamResult": {
      "brief": "Return the result of an upstream connection or value for an input.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const ShaderInput *input,GenContext &context) const override"
    },
    "MaterialX::MdlShaderGenerator::getMdlVersion": {
      "brief": "Get the selected MDL target language version number from the context option.",
      "detail": "If not set, the latest version supported by GenMdl is returned.",
      "params": {},
      "returns": "",
      "args_sig": "(GenContext &context) const"
    },
    "MaterialX::MdlShaderGenerator::emitMdlVersionNumber": {
      "brief": "Add the MDL file header containing the version number of the generated module.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(GenContext &context,ShaderStage &stage) const"
    },
    "MaterialX::MdlShaderGenerator::emitMdlVersionFilenameSuffix": {
      "brief": "Add the version number suffix appended to MDL modules that use versions.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(GenContext &context,ShaderStage &stage) const"
    },
    "MaterialX::MdlShaderGenerator::getMdlVersionFilenameSuffix": {
      "brief": "Get the version number suffix appended to MDL modules that use versions.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(GenContext &context) const"
    },
    "MaterialX::MdlShaderGenerator::emitTypeDefinitions": {
      "brief": "Emit type definitions for all data types that need them.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(GenContext &context,ShaderStage &stage) const override"
    },
    "MaterialX::MdlShaderGenerator::create": {
      "brief": "Creator function.",
      "detail": "If a TypeSystem is not provided it will be created internally. Optionally pass in an externally created TypeSystem here, if you want to keep type descriptions alive after the lifetime of the shader generator.",
      "params": {},
      "returns": "",
      "args_sig": "(TypeSystemPtr typeSystem=nullptr)"
    },
    "MaterialX::MdlShaderGenerator::createShader": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &name,ElementPtr element,GenContext &context) const"
    },
    "MaterialX::MdlShaderGenerator::emitShaderInputs": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const VariableBlock &inputs,ShaderStage &stage) const"
    },
    "MaterialX::MdlStructTypeSyntax::getValue": {
      "brief": "Returns a value formatted according to this type syntax.",
      "detail": "The value is constructed from the given value object.",
      "params": {},
      "returns": "",
      "args_sig": "(const Value &value,bool uniform) const override"
    },
    "MaterialX::MdlStructTypeSyntax::StructTypeSyntax": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const Syntax *parent,const string &name,const string &defaultValue,const string &uniformDefaultValue,const string &typeAlias=EMPTY_STRING,const string &typeDefinition=EMPTY_STRING,const StringVec &members=EMPTY_MEMBERS)"
    },
    "MaterialX::MdlSyntax::MdlSyntax": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(TypeSystemPtr typeSystem)"
    },
    "MaterialX::MdlSyntax::createStructSyntax": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &structTypeName,const string &defaultValue,const string &uniformDefaultValue,const string &typeAlias,const string &typeDefinition) const override"
    },
    "MaterialX::MdlSyntax::getConstantQualifier": {
      "brief": "Get the qualifier used when declaring constant variables.",
      "detail": "Derived classes must define this method.",
      "params": {},
      "returns": "",
      "args_sig": "() const override"
    },
    "MaterialX::MdlSyntax::getUniformQualifier": {
      "brief": "Get the qualifier used when declaring uniform variables.",
      "detail": "Default implementation returns empty string and derived syntax classes should override this method.",
      "params": {},
      "returns": "",
      "args_sig": "() const override"
    },
    "MaterialX::MdlSyntax::getSourceFileExtension": {
      "brief": "Return the file extension used for source code files in this language.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const override"
    },
    "MaterialX::MdlSyntax::getArrayTypeSuffix": {
      "brief": "Override to return array type suffix.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(TypeDesc type,const Value &value) const override"
    },
    "MaterialX::MdlSyntax::getArrayVariableSuffix": {
      "brief": "Override to indicate array variables have no array suffix.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(TypeDesc,const Value &) const override"
    },
    "MaterialX::MdlSyntax::getEnumeratedType": {
      "brief": "Get an type description for an enumeration based on member value.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &value) const"
    },
    "MaterialX::MdlSyntax::remapEnumeration": {
      "brief": "Given an input specification attempt to remap this to an enumeration which is accepted by the shader generator.",
      "detail": "The enumeration may be converted to a different type than the input.",
      "params": {},
      "returns": "",
      "args_sig": "(const string &value,TypeDesc type,const string &enumNames,std::pair< TypeDesc,ValuePtr > &result) const override"
    },
    "MaterialX::MdlSyntax::makeValidName": {
      "brief": "Modify the given name string to remove any invalid characters or tokens.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(string &name) const override"
    },
    "MaterialX::MdlSyntax::modifyPortName": {
      "brief": "To avoid collisions with reserved names in MDL, input and output names are prefixed.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &word) const"
    },
    "MaterialX::MdlSyntax::replaceSourceCodeMarkers": {
      "brief": "Replaces all markers in a source code string indicated by {{...}}.",
      "detail": "The replacement is defined by a callback function.",
      "params": {},
      "returns": "",
      "args_sig": "(const string &nodeName,const string &soureCode,std::function< string(const string &)> lambda) const"
    },
    "MaterialX::MdlSyntax::getMdlVersionSuffixMarker": {
      "brief": "Get the MDL language versing marker: {{MDL_VERSION_SUFFIX}}.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::MdlSyntax::create": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(TypeSystemPtr typeSystem)"
    },
    "MaterialX::Member::Member": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(ElementPtr parent,const string &name)"
    },
    "MaterialX::Member::~Member": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::Mesh::Mesh": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &name)"
    },
    "MaterialX::Mesh::~Mesh": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()=default"
    },
    "MaterialX::Mesh::getName": {
      "brief": "Return the name of this mesh.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::Mesh::setSourceUri": {
      "brief": "Set the mesh's source URI.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &sourceUri)"
    },
    "MaterialX::Mesh::hasSourceUri": {
      "brief": "Return true if this mesh has a source URI.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::Mesh::getSourceUri": {
      "brief": "Return the mesh's source URI.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::Mesh::getStream": {
      "brief": "Get a mesh stream by type and index.",
      "detail": "",
      "params": {
        "type": "Type of stream",
        "index": "Index of stream"
      },
      "returns": "Reference to a mesh stream if found",
      "args_sig": "(const string &type,unsigned int index) const"
    },
    "MaterialX::Mesh::addStream": {
      "brief": "Add a mesh stream.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(MeshStreamPtr stream)"
    },
    "MaterialX::Mesh::removeStream": {
      "brief": "Remove a mesh stream.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(MeshStreamPtr stream)"
    },
    "MaterialX::Mesh::setVertexCount": {
      "brief": "Set vertex count.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(size_t val)"
    },
    "MaterialX::Mesh::getVertexCount": {
      "brief": "Get vertex count.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::Mesh::setMinimumBounds": {
      "brief": "Set the minimum bounds for the geometry.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const Vector3 &val)"
    },
    "MaterialX::Mesh::getMinimumBounds": {
      "brief": "Return the minimum bounds for the geometry.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::Mesh::setMaximumBounds": {
      "brief": "Set the minimum bounds for the geometry.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const Vector3 &v)"
    },
    "MaterialX::Mesh::getMaximumBounds": {
      "brief": "Return the minimum bounds for the geometry.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::Mesh::setSphereCenter": {
      "brief": "Set center of the bounding sphere.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const Vector3 &val)"
    },
    "MaterialX::Mesh::getSphereCenter": {
      "brief": "Return center of the bounding sphere.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::Mesh::setSphereRadius": {
      "brief": "Set radius of the bounding sphere.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(float val)"
    },
    "MaterialX::Mesh::getSphereRadius": {
      "brief": "Return radius of the bounding sphere.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::Mesh::getPartitionCount": {
      "brief": "Return the number of mesh partitions.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::Mesh::addPartition": {
      "brief": "Add a partition.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(MeshPartitionPtr partition)"
    },
    "MaterialX::Mesh::getPartition": {
      "brief": "Return a reference to a mesh partition.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(size_t partIndex) const"
    },
    "MaterialX::Mesh::generateTextureCoordinates": {
      "brief": "Create texture coordinates from the given positions.",
      "detail": "",
      "params": {
        "positionStream": "Input position stream"
      },
      "returns": "The generated texture coordinate stream",
      "args_sig": "(MeshStreamPtr positionStream)"
    },
    "MaterialX::Mesh::generateNormals": {
      "brief": "Generate face normals from the given positions.",
      "detail": "",
      "params": {
        "positionStream": "Input position stream"
      },
      "returns": "The generated normal stream",
      "args_sig": "(MeshStreamPtr positionStream)"
    },
    "MaterialX::Mesh::generateTangents": {
      "brief": "Generate tangents from the given positions, normals, and texture coordinates.",
      "detail": "",
      "params": {
        "positionStream": "Input position stream",
        "normalStream": "Input normal stream",
        "texcoordStream": "Input texcoord stream"
      },
      "returns": "The generated tangent stream, on success; otherwise, a null pointer.",
      "args_sig": "(MeshStreamPtr positionStream,MeshStreamPtr normalStream,MeshStreamPtr texcoordStream)"
    },
    "MaterialX::Mesh::generateBitangents": {
      "brief": "Generate bitangents from the given normals and tangents.",
      "detail": "",
      "params": {
        "normalStream": "Input normal stream",
        "tangentStream": "Input tangent stream"
      },
      "returns": "The generated bitangent stream, on success; otherwise, a null pointer.",
      "args_sig": "(MeshStreamPtr normalStream,MeshStreamPtr tangentStream)"
    },
    "MaterialX::Mesh::mergePartitions": {
      "brief": "Merge all mesh partitions into one.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::Mesh::splitByUdims": {
      "brief": "Split the mesh into a single partition per UDIM.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::Mesh::create": {
      "brief": "Create a new mesh.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &name)"
    },
    "MaterialX::MeshPartition::MeshPartition": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::MeshPartition::~MeshPartition": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()=default"
    },
    "MaterialX::MeshPartition::resize": {
      "brief": "Resize data to the given number of indices.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(size_t indexCount)"
    },
    "MaterialX::MeshPartition::setName": {
      "brief": "Set the name of this partition.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &val)"
    },
    "MaterialX::MeshPartition::getName": {
      "brief": "Return the name of this partition.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::MeshPartition::addSourceName": {
      "brief": "Add a source name, representing a partition that was processed to generate this one.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &val)"
    },
    "MaterialX::MeshPartition::getSourceNames": {
      "brief": "Return the vector of source names, representing all partitions that were processed to generate this one.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::MeshPartition::getIndices": {
      "brief": "Return indexing.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::MeshPartition::getFaceCount": {
      "brief": "Return number of faces.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::MeshPartition::setFaceCount": {
      "brief": "Set face count.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(size_t val)"
    },
    "MaterialX::MeshPartition::create": {
      "brief": "Create a new mesh partition.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::MeshStream::MeshStream": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &name,const string &type,unsigned int index)"
    },
    "MaterialX::MeshStream::~MeshStream": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()=default"
    },
    "MaterialX::MeshStream::reserve": {
      "brief": "Reserve memory for a given number of elements.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(size_t elementCount)"
    },
    "MaterialX::MeshStream::resize": {
      "brief": "Resize data to an given number of elements.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(size_t elementCount)"
    },
    "MaterialX::MeshStream::getName": {
      "brief": "Get stream name.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::MeshStream::getType": {
      "brief": "Get stream attribute name.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::MeshStream::getIndex": {
      "brief": "Get stream index.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::MeshStream::getData": {
      "brief": "Return the raw float vector.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::MeshStream::getElement": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(size_t index) const"
    },
    "MaterialX::MeshStream::getStride": {
      "brief": "Get stride between elements.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::MeshStream::setStride": {
      "brief": "Set stride between elements.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(unsigned int stride)"
    },
    "MaterialX::MeshStream::getSize": {
      "brief": "Get the number of elements.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::MeshStream::transform": {
      "brief": "Transform elements by a matrix.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const Matrix44 &matrix)"
    },
    "MaterialX::MeshStream::create": {
      "brief": "Create a new mesh stream.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &name,const string &type,unsigned int index=0)"
    },
    "MaterialX::NewlineElement::NewlineElement": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(ElementPtr parent,const string &name)"
    },
    "MaterialX::NewlineElement::~NewlineElement": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::Node::setNameGlobal": {
      "brief": "Set the name string of this Node, propagating the updated name to all downstream ports.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &name)"
    },
    "MaterialX::Node::setConnectedNode": {
      "brief": "Set the node to which the given input is connected, creating a child input if needed.",
      "detail": "If the node argument is null, then any existing node connection on the input will be cleared.",
      "params": {},
      "returns": "",
      "args_sig": "(const string &inputName,ConstNodePtr node)"
    },
    "MaterialX::Node::getConnectedNode": {
      "brief": "Return the Node connected to the given input.",
      "detail": "If the given input is not present, then an empty NodePtr is returned.",
      "params": {},
      "returns": "",
      "args_sig": "(const string &inputName) const"
    },
    "MaterialX::Node::setConnectedNodeName": {
      "brief": "Set the name of the Node connected to the given input, creating a child element for the input if needed.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &inputName,const string &nodeName)"
    },
    "MaterialX::Node::getConnectedNodeName": {
      "brief": "Return the name of the Node connected to the given input.",
      "detail": "If the given input is not present, then an empty string is returned.",
      "params": {},
      "returns": "",
      "args_sig": "(const string &inputName) const"
    },
    "MaterialX::Node::getNodeDef": {
      "brief": "Return the first NodeDef that declares this node, optionally filtered by the given target name.",
      "detail": "",
      "params": {
        "target": "An optional target name, which will be used to filter the nodedefs that are considered.",
        "allowRoughMatch": "If specified, then a rough match will be allowed when an exact match is not found. An exact match requires that each node input corresponds to a nodedef input of the same name and type."
      },
      "returns": "A NodeDef for this node, or an empty shared pointer if none was found.",
      "args_sig": "(const string &target=EMPTY_STRING,bool allowRoughMatch=false) const"
    },
    "MaterialX::Node::getImplementation": {
      "brief": "Return the first implementation for this node, optionally filtered by the given target and language names.",
      "detail": "",
      "params": {
        "target": "An optional target name, which will be used to filter the implementations that are considered."
      },
      "returns": "An implementation for this node, or an empty shared pointer if none was found. Note that a node implementation may be either an Implementation element or a NodeGraph element.",
      "args_sig": "(const string &target=EMPTY_STRING) const"
    },
    "MaterialX::Node::getUpstreamEdge": {
      "brief": "Return the Edge with the given index that lies directly upstream from this element in the dataflow graph.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(size_t index=0) const override"
    },
    "MaterialX::Node::getUpstreamEdgeCount": {
      "brief": "Return the number of queryable upstream edges for this element.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const override"
    },
    "MaterialX::Node::getNodeDefOutput": {
      "brief": "Given a connecting element (Input or Output) return the NodeDef output corresponding to the output the element is connected to.",
      "detail": "This is only valid if the NodeDef has explicit outputs defined, e.g. multiple outputs or an explicitly named output. If this is not the case, nullptr is returned, which implies the node is a standard node with a single implicit output.",
      "params": {},
      "returns": "",
      "args_sig": "(ElementPtr connectingElement)"
    },
    "MaterialX::Node::getDownstreamPorts": {
      "brief": "Return a vector of all downstream ports that connect to this node, ordered by the names of the port elements.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::Node::getDeclaration": {
      "brief": "Return the first declaration of this interface, optionally filtered by the given target name.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &target=EMPTY_STRING) const override"
    },
    "MaterialX::Node::addInputFromNodeDef": {
      "brief": "Add an input based on the corresponding input for the associated node definition.",
      "detail": "If the input already exists on the node it will just be returned.",
      "params": {},
      "returns": "",
      "args_sig": "(const string &inputName)"
    },
    "MaterialX::Node::addInputsFromNodeDef": {
      "brief": "Add inputs based on the corresponding associated node definition.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::Node::validate": {
      "brief": "Validate that the given element tree, including all descendants, is consistent with the MaterialX specification.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(string *message=nullptr) const override"
    },
    "MaterialX::Node::Node": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(ElementPtr parent,const string &name)"
    },
    "MaterialX::Node::~Node": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::NodeDef::setNodeString": {
      "brief": "Set the node string of the NodeDef.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &node)"
    },
    "MaterialX::NodeDef::hasNodeString": {
      "brief": "Return true if the given NodeDef has a node string.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::NodeDef::getNodeString": {
      "brief": "Return the node string of the NodeDef.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::NodeDef::getType": {
      "brief": "Return the element's output type.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const override"
    },
    "MaterialX::NodeDef::setNodeGroup": {
      "brief": "Set the node group of the NodeDef.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &category)"
    },
    "MaterialX::NodeDef::hasNodeGroup": {
      "brief": "Return true if the given NodeDef has a node group.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::NodeDef::getNodeGroup": {
      "brief": "Return the node group of the NodeDef.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::NodeDef::getImplementation": {
      "brief": "Return the first implementation for this nodedef, optionally filtered by the given target name.",
      "detail": "",
      "params": {
        "target": "An optional target name, which will be used to filter the implementations that are considered."
      },
      "returns": "An implementation for this nodedef, or an empty shared pointer if none was found. Note that a node implementation may be either an Implementation element or a NodeGraph element.",
      "args_sig": "(const string &target=EMPTY_STRING) const"
    },
    "MaterialX::NodeDef::getInputHints": {
      "brief": "Return list of input hint pairs of the form { input_name, hint_string }.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::NodeDef::validate": {
      "brief": "Validate that the given element tree, including all descendants, is consistent with the MaterialX specification.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(string *message=nullptr) const override"
    },
    "MaterialX::NodeDef::isVersionCompatible": {
      "brief": "Return true if the given version string is compatible with this NodeDef.",
      "detail": "This may be used to test, for example, whether a NodeDef and Node may be used together.",
      "params": {},
      "returns": "",
      "args_sig": "(const string &version) const"
    },
    "MaterialX::NodeDef::getDeclaration": {
      "brief": "Return the first declaration of this interface, optionally filtered by the given target name.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &target=EMPTY_STRING) const override"
    },
    "MaterialX::NodeDef::NodeDef": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(ElementPtr parent,const string &name)"
    },
    "MaterialX::NodeDef::~NodeDef": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::NodeGraph::setNameGlobal": {
      "brief": "Set the name string of this NodeGraph, propagating the updated name to all downstream ports.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &name)"
    },
    "MaterialX::NodeGraph::getMaterialOutputs": {
      "brief": "Return all material-type outputs of the nodegraph.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::NodeGraph::setNodeDef": {
      "brief": "Set the NodeDef element referenced by this NodeGraph.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(ConstNodeDefPtr nodeDef)"
    },
    "MaterialX::NodeGraph::getNodeDef": {
      "brief": "Return the NodeDef element referenced by this NodeGraph.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::NodeGraph::getImplementation": {
      "brief": "Return the first implementation for this node graph.",
      "detail": "",
      "params": {},
      "returns": "An implementation for this node, or an empty shared pointer if none was found.",
      "args_sig": "() const"
    },
    "MaterialX::NodeGraph::getDownstreamPorts": {
      "brief": "Return a vector of all downstream ports that connect to this graph, ordered by the names of the port elements.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::NodeGraph::getDeclaration": {
      "brief": "Return the first declaration of this interface, optionally filtered by the given target name.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &target=EMPTY_STRING) const override"
    },
    "MaterialX::NodeGraph::addInterfaceName": {
      "brief": "Add an interface name to an existing NodeDef associated with this NodeGraph.",
      "detail": "",
      "params": {
        "inputPath": "Path to an input descendant of this graph.",
        "interfaceName": "The new interface name."
      },
      "returns": "Interface input.",
      "args_sig": "(const string &inputPath,const string &interfaceName)"
    },
    "MaterialX::NodeGraph::removeInterfaceName": {
      "brief": "Remove an interface name from an existing NodeDef associated with this NodeGraph.",
      "detail": "",
      "params": {
        "inputPath": "Path to an input descendant of this graph."
      },
      "returns": "",
      "args_sig": "(const string &inputPath)"
    },
    "MaterialX::NodeGraph::modifyInterfaceName": {
      "brief": "Modify the interface name on an existing NodeDef associated with this NodeGraph.",
      "detail": "",
      "params": {
        "inputPath": "Path to an input descendant of this graph.",
        "interfaceName": "The new interface name."
      },
      "returns": "",
      "args_sig": "(const string &inputPath,const string &interfaceName)"
    },
    "MaterialX::NodeGraph::validate": {
      "brief": "Validate that the given element tree, including all descendants, is consistent with the MaterialX specification.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(string *message=nullptr) const override"
    },
    "MaterialX::NodeGraph::NodeGraph": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(ElementPtr parent,const string &name)"
    },
    "MaterialX::NodeGraph::~NodeGraph": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::NopNode::create": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::OslRenderer::initialize": {
      "brief": "Internal initialization required for program validation and rendering.",
      "detail": "An exception is thrown on failure. The exception will contain a list of initialization errors.",
      "params": {},
      "returns": "",
      "args_sig": "(RenderContextHandle renderContextHandle=nullptr) override"
    },
    "MaterialX::OslRenderer::createProgram": {
      "brief": "Create OSL program based on shader stage source code.",
      "detail": "",
      "params": {
        "stages": "Map of name and source code for the shader stages."
      },
      "returns": "",
      "args_sig": "(const StageMap &stages) override"
    },
    "MaterialX::OslRenderer::validateInputs": {
      "brief": "Validate inputs for the compiled OSL program.",
      "detail": "Note: Currently no validation has been implemented.",
      "params": {},
      "returns": "",
      "args_sig": "() override"
    },
    "MaterialX::OslRenderer::setSize": {
      "brief": "Set the size for rendered image.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(unsigned int width,unsigned int height) override"
    },
    "MaterialX::OslRenderer::render": {
      "brief": "Render OSL program to disk.",
      "detail": "This is done by using either \"testshade\" or \"testrender\". Currently only \"testshade\" is supported.\n\nUsage of both executables requires compiled source (.oso) files as input. A shader output must be set before running this test via the setOslOutputName() method to ensure that the appropriate .oso files can be located.",
      "params": {},
      "returns": "",
      "args_sig": "() override"
    },
    "MaterialX::OslRenderer::captureImage": {
      "brief": "Capture the current rendered output as an image.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(ImagePtr image=nullptr) override"
    },
    "MaterialX::OslRenderer::setOslCompilerExecutable": {
      "brief": "Set the path to the OSL executable.",
      "detail": "",
      "params": {
        "executableFilePath": "Path to OSL compiler executable"
      },
      "returns": "",
      "args_sig": "(const FilePath &executableFilePath)"
    },
    "MaterialX::OslRenderer::setOslIncludePath": {
      "brief": "Set the search locations for OSL include files.",
      "detail": "",
      "params": {
        "dirPath": "Include path(s) for the OSL compiler. This should include the path to stdosl.h."
      },
      "returns": "",
      "args_sig": "(const FileSearchPath &dirPath)"
    },
    "MaterialX::OslRenderer::setOslOutputFilePath": {
      "brief": "Set the location where compiled OSL files will reside.",
      "detail": "",
      "params": {
        "dirPath": "Path to output location"
      },
      "returns": "",
      "args_sig": "(const FilePath &dirPath)"
    },
    "MaterialX::OslRenderer::setShaderParameterOverrides": {
      "brief": "Set shader parameter strings to be added to the scene XML file.",
      "detail": "These strings will set parameter overrides for the shader.",
      "params": {},
      "returns": "",
      "args_sig": "(const StringVec &parameterOverrides)"
    },
    "MaterialX::OslRenderer::setEnvShaderParameterOverrides": {
      "brief": "Set shader parameter strings to be added to the scene XML file.",
      "detail": "These strings will set parameter overrides for the shader.",
      "params": {},
      "returns": "",
      "args_sig": "(const StringVec &parameterOverrides)"
    },
    "MaterialX::OslRenderer::setOslShaderOutput": {
      "brief": "Set the OSL shader output.",
      "detail": "",
      "params": {
        "outputName": "Name of shader output",
        "outputType": "The MaterialX type of the output"
      },
      "returns": "",
      "args_sig": "(const string &outputName,const string &outputType)"
    },
    "MaterialX::OslRenderer::setOslTestShadeExecutable": {
      "brief": "Set the path to the OSL shading tester.",
      "detail": "",
      "params": {
        "executableFilePath": "Path to OSL \"testshade\" executable"
      },
      "returns": "",
      "args_sig": "(const FilePath &executableFilePath)"
    },
    "MaterialX::OslRenderer::setOslTestRenderExecutable": {
      "brief": "Set the path to the OSL rendering tester.",
      "detail": "",
      "params": {
        "executableFilePath": "Path to OSL \"testrender\" executable"
      },
      "returns": "",
      "args_sig": "(const FilePath &executableFilePath)"
    },
    "MaterialX::OslRenderer::setOslTestRenderSceneTemplateFile": {
      "brief": "Set the XML scene file to use for testrender.",
      "detail": "This is a template file with the following tokens for replacement: shader% : which will be replaced with the name of the shader to use shader_output% : which will be replace with the name of the shader output to use templateFilePath Scene file name",
      "params": {
        "templateFilePath": "Scene file name"
      },
      "returns": "",
      "args_sig": "(const FilePath &templateFilePath)"
    },
    "MaterialX::OslRenderer::setOslShaderName": {
      "brief": "Set the name of the shader to be used for the input XML scene file.",
      "detail": "",
      "params": {
        "shaderName": "Name of shader"
      },
      "returns": "",
      "args_sig": "(const string &shaderName)"
    },
    "MaterialX::OslRenderer::setOslUtilityOSOPath": {
      "brief": "Set the search path for dependent shaders (.oso files) which are used when rendering with testrender.",
      "detail": "",
      "params": {
        "dirPath": "Path to location containing .oso files."
      },
      "returns": "",
      "args_sig": "(const FilePath &dirPath)"
    },
    "MaterialX::OslRenderer::useTestRender": {
      "brief": "Used to toggle to either use testrender or testshade during render validation By default testshade is used.",
      "detail": "",
      "params": {
        "useTestRender": "Indicate whether to use testrender."
      },
      "returns": "",
      "args_sig": "(bool useTestRender)"
    },
    "MaterialX::OslRenderer::setRaysPerPixelLit": {
      "brief": "Set the number of rays per pixel to be used for lit surfaces.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(int rays)"
    },
    "MaterialX::OslRenderer::setRaysPerPixelUnlit": {
      "brief": "Set the number of rays per pixel to be used for unlit surfaces.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(int rays)"
    },
    "MaterialX::OslRenderer::compileOSL": {
      "brief": "Compile OSL code stored in a file.",
      "detail": "",
      "params": {
        "oslFilePath": "OSL file path."
      },
      "returns": "",
      "args_sig": "(const FilePath &oslFilePath)"
    },
    "MaterialX::OslRenderer::create": {
      "brief": "Create an OSL renderer instance.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(unsigned int width=512,unsigned int height=512,Image::BaseType baseType=Image::BaseType::UINT8)"
    },
    "MaterialX::OslRenderer::~OslRenderer": {
      "brief": "Destructor.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::OslRenderer::shadeOSL": {
      "brief": "Shade using OSO input file.",
      "detail": "",
      "params": {
        "dirPath": "Path to location containing input .oso file.",
        "shaderName": "Name of OSL shader. A corresponding .oso file is assumed to exist in the output path folder.",
        "outputName": "Name of OSL shader output to use."
      },
      "returns": "",
      "args_sig": "(const FilePath &dirPath,const string &shaderName,const string &outputName)"
    },
    "MaterialX::OslRenderer::renderOSL": {
      "brief": "Render using OSO input file.",
      "detail": "",
      "params": {
        "dirPath": "Path to location containing input .oso file.",
        "shaderName": "Name of OSL shader. A corresponding .oso file is assumed to exist in the output path folder.",
        "outputName": "Name of OSL shader output to use."
      },
      "returns": "",
      "args_sig": "(const FilePath &dirPath,const string &shaderName,const string &outputName)"
    },
    "MaterialX::OslRenderer::OslRenderer": {
      "brief": "Constructor.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(unsigned int width,unsigned int height,Image::BaseType baseType)"
    },
    "MaterialX::OslShaderGenerator::OslShaderGenerator": {
      "brief": "Constructor.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(TypeSystemPtr typeSystem)"
    },
    "MaterialX::OslShaderGenerator::getTarget": {
      "brief": "Return a unique identifier for the target this generator is for.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const override"
    },
    "MaterialX::OslShaderGenerator::generate": {
      "brief": "Generate a shader starting from the given element, translating the element and all dependencies upstream into shader code.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &name,ElementPtr element,GenContext &context) const override"
    },
    "MaterialX::OslShaderGenerator::emitAllDependentFunctionCalls": {
      "brief": "Add all function calls for a node, and all upstream nodes.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const ShaderNode &node,GenContext &context,ShaderStage &stage) const"
    },
    "MaterialX::OslShaderGenerator::registerShaderMetadata": {
      "brief": "Register metadata that should be exported to the generated shaders.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const DocumentPtr &doc,GenContext &context) const override"
    },
    "MaterialX::OslShaderGenerator::create": {
      "brief": "Creator function.",
      "detail": "If a TypeSystem is not provided it will be created internally. Optionally pass in an externally created TypeSystem here, if you want to keep type descriptions alive after the lifetime of the shader generator.",
      "params": {},
      "returns": "",
      "args_sig": "(TypeSystemPtr typeSystem=nullptr)"
    },
    "MaterialX::OslShaderGenerator::createShader": {
      "brief": "Create and initialize a new OSL shader for shader generation.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &name,ElementPtr element,GenContext &context) const"
    },
    "MaterialX::OslShaderGenerator::emitLibraryIncludes": {
      "brief": "Emit include headers needed by the generated shader code.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(ShaderStage &stage,GenContext &context) const"
    },
    "MaterialX::OslShaderGenerator::emitShaderInputs": {
      "brief": "Emit a block of shader inputs.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const VariableBlock &inputs,ShaderStage &stage) const"
    },
    "MaterialX::OslShaderGenerator::emitShaderOutputs": {
      "brief": "Emit a block of shader outputs.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const VariableBlock &inputs,ShaderStage &stage) const"
    },
    "MaterialX::OslShaderGenerator::emitMetadata": {
      "brief": "Emit metadata for a shader parameter.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const ShaderPort *port,ShaderStage &stage) const"
    },
    "MaterialX::OslSyntax::OslSyntax": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(TypeSystemPtr typeSystem)"
    },
    "MaterialX::OslSyntax::getOutputQualifier": {
      "brief": "Returns a type qualifier to be used when declaring types for output variables.",
      "detail": "Default implementation returns empty string and derived syntax classes should override this method.",
      "params": {},
      "returns": "",
      "args_sig": "() const override"
    },
    "MaterialX::OslSyntax::getConstantQualifier": {
      "brief": "Get the qualifier used when declaring constant variables.",
      "detail": "Derived classes must define this method.",
      "params": {},
      "returns": "",
      "args_sig": "() const override"
    },
    "MaterialX::OslSyntax::getSourceFileExtension": {
      "brief": "Return the file extension used for source code files in this language.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const override"
    },
    "MaterialX::OslSyntax::create": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(TypeSystemPtr typeSystem)"
    },
    "MaterialX::Output::getUpstreamEdge": {
      "brief": "Return the Edge with the given index that lies directly upstream from this element in the dataflow graph.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(size_t index=0) const override"
    },
    "MaterialX::Output::getUpstreamEdgeCount": {
      "brief": "Return the number of queryable upstream edges for this element.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const override"
    },
    "MaterialX::Output::hasUpstreamCycle": {
      "brief": "Return true if a cycle exists in any upstream path from this element.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::Output::validate": {
      "brief": "Validate that the given element tree, including all descendants, is consistent with the MaterialX specification.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(string *message=nullptr) const override"
    },
    "MaterialX::Output::Output": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(ElementPtr parent,const string &name)"
    },
    "MaterialX::Output::~Output": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::PortElement::setNodeName": {
      "brief": "Set the node name string of this element, creating a connection to the Node with the given name within the same NodeGraph.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &node)"
    },
    "MaterialX::PortElement::hasNodeName": {
      "brief": "Return true if this element has a node name string.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::PortElement::getNodeName": {
      "brief": "Return the node name string of this element.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::PortElement::setNodeGraphString": {
      "brief": "Set the node graph string of this element.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &node)"
    },
    "MaterialX::PortElement::hasNodeGraphString": {
      "brief": "Return true if this element has a node graph string.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::PortElement::getNodeGraphString": {
      "brief": "Return the node graph string of this element.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::PortElement::setOutputString": {
      "brief": "Set the output string of this element.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &output)"
    },
    "MaterialX::PortElement::hasOutputString": {
      "brief": "Return true if this element has an output string.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::PortElement::setConnectedOutput": {
      "brief": "Set the output to which this input is connected.",
      "detail": "If the output argument is null, then any existing output connection will be cleared.",
      "params": {},
      "returns": "",
      "args_sig": "(ConstOutputPtr output)"
    },
    "MaterialX::PortElement::getConnectedOutput": {
      "brief": "Return the output, if any, to which this input is connected.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::PortElement::getOutputString": {
      "brief": "Return the output string of this element.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::PortElement::setConnectedNode": {
      "brief": "Set the node to which this element is connected.",
      "detail": "The given node must belong to the same node graph. If the node argument is null, then any existing node connection will be cleared.",
      "params": {},
      "returns": "",
      "args_sig": "(ConstNodePtr node)"
    },
    "MaterialX::PortElement::getConnectedNode": {
      "brief": "Return the node, if any, to which this element is connected.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::PortElement::validate": {
      "brief": "Validate that the given element tree, including all descendants, is consistent with the MaterialX specification.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(string *message=nullptr) const override"
    },
    "MaterialX::PortElement::PortElement": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(ElementPtr parent,const string &category,const string &name)"
    },
    "MaterialX::PortElement::~PortElement": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::Property::Property": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(ElementPtr parent,const string &name)"
    },
    "MaterialX::Property::~Property": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::PropertyAssign::setProperty": {
      "brief": "Set the property string of this element.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &property)"
    },
    "MaterialX::PropertyAssign::hasProperty": {
      "brief": "Return true if this element has a property string.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::PropertyAssign::getProperty": {
      "brief": "Return the property string of this element.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::PropertyAssign::setGeom": {
      "brief": "Set the geometry string of this element.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &geom)"
    },
    "MaterialX::PropertyAssign::hasGeom": {
      "brief": "Return true if this element has a geometry string.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::PropertyAssign::getGeom": {
      "brief": "Return the geometry string of this element.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::PropertyAssign::setCollectionString": {
      "brief": "Set the collection string of this element.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &collection)"
    },
    "MaterialX::PropertyAssign::hasCollectionString": {
      "brief": "Return true if this element has a collection string.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::PropertyAssign::getCollectionString": {
      "brief": "Return the collection string of this element.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::PropertyAssign::setCollection": {
      "brief": "Assign a Collection to this element.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(ConstCollectionPtr collection)"
    },
    "MaterialX::PropertyAssign::getCollection": {
      "brief": "Return the Collection that is assigned to this element.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::PropertyAssign::PropertyAssign": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(ElementPtr parent,const string &name)"
    },
    "MaterialX::PropertyAssign::~PropertyAssign": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::PropertySet::addProperty": {
      "brief": "Add a Property to the set.",
      "detail": "",
      "params": {
        "name": "The name of the new Property. If no name is specified, then a unique name will automatically be generated."
      },
      "returns": "A shared pointer to the new Property.",
      "args_sig": "(const string &name)"
    },
    "MaterialX::PropertySet::getProperty": {
      "brief": "Return the Property, if any, with the given name.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &name) const"
    },
    "MaterialX::PropertySet::getProperties": {
      "brief": "Return a vector of all Property elements in the set.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::PropertySet::removeProperty": {
      "brief": "Remove the Property with the given name, if present.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &name)"
    },
    "MaterialX::PropertySet::setPropertyValue": {
      "brief": "Set the typed value of a property by its name, creating a child element to hold the property if needed.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &name,const T &value,const string &type=EMPTY_STRING)"
    },
    "MaterialX::PropertySet::getPropertyValue": {
      "brief": "Return the typed value of a property by its name.",
      "detail": "",
      "params": {
        "name": "The name of the property to be evaluated."
      },
      "returns": "If the given property is found, then a shared pointer to its value is returned; otherwise, an empty shared pointer is returned.",
      "args_sig": "(const string &name) const"
    },
    "MaterialX::PropertySet::PropertySet": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(ElementPtr parent,const string &name)"
    },
    "MaterialX::PropertySet::~PropertySet": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::PropertySetAssign::setPropertySetString": {
      "brief": "Set the property set string of this element.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &propertySet)"
    },
    "MaterialX::PropertySetAssign::hasPropertySetString": {
      "brief": "Return true if this element has a property set string.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::PropertySetAssign::getPropertySetString": {
      "brief": "Return the property set string of this element.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::PropertySetAssign::setPropertySet": {
      "brief": "Assign a property set to this element.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(ConstPropertySetPtr propertySet)"
    },
    "MaterialX::PropertySetAssign::getPropertySet": {
      "brief": "Return the property set that is assigned to this element.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::PropertySetAssign::PropertySetAssign": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(ElementPtr parent,const string &name)"
    },
    "MaterialX::PropertySetAssign::~PropertySetAssign": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::Quaternion::Quaternion": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(float x,float y,float z,float w)"
    },
    "MaterialX::Quaternion::operator*": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const Quaternion &q) const"
    },
    "MaterialX::Quaternion::getNormalized": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::Quaternion::toMatrix": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::Quaternion::createFromAxisAngle": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const Vector3 &v,float a)"
    },
    "MaterialX::ScalarTypeSyntax::ScalarTypeSyntax": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const Syntax *parent,const string &name,const string &defaultValue,const string &uniformDefaultValue,const string &typeAlias=EMPTY_STRING,const string &typeDefinition=EMPTY_STRING)"
    },
    "MaterialX::ScalarTypeSyntax::getValue": {
      "brief": "Returns a value formatted according to this type syntax.",
      "detail": "The value is constructed from the given value object.",
      "params": {},
      "returns": "",
      "args_sig": "(const Value &value,bool uniform) const override"
    },
    "MaterialX::ScopedFloatFormatting::ScopedFloatFormatting": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(Value::FloatFormat format,int precision=-1)"
    },
    "MaterialX::ScopedFloatFormatting::~ScopedFloatFormatting": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::ScopedSetVariableName::ScopedSetVariableName": {
      "brief": "Constructor for setting a new variable name for a port.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &name,ShaderPort *port)"
    },
    "MaterialX::ScopedSetVariableName::~ScopedSetVariableName": {
      "brief": "Destructor restoring the original variable name.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::ScopedTimer::ScopedTimer": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(double *externalCounter=nullptr)"
    },
    "MaterialX::ScopedTimer::~ScopedTimer": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::ScopedTimer::elapsedTime": {
      "brief": "Return the elapsed time in seconds since our start time.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::ScopedTimer::startTimer": {
      "brief": "Activate the timer, and set our start time to the current moment.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::ScopedTimer::endTimer": {
      "brief": "Deactivate the timer, and add the elapsed time to our external counter.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::Shader::Shader": {
      "brief": "Constructor.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &name,ShaderGraphPtr graph)"
    },
    "MaterialX::Shader::~Shader": {
      "brief": "Destructor.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::Shader::getName": {
      "brief": "Return the shader name.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::Shader::numStages": {
      "brief": "Return the number of shader stages for this shader.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::Shader::getStage": {
      "brief": "Return a stage by name.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &name) const"
    },
    "MaterialX::Shader::hasStage": {
      "brief": "Return if stage exists.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &name)"
    },
    "MaterialX::Shader::hasAttribute": {
      "brief": "Return true if the shader has a given named attribute.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &attrib) const"
    },
    "MaterialX::Shader::getAttribute": {
      "brief": "Return the value for a named attribute, or nullptr if no such attribute is found.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &attrib) const"
    },
    "MaterialX::Shader::setAttribute": {
      "brief": "Set a flag attribute on the shader.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &attrib)"
    },
    "MaterialX::Shader::getGraph": {
      "brief": "Return the shader graph.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::Shader::hasClassification": {
      "brief": "Return true if this shader matches the given classification.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(unsigned int c) const"
    },
    "MaterialX::Shader::setSourceCode": {
      "brief": "Set the shader source code for a given shader stage.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &code,const string &stage=Stage::PIXEL)"
    },
    "MaterialX::Shader::getSourceCode": {
      "brief": "Return the shader source code for a given shader stage.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &stage=Stage::PIXEL) const"
    },
    "MaterialX::Shader::createStage": {
      "brief": "Create a new stage in the shader.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &name,ConstSyntaxPtr syntax)"
    },
    "MaterialX::ShaderGenerator::~ShaderGenerator": {
      "brief": "Destructor.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::ShaderGenerator::getTarget": {
      "brief": "Return the name of the target this generator is for.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::ShaderGenerator::generate": {
      "brief": "Generate a shader starting from the given element, translating the element and all dependencies upstream into shader code.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &,ElementPtr,GenContext &) const"
    },
    "MaterialX::ShaderGenerator::emitScopeBegin": {
      "brief": "Start a new scope using the given bracket type.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(ShaderStage &stage,Syntax::Punctuation punc=Syntax::CURLY_BRACKETS) const"
    },
    "MaterialX::ShaderGenerator::emitScopeEnd": {
      "brief": "End the current scope.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(ShaderStage &stage,bool semicolon=false,bool newline=true) const"
    },
    "MaterialX::ShaderGenerator::emitLineBegin": {
      "brief": "Start a new line.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(ShaderStage &stage) const"
    },
    "MaterialX::ShaderGenerator::emitLineEnd": {
      "brief": "End the current line.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(ShaderStage &stage,bool semicolon=true) const"
    },
    "MaterialX::ShaderGenerator::emitLineBreak": {
      "brief": "Add a line break.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(ShaderStage &stage) const"
    },
    "MaterialX::ShaderGenerator::emitString": {
      "brief": "Add a string.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &str,ShaderStage &stage) const"
    },
    "MaterialX::ShaderGenerator::emitLine": {
      "brief": "Add a single line of code, optionally appending a semicolon.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &str,ShaderStage &stage,bool semicolon=true) const"
    },
    "MaterialX::ShaderGenerator::emitComment": {
      "brief": "Add a single line code comment.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &str,ShaderStage &stage) const"
    },
    "MaterialX::ShaderGenerator::emitBlock": {
      "brief": "Add a block of code.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &str,const FilePath &sourceFilename,GenContext &context,ShaderStage &stage) const"
    },
    "MaterialX::ShaderGenerator::emitLibraryInclude": {
      "brief": "Add the contents of a standard library include file if not already present.",
      "detail": "The library file prefix of the given context, if any, will be prepended to the given filename.",
      "params": {},
      "returns": "",
      "args_sig": "(const FilePath &filename,GenContext &context,ShaderStage &stage) const"
    },
    "MaterialX::ShaderGenerator::emitValue": {
      "brief": "Add a value.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const T &value,ShaderStage &stage) const"
    },
    "MaterialX::ShaderGenerator::emitFunctionDefinition": {
      "brief": "Add the function definition for a single node.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const ShaderNode &node,GenContext &context,ShaderStage &stage) const"
    },
    "MaterialX::ShaderGenerator::emitFunctionDefinitionParameter": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const ShaderPort *shaderPort,bool isOutput,GenContext &context,ShaderStage &stage) const"
    },
    "MaterialX::ShaderGenerator::emitFunctionDefinitions": {
      "brief": "Add all function definitions for a graph.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const ShaderGraph &graph,GenContext &context,ShaderStage &stage) const"
    },
    "MaterialX::ShaderGenerator::emitFunctionCall": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const ShaderNode &node,GenContext &context,ShaderStage &stage,bool checkScope) const"
    },
    "MaterialX::ShaderGenerator::emitFunctionCalls": {
      "brief": "Add all function calls for a graph.",
      "detail": "If a classification mask is given only functions for nodes matching this classification will be emitted.",
      "params": {},
      "returns": "",
      "args_sig": "(const ShaderGraph &graph,GenContext &context,ShaderStage &stage,uint32_t classification=0u) const"
    },
    "MaterialX::ShaderGenerator::emitDependentFunctionCalls": {
      "brief": "Add function calls for nodes connected directly upstream from the given node.",
      "detail": "If a classification mask is given only functions for nodes matching this classification will be emitted.",
      "params": {},
      "returns": "",
      "args_sig": "(const ShaderNode &node,GenContext &context,ShaderStage &stage,uint32_t classification=0u) const"
    },
    "MaterialX::ShaderGenerator::emitFunctionBodyBegin": {
      "brief": "Emit code for starting a new function body.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const ShaderNode &node,GenContext &context,ShaderStage &stage,Syntax::Punctuation punc=Syntax::CURLY_BRACKETS) const"
    },
    "MaterialX::ShaderGenerator::emitFunctionBodyEnd": {
      "brief": "Emit code for ending a function body.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const ShaderNode &node,GenContext &context,ShaderStage &stage) const"
    },
    "MaterialX::ShaderGenerator::emitTypeDefinitions": {
      "brief": "Emit type definitions for all data types that needs it.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(GenContext &context,ShaderStage &stage) const"
    },
    "MaterialX::ShaderGenerator::emitInput": {
      "brief": "Emit the connected variable name for an input, or constant value if the port is not connected.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const ShaderInput *input,GenContext &context,ShaderStage &stage) const"
    },
    "MaterialX::ShaderGenerator::emitOutput": {
      "brief": "Emit the output variable name for an output, optionally including it's type and default value assignment.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const ShaderOutput *output,bool includeType,bool assignValue,GenContext &context,ShaderStage &stage) const"
    },
    "MaterialX::ShaderGenerator::emitVariableDeclarations": {
      "brief": "Emit definitions for all shader variables in a block.",
      "detail": "",
      "params": {
        "block": "Block to emit.",
        "qualifier": "Optional qualifier to add before the variable declaration.",
        "separator": "Separator to use between the declarations.",
        "context": "Context for generation.",
        "stage": "The stage to emit code into.",
        "assignValue": "If true the variables are initialized with their value."
      },
      "returns": "",
      "args_sig": "(const VariableBlock &block,const string &qualifier,const string &separator,GenContext &context,ShaderStage &stage,bool assignValue=true) const"
    },
    "MaterialX::ShaderGenerator::emitVariableDeclaration": {
      "brief": "Emit definition of a single shader variable.",
      "detail": "",
      "params": {
        "variable": "Shader port representing the variable.",
        "qualifier": "Optional qualifier to add before the variable declaration.",
        "context": "Context for generation.",
        "stage": "The stage to emit code into.",
        "assignValue": "If true the variable is initialized with its value."
      },
      "returns": "",
      "args_sig": "(const ShaderPort *variable,const string &qualifier,GenContext &context,ShaderStage &stage,bool assignValue=true) const"
    },
    "MaterialX::ShaderGenerator::nodeNeedsClosureData": {
      "brief": "Return true if the node needs the additional ClosureData added.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const ShaderNode &) const"
    },
    "MaterialX::ShaderGenerator::emitClosureDataArg": {
      "brief": "Emit the closure data argument if required Note this is an affordance for HwShaderGenerator.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const ShaderNode &,GenContext &,ShaderStage &) const"
    },
    "MaterialX::ShaderGenerator::emitClosureDataParameter": {
      "brief": "Emit the closure data parameter if required.",
      "detail": "Note this is an affordance for HwShaderGenerator",
      "params": {},
      "returns": "",
      "args_sig": "(const ShaderNode &,GenContext &,ShaderStage &) const"
    },
    "MaterialX::ShaderGenerator::getUpstreamResult": {
      "brief": "Return the result of an upstream connection or value for an input.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const ShaderInput *input,GenContext &context) const"
    },
    "MaterialX::ShaderGenerator::getSyntax": {
      "brief": "Return the syntax object for the language used by the code generator.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::ShaderGenerator::registerImplementation": {
      "brief": "Register a shader node implementation for a given set of implementation element names.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const StringVec &nameVec,CreatorFunction< ShaderNodeImpl > creator)"
    },
    "MaterialX::ShaderGenerator::implementationRegistered": {
      "brief": "Determine if a shader node implementation has been registered for a given implementation element name.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &name) const"
    },
    "MaterialX::ShaderGenerator::createShaderNodeImplForNodeGraph": {
      "brief": "Create the shader node implementation for a nodedef that has a NodeGraph implementation.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const NodeDef &nodedef) const"
    },
    "MaterialX::ShaderGenerator::createShaderNodeImplForImplementation": {
      "brief": "Create the shader node implementation for a nodedef that has a Implementation implementation.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const NodeDef &nodedef) const"
    },
    "MaterialX::ShaderGenerator::getImplementation": {
      "brief": "Return a registered shader node implementation for the given nodedef.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const NodeDef &nodedef,GenContext &context) const"
    },
    "MaterialX::ShaderGenerator::setColorManagementSystem": {
      "brief": "Sets the color management system.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(ColorManagementSystemPtr colorManagementSystem)"
    },
    "MaterialX::ShaderGenerator::getColorManagementSystem": {
      "brief": "Returns the color management system.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::ShaderGenerator::setUnitSystem": {
      "brief": "Sets the unit system.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(UnitSystemPtr unitSystem)"
    },
    "MaterialX::ShaderGenerator::getUnitSystem": {
      "brief": "Returns the unit system.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::ShaderGenerator::getTypeSystem": {
      "brief": "Returns the type system.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::ShaderGenerator::getTokenSubstitutions": {
      "brief": "Return the map of token substitutions used by the generator.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::ShaderGenerator::registerTypeDefs": {
      "brief": "Register type definitions from the document.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const DocumentPtr &doc)"
    },
    "MaterialX::ShaderGenerator::registerShaderMetadata": {
      "brief": "Register metadata that should be exported to the generated shaders.",
      "detail": "Supported metadata includes standard UI attributes like \"uiname\", \"uifolder\", \"uimin\", \"uimax\", etc. But it is also extendable by defining custom attributes using AttributeDefs. Any AttributeDef in the given document with exportable=\"true\" will be exported as shader metadata when found on nodes during shader generation. Derived shader generators may override this method to change the registration. Applications must explicitly call this method before shader generation to enable export of metadata.",
      "params": {},
      "returns": "",
      "args_sig": "(const DocumentPtr &doc,GenContext &context) const"
    },
    "MaterialX::ShaderGenerator::getLightDataTypevarString": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::ShaderGenerator::ShaderGenerator": {
      "brief": "Protected constructor.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(TypeSystemPtr typeSystem,SyntaxPtr syntax)"
    },
    "MaterialX::ShaderGenerator::createStage": {
      "brief": "Create a new stage in a shader.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &name,Shader &shader) const"
    },
    "MaterialX::ShaderGenerator::setFunctionName": {
      "brief": "Set function name for a stage.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &functionName,ShaderStage &stage) const"
    },
    "MaterialX::ShaderGenerator::replaceTokens": {
      "brief": "Replace tokens with identifiers according to the given substitutions map.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const StringMap &substitutions,ShaderStage &stage) const"
    },
    "MaterialX::ShaderGenerator::createVariables": {
      "brief": "Create shader variables (e.g.",
      "detail": "uniforms, inputs and outputs) for nodes that require input data from the application.",
      "params": {},
      "returns": "",
      "args_sig": "(ShaderGraphPtr graph,GenContext &context,Shader &shader) const"
    },
    "MaterialX::ShaderGraph::ShaderGraph": {
      "brief": "Constructor.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const ShaderGraph *parent,const string &name,ConstDocumentPtr document)"
    },
    "MaterialX::ShaderGraph::~ShaderGraph": {
      "brief": "Destructor.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::ShaderGraph::isAGraph": {
      "brief": "Return true if this node is a graph.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const override"
    },
    "MaterialX::ShaderGraph::getNode": {
      "brief": "Get an internal node by name.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &name) const"
    },
    "MaterialX::ShaderGraph::getNodes": {
      "brief": "Get a vector of all nodes in order.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::ShaderGraph::numInputSockets": {
      "brief": "Get number of input sockets.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::ShaderGraph::numOutputSockets": {
      "brief": "Get number of output sockets.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::ShaderGraph::getInputSocket": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &name) const"
    },
    "MaterialX::ShaderGraph::getOutputSocket": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &name) const"
    },
    "MaterialX::ShaderGraph::getInputSockets": {
      "brief": "Get vector of sockets.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::ShaderGraph::getOutputSockets": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::ShaderGraph::applyInputTransforms": {
      "brief": "Apply color and unit transforms to each input of a node.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(ConstNodePtr node,ShaderNode *shaderNode,GenContext &context)"
    },
    "MaterialX::ShaderGraph::createNode": {
      "brief": "Create a new node in a graph from a node definition.",
      "detail": "Note - this does not initialize the node instance with any concrete values, but instead creates an empty instance of the provided node definition",
      "params": {},
      "returns": "",
      "args_sig": "(const string &name,ConstNodeDefPtr nodeDef,GenContext &context)"
    },
    "MaterialX::ShaderGraph::inlineNodeBeforeOutput": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(ShaderGraphOutputSocket *output,const std::string &newNodeName,const std::string &nodeDefName,const std::string &inputName,const std::string &outputName,GenContext &context)"
    },
    "MaterialX::ShaderGraph::addInputSocket": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &name,const TypeDesc *type)"
    },
    "MaterialX::ShaderGraph::addOutputSocket": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &name,const TypeDesc *type)"
    },
    "MaterialX::ShaderGraph::addDefaultGeomNode": {
      "brief": "Add a default geometric node and connect to the given input.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(ShaderInput *input,const GeomPropDef &geomprop,GenContext &context)"
    },
    "MaterialX::ShaderGraph::topologicalSort": {
      "brief": "Sort the nodes in topological order.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::ShaderGraph::getIdentifierMap": {
      "brief": "Return the map of unique identifiers used in the scope of this graph.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::ShaderGraph::create": {
      "brief": "Create a new shader graph from a nodegraph.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const ShaderGraph *parent,const NodeGraph &nodeGraph,GenContext &context)"
    },
    "MaterialX::ShaderGraph::traverseUpstream": {
      "brief": "Return an iterator for traversal upstream from the given output.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(ShaderOutput *output)"
    },
    "MaterialX::ShaderGraph::createConnectedNodes": {
      "brief": "Create node connections corresponding to the connection between a pair of elements.",
      "detail": "",
      "params": {
        "downstreamElement": "Element representing the node to connect to.",
        "upstreamElement": "Element representing the node to connect from",
        "connectingElement": "If non-null, specifies the element on on the downstream node to connect to.",
        "context": "Context for generation."
      },
      "returns": "",
      "args_sig": "(const ElementPtr &downstreamElement,const ElementPtr &upstreamElement,ElementPtr connectingElement,GenContext &context)"
    },
    "MaterialX::ShaderGraph::addNode": {
      "brief": "Add a node to the graph.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(ShaderNodePtr node)"
    },
    "MaterialX::ShaderGraph::addInputSockets": {
      "brief": "Add input sockets from an interface element (nodedef, nodegraph or node)",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const InterfaceElement &elem,GenContext &context)"
    },
    "MaterialX::ShaderGraph::addOutputSockets": {
      "brief": "Add output sockets from an interface element (nodedef, nodegraph or node)",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const InterfaceElement &elem,GenContext &context)"
    },
    "MaterialX::ShaderGraph::addUpstreamDependencies": {
      "brief": "Traverse from the given root element and add all dependencies upstream.",
      "detail": "The traversal is done in the context of a material, if given, to include bind input elements in the traversal.",
      "params": {},
      "returns": "",
      "args_sig": "(const Element &root,GenContext &context)"
    },
    "MaterialX::ShaderGraph::addColorTransformNode": {
      "brief": "Add a color transform node and connect to the given output.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(ShaderOutput *output,const ColorSpaceTransform &transform,GenContext &context)"
    },
    "MaterialX::ShaderGraph::addUnitTransformNode": {
      "brief": "Add a unit transform node and connect to the given output.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(ShaderOutput *output,const UnitTransform &transform,GenContext &context)"
    },
    "MaterialX::ShaderGraph::finalize": {
      "brief": "Perform all post-build operations on the graph.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(GenContext &context)"
    },
    "MaterialX::ShaderGraph::optimize": {
      "brief": "Optimize the graph, removing redundant paths.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(GenContext &context)"
    },
    "MaterialX::ShaderGraph::bypass": {
      "brief": "Bypass a node for a particular input and output, effectively connecting the input's upstream connection with the output's downstream connections.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(ShaderNode *node,size_t inputIndex,size_t outputIndex=0)"
    },
    "MaterialX::ShaderGraph::setVariableNames": {
      "brief": "For inputs and outputs in the graph set the variable names to be used in generated code.",
      "detail": "Making sure variable names are valid and unique to avoid name conflicts during shader generation.",
      "params": {},
      "returns": "",
      "args_sig": "(GenContext &context)"
    },
    "MaterialX::ShaderGraph::populateColorTransformMap": {
      "brief": "Populate the color transform map for the given shader port, if the provided combination of source and target color spaces are supported for its data type.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(ColorManagementSystemPtr colorManagementSystem,ShaderPort *shaderPort,const string &sourceColorSpace,const string &targetColorSpace,bool asInput)"
    },
    "MaterialX::ShaderGraph::populateUnitTransformMap": {
      "brief": "Populates the appropriate unit transform map if the provided input/parameter or output has a unit attribute and is of the supported type.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(UnitSystemPtr unitSystem,ShaderPort *shaderPort,ValueElementPtr element,const string &targetUnitSpace,bool asInput)"
    },
    "MaterialX::ShaderGraph::disconnect": {
      "brief": "Break all connections on a node.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(ShaderNode *node) const"
    },
    "MaterialX::ShaderGraphEdge::ShaderGraphEdge": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(ShaderOutput *up,ShaderInput *down)"
    },
    "MaterialX::ShaderGraphEdge::operator==": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const ShaderGraphEdge &rhs) const"
    },
    "MaterialX::ShaderGraphEdge::operator!=": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const ShaderGraphEdge &rhs) const"
    },
    "MaterialX::ShaderGraphEdge::operator<": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const ShaderGraphEdge &rhs) const"
    },
    "MaterialX::ShaderGraphEdgeIterator::ShaderGraphEdgeIterator": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(ShaderOutput *output)"
    },
    "MaterialX::ShaderGraphEdgeIterator::~ShaderGraphEdgeIterator": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()=default"
    },
    "MaterialX::ShaderGraphEdgeIterator::operator==": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const ShaderGraphEdgeIterator &rhs) const"
    },
    "MaterialX::ShaderGraphEdgeIterator::operator!=": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const ShaderGraphEdgeIterator &rhs) const"
    },
    "MaterialX::ShaderGraphEdgeIterator::operator*": {
      "brief": "Dereference this iterator, returning the current output in the traversal.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::ShaderGraphEdgeIterator::operator++": {
      "brief": "Iterate to the next edge in the traversal.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::ShaderGraphEdgeIterator::begin": {
      "brief": "Return a reference to this iterator to begin traversal.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::ShaderGraphEdgeIterator::end": {
      "brief": "Return the end iterator.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::ShaderGraphEdgeIterator::extendPathUpstream": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(ShaderOutput *upstream,ShaderInput *downstream)"
    },
    "MaterialX::ShaderGraphEdgeIterator::returnPathDownstream": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(ShaderOutput *upstream)"
    },
    "MaterialX::ShaderGraphEdgeIterator::skipOrMarkAsVisited": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(ShaderGraphEdge)"
    },
    "MaterialX::ShaderInput::ShaderInput": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(ShaderNode *node,TypeDesc type,const string &name)"
    },
    "MaterialX::ShaderInput::getConnection": {
      "brief": "Return a connection to an upstream node output, or nullptr if not connected.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::ShaderInput::makeConnection": {
      "brief": "Make a connection from the given source output to this input.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(ShaderOutput *src)"
    },
    "MaterialX::ShaderInput::breakConnection": {
      "brief": "Break the connection to this input.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::ShaderInput::getConnectedSibling": {
      "brief": "Return the sibling node connected upstream, or nullptr if there is no sibling upstream.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::ShaderMaterial::ShaderMaterial": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::ShaderMaterial::~ShaderMaterial": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::ShaderMaterial::setDocument": {
      "brief": "Set the renderable element associated with this ShaderMaterial.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(DocumentPtr doc)"
    },
    "MaterialX::ShaderMaterial::getDocument": {
      "brief": "Return the document associated with this ShaderMaterial.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::ShaderMaterial::setElement": {
      "brief": "Set the renderable element associated with this ShaderMaterial.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(TypedElementPtr val)"
    },
    "MaterialX::ShaderMaterial::getElement": {
      "brief": "Return the renderable element associated with this ShaderMaterial.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::ShaderMaterial::setMaterialNode": {
      "brief": "Set the ShaderMaterial node associated with this ShaderMaterial.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(NodePtr node)"
    },
    "MaterialX::ShaderMaterial::getMaterialNode": {
      "brief": "Return the ShaderMaterial node associated with this ShaderMaterial.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::ShaderMaterial::setUdim": {
      "brief": "Set udim identifier.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const std::string &val)"
    },
    "MaterialX::ShaderMaterial::getUdim": {
      "brief": "Get any associated udim identifier.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::ShaderMaterial::loadSource": {
      "brief": "Load shader source from file.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const FilePath &vertexShaderFile,const FilePath &pixelShaderFile,bool hasTransparency)=0"
    },
    "MaterialX::ShaderMaterial::generateShader": {
      "brief": "Generate a shader from the given hardware shader.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(ShaderPtr hwShader)=0"
    },
    "MaterialX::ShaderMaterial::copyShader": {
      "brief": "Copies shader and API specific generated program from ShaderMaterial to this one.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(MaterialPtr ShaderMaterial)=0"
    },
    "MaterialX::ShaderMaterial::generateEnvironmentShader": {
      "brief": "Generate an environment background shader.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(GenContext &context,const FilePath &filename,DocumentPtr stdLib,const FilePath &imagePath)"
    },
    "MaterialX::ShaderMaterial::getShader": {
      "brief": "Return the underlying hardware shader.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::ShaderMaterial::hasTransparency": {
      "brief": "Return true if this ShaderMaterial has transparency.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::ShaderMaterial::bindShader": {
      "brief": "Bind shader.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const =0"
    },
    "MaterialX::ShaderMaterial::bindViewInformation": {
      "brief": "Bind viewing information for this ShaderMaterial.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(CameraPtr camera)=0"
    },
    "MaterialX::ShaderMaterial::bindImages": {
      "brief": "Bind all images for this ShaderMaterial.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(ImageHandlerPtr imageHandler,const FileSearchPath &searchPath,bool enableMipmaps=true)=0"
    },
    "MaterialX::ShaderMaterial::unbindImages": {
      "brief": "Unbbind all images for this ShaderMaterial.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(ImageHandlerPtr imageHandler)=0"
    },
    "MaterialX::ShaderMaterial::bindImage": {
      "brief": "Bind a single image.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const FilePath &filePath,const std::string &uniformName,ImageHandlerPtr imageHandler,const ImageSamplingProperties &samplingProperties)=0"
    },
    "MaterialX::ShaderMaterial::bindLighting": {
      "brief": "Bind lights to shader.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(LightHandlerPtr lightHandler,ImageHandlerPtr imageHandler,const ShadowState &shadowState)=0"
    },
    "MaterialX::ShaderMaterial::bindMesh": {
      "brief": "Bind the given mesh to this ShaderMaterial.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(MeshPtr mesh)=0"
    },
    "MaterialX::ShaderMaterial::bindPartition": {
      "brief": "Bind a mesh partition to this ShaderMaterial.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(MeshPartitionPtr part) const =0"
    },
    "MaterialX::ShaderMaterial::drawPartition": {
      "brief": "Draw the given mesh partition.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(MeshPartitionPtr part) const =0"
    },
    "MaterialX::ShaderMaterial::unbindGeometry": {
      "brief": "Unbind all geometry from this ShaderMaterial.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()=0"
    },
    "MaterialX::ShaderMaterial::getPublicUniforms": {
      "brief": "Return the block of public uniforms for this ShaderMaterial.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const =0"
    },
    "MaterialX::ShaderMaterial::findUniform": {
      "brief": "Find a public uniform from its MaterialX path.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const std::string &path) const =0"
    },
    "MaterialX::ShaderMaterial::modifyUniform": {
      "brief": "Modify the value of the uniform with the given path.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const std::string &path,ConstValuePtr value,std::string valueString=EMPTY_STRING)=0"
    },
    "MaterialX::ShaderMaterial::clearShader": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()=0"
    },
    "MaterialX::ShaderMetadataRegistry::addMetadata": {
      "brief": "Add a new metadata entry to the registry.",
      "detail": "The entry contains the name and data type for the metadata.",
      "params": {},
      "returns": "",
      "args_sig": "(const string &name,TypeDesc type,ValuePtr value=nullptr)"
    },
    "MaterialX::ShaderMetadataRegistry::findMetadata": {
      "brief": "Return the metadata registered for the given name, or nullptr if no such entry is found.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &name)"
    },
    "MaterialX::ShaderMetadataRegistry::getAllMetadata": {
      "brief": "Return all entries in the registry.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::ShaderMetadataRegistry::clear": {
      "brief": "Clear all entries in the registry.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::ShaderNode::~ShaderNode": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::ShaderNode::ShaderNode": {
      "brief": "Constructor.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const ShaderGraph *parent,const string &name)"
    },
    "MaterialX::ShaderNode::isAGraph": {
      "brief": "Return true if this node is a graph.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::ShaderNode::getParent": {
      "brief": "Return the parent graph that owns this node.",
      "detail": "If this node is a root graph it has no parent and nullptr will be returned.",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::ShaderNode::setClassification": {
      "brief": "Set classification bits for this node, replacing any previous set bits.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(uint32_t c)"
    },
    "MaterialX::ShaderNode::getClassification": {
      "brief": "Get classification bits set for this node.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::ShaderNode::addClassification": {
      "brief": "Add classification bits to this node.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(uint32_t c)"
    },
    "MaterialX::ShaderNode::hasClassification": {
      "brief": "Return true if this node matches the given classification.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(uint32_t c) const"
    },
    "MaterialX::ShaderNode::getName": {
      "brief": "Return the name of this node.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::ShaderNode::getImplementation": {
      "brief": "Return the implementation used for this node.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::ShaderNode::initialize": {
      "brief": "Initialize this shader node with all required data from the given node and nodedef.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const Node &node,const NodeDef &nodeDef,GenContext &context)"
    },
    "MaterialX::ShaderNode::addInput": {
      "brief": "Add inputs/outputs.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &name,TypeDesc type)"
    },
    "MaterialX::ShaderNode::addOutput": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &name,TypeDesc type)"
    },
    "MaterialX::ShaderNode::numInputs": {
      "brief": "Get number of inputs/outputs.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::ShaderNode::numOutputs": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::ShaderNode::getInput": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &name) const"
    },
    "MaterialX::ShaderNode::getOutput": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &name) const"
    },
    "MaterialX::ShaderNode::getInputs": {
      "brief": "Get vector of inputs/outputs.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::ShaderNode::getOutputs": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::ShaderNode::setMetadata": {
      "brief": "Set the metadata vector.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(ShaderMetadataVecPtr metadata)"
    },
    "MaterialX::ShaderNode::getMetadata": {
      "brief": "Get the metadata vector.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::ShaderNode::isEditable": {
      "brief": "Returns true if a graph input is accessible by users.",
      "detail": "Editable inputs are allowed to be published as shader uniforms and hence must be presentable in a user interface.",
      "params": {},
      "returns": "",
      "args_sig": "(const ShaderGraphInputSocket &input) const"
    },
    "MaterialX::ShaderNode::create": {
      "brief": "Create a new node from a node implementation.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const ShaderGraph *parent,const string &name,ShaderNodeImplPtr impl,unsigned int classification=Classification::TEXTURE)"
    },
    "MaterialX::ShaderNode::createMetadata": {
      "brief": "Create metadata from the nodedef according to registered metadata.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const NodeDef &nodeDef,GenContext &context)"
    },
    "MaterialX::ShaderNodeImpl::~ShaderNodeImpl": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::ShaderNodeImpl::initialize": {
      "brief": "Initialize with the given implementation element.",
      "detail": "Initialization must set the name and hash for the implementation, as well as any other data needed to emit code for the node.",
      "params": {},
      "returns": "",
      "args_sig": "(const InterfaceElement &element,GenContext &context)"
    },
    "MaterialX::ShaderNodeImpl::getName": {
      "brief": "Return the name of this implementation.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::ShaderNodeImpl::getHash": {
      "brief": "Return a hash for this implementation.",
      "detail": "The hash should correspond to the function signature generated for the node, and can be used to compare implementations, e.g. to query if an identical function has already been emitted during shader generation.",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::ShaderNodeImpl::addInputs": {
      "brief": "Add additional inputs on a node.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(ShaderNode &node,GenContext &context) const"
    },
    "MaterialX::ShaderNodeImpl::setValues": {
      "brief": "Set values for additional inputs on a node.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const Node &node,ShaderNode &shaderNode,GenContext &context) const"
    },
    "MaterialX::ShaderNodeImpl::addClassification": {
      "brief": "Add additional classifications on a node.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(ShaderNode &node) const"
    },
    "MaterialX::ShaderNodeImpl::createVariables": {
      "brief": "Create shader variables needed for the implementation of this node (e.g.",
      "detail": "uniforms, inputs and outputs). Used if the node requires input data from the application.",
      "params": {},
      "returns": "",
      "args_sig": "(const ShaderNode &node,GenContext &context,Shader &shader) const"
    },
    "MaterialX::ShaderNodeImpl::emitFunctionDefinition": {
      "brief": "Emit function definition for the given node instance.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const ShaderNode &node,GenContext &context,ShaderStage &stage) const"
    },
    "MaterialX::ShaderNodeImpl::emitFunctionCall": {
      "brief": "Emit the function call or inline source code for given node instance in the given context.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const ShaderNode &node,GenContext &context,ShaderStage &stage) const"
    },
    "MaterialX::ShaderNodeImpl::emitOutputVariables": {
      "brief": "Emit declaration and initialization of output variables to use in a function call.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const ShaderNode &node,GenContext &context,ShaderStage &stage) const"
    },
    "MaterialX::ShaderNodeImpl::getGraph": {
      "brief": "Return a pointer to the graph if this implementation is using a graph, or returns nullptr otherwise.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::ShaderNodeImpl::isEditable": {
      "brief": "Returns true if a graph input is accessible by users.",
      "detail": "Accessible inputs are allowed to be published as shader uniforms and hence must be presentable in a user interface. By default all graph inputs are considered to be accessible.",
      "params": {},
      "returns": "",
      "args_sig": "(const ShaderGraphInputSocket &) const"
    },
    "MaterialX::ShaderNodeImpl::ShaderNodeImpl": {
      "brief": "Protected constructor.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::ShaderNodeImpl::nodeOutputIsClosure": {
      "brief": "Returns true if the first output of the node is a closure This is used by SourceCodeNode and CompoundNode to generate the appropriate shader code.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const ShaderNode &node) const"
    },
    "MaterialX::ShaderOutput::ShaderOutput": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(ShaderNode *node,TypeDesc type,const string &name)"
    },
    "MaterialX::ShaderOutput::getConnections": {
      "brief": "Return a set of connections to downstream node inputs, empty if not connected.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::ShaderOutput::makeConnection": {
      "brief": "Make a connection from this output to the given input.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(ShaderInput *dst)"
    },
    "MaterialX::ShaderOutput::breakConnection": {
      "brief": "Break a connection from this output to the given input.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(ShaderInput *dst)"
    },
    "MaterialX::ShaderOutput::breakConnections": {
      "brief": "Break all connections from this output.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::ShaderPort::ShaderPort": {
      "brief": "Constructor.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(ShaderNode *node,TypeDesc type,const string &name,ValuePtr value=nullptr)"
    },
    "MaterialX::ShaderPort::getSelf": {
      "brief": "Return a shared pointer instance of this object.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::ShaderPort::getNode": {
      "brief": "Return the node this port belongs to.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::ShaderPort::setType": {
      "brief": "Set the data type for this port.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(TypeDesc type)"
    },
    "MaterialX::ShaderPort::getType": {
      "brief": "Return the data type for this port.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::ShaderPort::setName": {
      "brief": "Set the name of this port.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &name)"
    },
    "MaterialX::ShaderPort::getName": {
      "brief": "Return the name of this port.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::ShaderPort::getFullName": {
      "brief": "Return the name of this port.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::ShaderPort::setVariable": {
      "brief": "Set the variable name of this port.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &name)"
    },
    "MaterialX::ShaderPort::getVariable": {
      "brief": "Return the variable name of this port.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::ShaderPort::setSemantic": {
      "brief": "Set the variable semantic of this port.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &semantic)"
    },
    "MaterialX::ShaderPort::getSemantic": {
      "brief": "Return the variable semantic of this port.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::ShaderPort::setValue": {
      "brief": "Set a value on this port.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(ValuePtr value)"
    },
    "MaterialX::ShaderPort::getValue": {
      "brief": "Return the value set on this port.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::ShaderPort::getValueString": {
      "brief": "Return the value set on this port as a string, or an empty string if there is no value.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::ShaderPort::setColorSpace": {
      "brief": "Set a source color space for the value on this port.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &colorspace)"
    },
    "MaterialX::ShaderPort::getColorSpace": {
      "brief": "Return the source color space for the value on this port.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::ShaderPort::setUnit": {
      "brief": "Set a unit type for the value on this port.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &unit)"
    },
    "MaterialX::ShaderPort::getUnit": {
      "brief": "Return the unit type for the value on this port.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::ShaderPort::setGeomProp": {
      "brief": "Set geomprop name if the input has a default geomprop to be assigned when it is unconnected.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &geomprop)"
    },
    "MaterialX::ShaderPort::getGeomProp": {
      "brief": "Get geomprop name.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::ShaderPort::setPath": {
      "brief": "Set the path to this port.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &path)"
    },
    "MaterialX::ShaderPort::getPath": {
      "brief": "Return the path to this port.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::ShaderPort::setFlags": {
      "brief": "Set flags on this port.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(uint32_t flags)"
    },
    "MaterialX::ShaderPort::getFlags": {
      "brief": "Return flags set on this port.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::ShaderPort::setFlag": {
      "brief": "Set the on|off state of a given flag.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(uint32_t flag,bool value)"
    },
    "MaterialX::ShaderPort::getFlag": {
      "brief": "Return the on|off state of a given flag.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(uint32_t flag) const"
    },
    "MaterialX::ShaderPort::setUniform": {
      "brief": "Set the uniform flag this port to true.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::ShaderPort::isUniform": {
      "brief": "Return the uniform flag on this port.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::ShaderPort::setEmitted": {
      "brief": "Set the emitted state on this port to true.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::ShaderPort::isEmitted": {
      "brief": "Return the emitted state of this port.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::ShaderPort::setBindInput": {
      "brief": "Set the bind input state on this port to true.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::ShaderPort::isBindInput": {
      "brief": "Return the emitted state of this port.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::ShaderPort::setMetadata": {
      "brief": "Set the metadata vector.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(ShaderMetadataVecPtr metadata)"
    },
    "MaterialX::ShaderPort::getMetadata": {
      "brief": "Get the metadata vector.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::ShaderRenderer::initialize": {
      "brief": "Initialize the renderer.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(RenderContextHandle=nullptr)"
    },
    "MaterialX::ShaderRenderer::setCamera": {
      "brief": "Set the camera.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(CameraPtr camera)"
    },
    "MaterialX::ShaderRenderer::getCamera": {
      "brief": "Return the camera.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::ShaderRenderer::setImageHandler": {
      "brief": "Set the image handler used by this renderer for image I/O.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(ImageHandlerPtr imageHandler)"
    },
    "MaterialX::ShaderRenderer::getImageHandler": {
      "brief": "Return the image handler.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::ShaderRenderer::setLightHandler": {
      "brief": "Set the light handler used by this renderer for light bindings.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(LightHandlerPtr lightHandler)"
    },
    "MaterialX::ShaderRenderer::getLightHandler": {
      "brief": "Return the light handler.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::ShaderRenderer::setGeometryHandler": {
      "brief": "Set the geometry handler.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(GeometryHandlerPtr geometryHandler)"
    },
    "MaterialX::ShaderRenderer::getGeometryHandler": {
      "brief": "Return the geometry handler.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::ShaderRenderer::createProgram": {
      "brief": "Create program based on shader stage source code.",
      "detail": "",
      "params": {
        "stages": "Map of name and source code for the shader stages."
      },
      "returns": "",
      "args_sig": "(const StageMap &stages)"
    },
    "MaterialX::ShaderRenderer::validateInputs": {
      "brief": "Validate inputs for the program.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::ShaderRenderer::updateUniform": {
      "brief": "Update the program with value of the uniform.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &name,ConstValuePtr value)"
    },
    "MaterialX::ShaderRenderer::setSize": {
      "brief": "Set the size of the rendered image.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(unsigned int width,unsigned int height)"
    },
    "MaterialX::ShaderRenderer::render": {
      "brief": "Render the current program to produce an image.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::ShaderRenderer::captureImage": {
      "brief": "Capture the current rendered output as an image.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(ImagePtr=nullptr)"
    },
    "MaterialX::ShaderRenderer::~ShaderRenderer": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::ShaderRenderer::ShaderRenderer": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(unsigned int width,unsigned int height,Image::BaseType baseType,MatrixConvention matrixConvention=MatrixConvention::OpenGL)"
    },
    "MaterialX::ShaderStage::ShaderStage": {
      "brief": "Constructor.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &name,ConstSyntaxPtr syntax)"
    },
    "MaterialX::ShaderStage::getName": {
      "brief": "Return the stage name.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::ShaderStage::getFunctionName": {
      "brief": "Return the stage function name.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::ShaderStage::setSourceCode": {
      "brief": "Set the stage source code.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &code)"
    },
    "MaterialX::ShaderStage::getSourceCode": {
      "brief": "Return the stage source code.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::ShaderStage::createUniformBlock": {
      "brief": "Create a new uniform variable block.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &name,const string &instance=EMPTY_STRING)"
    },
    "MaterialX::ShaderStage::createInputBlock": {
      "brief": "Create a new input variable block.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &name,const string &instance=EMPTY_STRING)"
    },
    "MaterialX::ShaderStage::createOutputBlock": {
      "brief": "Create a new output variable block.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &name,const string &instance=EMPTY_STRING)"
    },
    "MaterialX::ShaderStage::getUniformBlock": {
      "brief": "Return the uniform variable block with given name.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &name) const"
    },
    "MaterialX::ShaderStage::getInputBlock": {
      "brief": "Return the input variable block with given name.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &name) const"
    },
    "MaterialX::ShaderStage::getOutputBlock": {
      "brief": "Return the output variable block with given name.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &name) const"
    },
    "MaterialX::ShaderStage::getConstantBlock": {
      "brief": "Return the constant variable block.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::ShaderStage::getUniformBlocks": {
      "brief": "Return a map of all uniform blocks.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::ShaderStage::getInputBlocks": {
      "brief": "Return a map of all input blocks.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::ShaderStage::getOutputBlocks": {
      "brief": "Return a map of all output blocks.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::ShaderStage::getIncludes": {
      "brief": "Return a set of all include files.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::ShaderStage::getSourceDependencies": {
      "brief": "Return a set of all source dependencies.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::ShaderStage::beginScope": {
      "brief": "Start a new scope using the given bracket type.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(Syntax::Punctuation punc=Syntax::CURLY_BRACKETS)"
    },
    "MaterialX::ShaderStage::endScope": {
      "brief": "End the current scope.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(bool semicolon=false,bool newline=true)"
    },
    "MaterialX::ShaderStage::beginLine": {
      "brief": "Start a new line.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::ShaderStage::endLine": {
      "brief": "End the current line.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(bool semicolon=true)"
    },
    "MaterialX::ShaderStage::newLine": {
      "brief": "Add a newline character.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::ShaderStage::addString": {
      "brief": "Add a string.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &str)"
    },
    "MaterialX::ShaderStage::addLine": {
      "brief": "Add a single line of code, optionally appending a semicolon.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &str,bool semicolon=true)"
    },
    "MaterialX::ShaderStage::addComment": {
      "brief": "Add a single line code comment.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &str)"
    },
    "MaterialX::ShaderStage::addBlock": {
      "brief": "Add a block of code.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &str,const FilePath &sourceFilename,GenContext &context)"
    },
    "MaterialX::ShaderStage::addInclude": {
      "brief": "Add the contents of an include file if not already present.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const FilePath &includeFilename,const FilePath &sourceFilename,GenContext &context)"
    },
    "MaterialX::ShaderStage::hasSourceDependency": {
      "brief": "Return true if this stage depends on the given source file.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const FilePath &file)"
    },
    "MaterialX::ShaderStage::addSourceDependency": {
      "brief": "Mark the given source file as a dependency of this stage.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const FilePath &file)"
    },
    "MaterialX::ShaderStage::addValue": {
      "brief": "Add a value.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const T &value)"
    },
    "MaterialX::ShaderStage::addFunctionDefinition": {
      "brief": "Add the function definition for a node's implementation.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const ShaderNode &node,GenContext &context)"
    },
    "MaterialX::ShaderStage::addFunctionCall": {
      "brief": "Add the function call for the given node.",
      "detail": "This will register the function as being called in the current scope, and code for the function call will be added to the stage. If emitCode is set to false the code for the function call will be omitted.",
      "params": {},
      "returns": "",
      "args_sig": "(const ShaderNode &node,GenContext &context,bool emitCode=true)"
    },
    "MaterialX::ShaderStage::isEmitted": {
      "brief": "Return true if the function for the given node has been emitted in the current scope.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const ShaderNode &node,GenContext &context) const"
    },
    "MaterialX::ShaderStage::setFunctionName": {
      "brief": "Set stage function name.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &functionName)"
    },
    "MaterialX::ShaderTranslator::create": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::ShaderTranslator::translateShader": {
      "brief": "Translate a shader node to the destination shading model.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(NodePtr shader,const string &destCategory)"
    },
    "MaterialX::ShaderTranslator::translateAllMaterials": {
      "brief": "Translate each material in the input document to the destination shading model.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(DocumentPtr doc,const string &destShader)"
    },
    "MaterialX::ShaderTranslator::ShaderTranslator": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()=default"
    },
    "MaterialX::ShaderTranslator::connectTranslationInputs": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(NodePtr shader,NodeDefPtr translationNodeDef)"
    },
    "MaterialX::ShaderTranslator::connectTranslationOutputs": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(NodePtr shader)"
    },
    "MaterialX::ShCoeffs::operator==": {
      "brief": "Return true if the given vector is identical to this one.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const ShCoeffs &rhs) const"
    },
    "MaterialX::ShCoeffs::operator!=": {
      "brief": "Return true if the given vector differs from this one.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const ShCoeffs &rhs) const"
    },
    "MaterialX::ShCoeffs::operator[]": {
      "brief": "Return the const coefficient at the given index.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(size_t i) const"
    },
    "MaterialX::ShCoeffs::ShCoeffs": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const std::array< C,NUM_COEFFS > &arr)"
    },
    "MaterialX::SimpleWindow::create": {
      "brief": "Static instance create function.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::SimpleWindow::~SimpleWindow": {
      "brief": "Default destructor.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::SimpleWindow::initialize": {
      "brief": "Window initialization.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const char *title,unsigned int width,unsigned int height,void *applicationShell)"
    },
    "MaterialX::SimpleWindow::getWindowWrapper": {
      "brief": "Return our platform-specific resource wrapper.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::SimpleWindow::width": {
      "brief": "Return width of window.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::SimpleWindow::height": {
      "brief": "Return height of window.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::SimpleWindow::isValid": {
      "brief": "Check for validity.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::SimpleWindow::SimpleWindow": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::SourceCodeNode::create": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::SourceCodeNode::initialize": {
      "brief": "Initialize with the given implementation element.",
      "detail": "Initialization must set the name and hash for the implementation, as well as any other data needed to emit code for the node.",
      "params": {},
      "returns": "",
      "args_sig": "(const InterfaceElement &element,GenContext &context) override"
    },
    "MaterialX::SourceCodeNode::emitFunctionDefinition": {
      "brief": "Emit function definition for the given node instance.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const ShaderNode &node,GenContext &context,ShaderStage &stage) const override"
    },
    "MaterialX::SourceCodeNode::emitFunctionCall": {
      "brief": "Emit the function call or inline source code for given node instance in the given context.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const ShaderNode &node,GenContext &context,ShaderStage &stage) const override"
    },
    "MaterialX::SourceCodeNode::resolveSourceCode": {
      "brief": "Resolve the source file and read the source code during the initialization of the node.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const InterfaceElement &element,GenContext &context)"
    },
    "MaterialX::StbImageLoader::StbImageLoader": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::StbImageLoader::~StbImageLoader": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::StbImageLoader::saveImage": {
      "brief": "Save an image to the file system.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const FilePath &filePath,ConstImagePtr image,bool verticalFlip=false) override"
    },
    "MaterialX::StbImageLoader::loadImage": {
      "brief": "Load an image from the file system.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const FilePath &filePath) override"
    },
    "MaterialX::StbImageLoader::create": {
      "brief": "Create a new stb image loader.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::StringResolver::isResolvedType": {
      "brief": "Return true if the given type may be resolved by this class.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &type)"
    },
    "MaterialX::StringResolver::resolve": {
      "brief": "Given an input string and type, apply all appropriate modifiers and return the resulting string.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &str,const string &type) const"
    },
    "MaterialX::StringResolver::setFilePrefix": {
      "brief": "Set the file prefix for this context.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &filePrefix)"
    },
    "MaterialX::StringResolver::getFilePrefix": {
      "brief": "Return the file prefix for this context.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::StringResolver::setGeomPrefix": {
      "brief": "Set the geom prefix for this context.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &geomPrefix)"
    },
    "MaterialX::StringResolver::getGeomPrefix": {
      "brief": "Return the geom prefix for this context.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::StringResolver::setUdimString": {
      "brief": "Set the UDIM substring substitution for filename data values.",
      "detail": "This string will be used to replace the standard <UDIM> token.",
      "params": {},
      "returns": "",
      "args_sig": "(const string &udim)"
    },
    "MaterialX::StringResolver::setUvTileString": {
      "brief": "Set the UV-tile substring substitution for filename data values.",
      "detail": "This string will be used to replace the standard <UVTILE> token.",
      "params": {},
      "returns": "",
      "args_sig": "(const string &uvTile)"
    },
    "MaterialX::StringResolver::setFilenameSubstitution": {
      "brief": "Set an arbitrary substring substitution for filename data values.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &key,const string &value)"
    },
    "MaterialX::StringResolver::addTokenSubstitutions": {
      "brief": "Add filename token substitutions for a given element.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(ConstElementPtr element)"
    },
    "MaterialX::StringResolver::getFilenameSubstitutions": {
      "brief": "Return the map of filename substring substitutions.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::StringResolver::setGeomNameSubstitution": {
      "brief": "Set an arbitrary substring substitution for geometry name data values.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &key,const string &value)"
    },
    "MaterialX::StringResolver::getGeomNameSubstitutions": {
      "brief": "Return the map of geometry name substring substitutions.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::StringResolver::create": {
      "brief": "Create a new string resolver.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::StringResolver::~StringResolver": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::StringResolver::StringResolver": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::StringTypeSyntax::StringTypeSyntax": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const Syntax *parent,const string &name,const string &defaultValue,const string &uniformDefaultValue,const string &typeAlias=EMPTY_STRING,const string &typeDefinition=EMPTY_STRING)"
    },
    "MaterialX::StringTypeSyntax::getValue": {
      "brief": "Returns a value formatted according to this type syntax.",
      "detail": "The value is constructed from the given value object.",
      "params": {},
      "returns": "",
      "args_sig": "(const Value &value,bool uniform) const override"
    },
    "MaterialX::StructMemberDesc::StructMemberDesc": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(TypeDesc type,const string &name,const string &defaultValueStr)"
    },
    "MaterialX::StructMemberDesc::getType": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::StructMemberDesc::getName": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::StructMemberDesc::getDefaultValueStr": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::StructTypeSyntax::StructTypeSyntax": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const Syntax *parent,const string &name,const string &defaultValue,const string &uniformDefaultValue,const string &typeAlias=EMPTY_STRING,const string &typeDefinition=EMPTY_STRING,const StringVec &members=EMPTY_MEMBERS)"
    },
    "MaterialX::StructTypeSyntax::getValue": {
      "brief": "Returns a value formatted according to this type syntax.",
      "detail": "The value is constructed from the given value object.",
      "params": {},
      "returns": "",
      "args_sig": "(const Value &value,bool uniform) const override"
    },
    "MaterialX::Syntax::~Syntax": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::Syntax::registerTypeSyntax": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const TypeDesc *type,TypeSyntaxPtr syntax)"
    },
    "MaterialX::Syntax::registerReservedWords": {
      "brief": "Register names that are reserved words not to be used by a code generator when naming variables and functions.",
      "detail": "Keywords, types, built-in functions etc. should be added to this set. Multiple calls will add to the internal set of names.",
      "params": {},
      "returns": "",
      "args_sig": "(const StringSet &names)"
    },
    "MaterialX::Syntax::registerInvalidTokens": {
      "brief": "Register a set string replacements for disallowed tokens for a code generator when naming variables and functions.",
      "detail": "Multiple calls will add to the internal set of tokens.",
      "params": {},
      "returns": "",
      "args_sig": "(const StringMap &tokens)"
    },
    "MaterialX::Syntax::getReservedWords": {
      "brief": "Returns a set of names that are reserved words for this language syntax.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::Syntax::getInvalidTokens": {
      "brief": "Returns a mapping from disallowed tokens to replacement strings for this language syntax.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::Syntax::getTypeSyntax": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const TypeDesc *type) const"
    },
    "MaterialX::Syntax::getTypeSyntaxes": {
      "brief": "Returns an array of all registered type syntax objects.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::Syntax::getType": {
      "brief": "Return a type description for the given type name.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &name) const"
    },
    "MaterialX::Syntax::getTypeName": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const TypeDesc *type) const"
    },
    "MaterialX::Syntax::getOutputTypeName": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const TypeDesc *type) const"
    },
    "MaterialX::Syntax::getTypeAlias": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const TypeDesc *type) const"
    },
    "MaterialX::Syntax::getTypeDefinition": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const TypeDesc *type) const"
    },
    "MaterialX::Syntax::getDefaultValue": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const TypeDesc *type,bool uniform=false) const"
    },
    "MaterialX::Syntax::getValue": {
      "brief": "Returns the value string for a given shader port object.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const ShaderPort *port,bool uniform=false) const"
    },
    "MaterialX::Syntax::getInputQualifier": {
      "brief": "Returns a type qualifier to be used when declaring types for input variables.",
      "detail": "Default implementation returns empty string and derived syntax classes should override this method.",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::Syntax::getOutputQualifier": {
      "brief": "Returns a type qualifier to be used when declaring types for output variables.",
      "detail": "Default implementation returns empty string and derived syntax classes should override this method.",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::Syntax::getConstantQualifier": {
      "brief": "Get the qualifier used when declaring constant variables.",
      "detail": "Derived classes must define this method.",
      "params": {},
      "returns": "",
      "args_sig": "() const =0"
    },
    "MaterialX::Syntax::getUniformQualifier": {
      "brief": "Get the qualifier used when declaring uniform variables.",
      "detail": "Default implementation returns empty string and derived syntax classes should override this method.",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::Syntax::getNewline": {
      "brief": "Return the characters used for a newline.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::Syntax::getIndentation": {
      "brief": "Return the characters used for a single indentation level.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::Syntax::getStringQuote": {
      "brief": "Return the characters used to begin/end a string definition.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::Syntax::getIncludeStatement": {
      "brief": "Return the string pattern used for a file include statement.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::Syntax::getSingleLineComment": {
      "brief": "Return the characters used for single line comment.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::Syntax::getBeginMultiLineComment": {
      "brief": "Return the characters used to begin a multi line comments block.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::Syntax::getEndMultiLineComment": {
      "brief": "Return the characters used to end a multi line comments block.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::Syntax::getSourceFileExtension": {
      "brief": "Return the file extension used for source code files in this language.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const =0"
    },
    "MaterialX::Syntax::getArrayTypeSuffix": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const TypeDesc *type,const Value &value) const"
    },
    "MaterialX::Syntax::getArrayVariableSuffix": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const TypeDesc *type,const Value &value) const"
    },
    "MaterialX::Syntax::typeSupported": {
      "brief": "Query if given type is supported in the syntax.",
      "detail": "By default all types are assumed to be supported.",
      "params": {},
      "returns": "",
      "args_sig": "(const TypeDesc *type) const"
    },
    "MaterialX::Syntax::makeValidName": {
      "brief": "Modify the given name string to remove any invalid characters or tokens.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(string &name) const"
    },
    "MaterialX::Syntax::makeIdentifier": {
      "brief": "Make sure the given name is a unique identifier, updating it if needed to make it unique.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(string &name,IdentifierMap &identifiers) const"
    },
    "MaterialX::Syntax::getVariableName": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &name,const TypeDesc *type,IdentifierMap &identifiers) const"
    },
    "MaterialX::Syntax::remapEnumeration": {
      "brief": "Given an input specification attempt to remap this to an enumeration which is accepted by the shader generator.",
      "detail": "",
      "params": {
        "value": "The value string to remap.",
        "type": "The type of the value to remap,",
        "enumNames": "Type enumeration names",
        "result": "Enumeration type and value (returned)."
      },
      "returns": "Return true if the remapping was successful.",
      "args_sig": "(const string &value,TypeDesc type,const string &enumNames,std::pair< TypeDesc,ValuePtr > &result) const"
    },
    "MaterialX::Syntax::createStructSyntax": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &structTypeName,const string &defaultValue,const string &uniformDefaultValue,const string &typeAlias,const string &typeDefinition) const"
    },
    "MaterialX::Syntax::Syntax": {
      "brief": "Protected constructor.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(TypeSystemPtr typeSystem)"
    },
    "MaterialX::TargetDef::TargetDef": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(ElementPtr parent,const string &name)"
    },
    "MaterialX::TargetDef::~TargetDef": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::TargetDef::getMatchingTargets": {
      "brief": "Return a vector of target names that is matching this targetdef either by itself of by its inheritance.",
      "detail": "The vector is ordered by priority starting with this targetdef itself and then upwards in the inheritance hierarchy.",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::TextureBaker::setExtension": {
      "brief": "Set the file extension for baked textures.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &extension)"
    },
    "MaterialX::TextureBaker::getExtension": {
      "brief": "Return the file extension for baked textures.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::TextureBaker::setColorSpace": {
      "brief": "Set the color space in which color textures are encoded.",
      "detail": "By default, this color space is srgb_texture, and color inputs are automatically transformed to this space by the baker. If another color space is set, then the input graph is responsible for transforming colors to this space.",
      "params": {},
      "returns": "",
      "args_sig": "(const string &colorSpace)"
    },
    "MaterialX::TextureBaker::getColorSpace": {
      "brief": "Return the color space in which color textures are encoded.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::TextureBaker::setDistanceUnit": {
      "brief": "Set the distance unit to which textures are baked. Defaults to meters.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &unitSpace)"
    },
    "MaterialX::TextureBaker::getDistanceUnit": {
      "brief": "Return the distance unit to which textures are baked.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::TextureBaker::setAverageImages": {
      "brief": "Set whether images should be averaged to generate constants. Defaults to false.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(bool enable)"
    },
    "MaterialX::TextureBaker::getAverageImages": {
      "brief": "Return whether images should be averaged to generate constants.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::TextureBaker::setOptimizeConstants": {
      "brief": "Set whether uniform textures should be stored as constants. Defaults to true.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(bool enable)"
    },
    "MaterialX::TextureBaker::getOptimizeConstants": {
      "brief": "Return whether uniform textures should be stored as constants.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::TextureBaker::setOutputImagePath": {
      "brief": "Set the output location for baked texture images.",
      "detail": "Defaults to the root folder of the destination material.",
      "params": {},
      "returns": "",
      "args_sig": "(const FilePath &outputImagePath)"
    },
    "MaterialX::TextureBaker::getOutputImagePath": {
      "brief": "Get the current output location for baked texture images.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::TextureBaker::setBakedGraphName": {
      "brief": "Set the name of the baked graph element.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &name)"
    },
    "MaterialX::TextureBaker::getBakedGraphName": {
      "brief": "Return the name of the baked graph element.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::TextureBaker::setBakedGeomInfoName": {
      "brief": "Set the name of the baked geometry info element.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &name)"
    },
    "MaterialX::TextureBaker::getBakedGeomInfoName": {
      "brief": "Return the name of the baked geometry info element.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::TextureBaker::getTextureFilenameTemplate": {
      "brief": "Get the texture filename template.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::TextureBaker::setTextureFilenameTemplate": {
      "brief": "Set the texture filename template.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &filenameTemplate)"
    },
    "MaterialX::TextureBaker::setFilenameTemplateVarOverride": {
      "brief": "Set texFilenameOverrides if template variable exists.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &key,const string &value)"
    },
    "MaterialX::TextureBaker::setOutputStream": {
      "brief": "Set the output stream for reporting progress and warnings. Defaults to std::cout.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(std::ostream *outputStream)"
    },
    "MaterialX::TextureBaker::getOutputStream": {
      "brief": "Return the output stream for reporting progress and warnings.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::TextureBaker::setHashImageNames": {
      "brief": "Set whether to create a short name for baked images by hashing the baked image filenames This is useful for file systems which may have a maximum limit on filename size.",
      "detail": "By default names are not hashed.",
      "params": {},
      "returns": "",
      "args_sig": "(bool enable)"
    },
    "MaterialX::TextureBaker::getHashImageNames": {
      "brief": "Return whether automatic baked texture resolution is set.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::TextureBaker::setTextureSpaceMin": {
      "brief": "Set the minimum texcoords used in texture baking. Defaults to 0, 0.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const Vector2 &min)"
    },
    "MaterialX::TextureBaker::getTextureSpaceMin": {
      "brief": "Return the minimum texcoords used in texture baking.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::TextureBaker::setTextureSpaceMax": {
      "brief": "Set the maximum texcoords used in texture baking. Defaults to 1, 1.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const Vector2 &max)"
    },
    "MaterialX::TextureBaker::getTextureSpaceMax": {
      "brief": "Return the maximum texcoords used in texture baking.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::TextureBaker::setupUnitSystem": {
      "brief": "Set up the unit definitions to be used in baking.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(DocumentPtr unitDefinitions)"
    },
    "MaterialX::TextureBaker::bakeShaderInputs": {
      "brief": "Bake textures for all graph inputs of the given shader.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(NodePtr material,NodePtr shader,GenContext &context,const string &udim=EMPTY_STRING)"
    },
    "MaterialX::TextureBaker::bakeGraphOutput": {
      "brief": "Bake a texture for the given graph output.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(OutputPtr output,GenContext &context,const StringMap &filenameTemplateMap)"
    },
    "MaterialX::TextureBaker::optimizeBakedTextures": {
      "brief": "Optimize baked textures before writing.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(NodePtr shader)"
    },
    "MaterialX::TextureBaker::bakeMaterialToDoc": {
      "brief": "Bake material to document in memory and write baked textures to disk.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(DocumentPtr doc,const FileSearchPath &searchPath,const string &materialPath,const StringVec &udimSet,std::string &documentName)"
    },
    "MaterialX::TextureBaker::bakeAllMaterials": {
      "brief": "Bake materials in the given document and write them to disk.",
      "detail": "If multiple documents are written, then the given output filename will be used as a template.",
      "params": {},
      "returns": "",
      "args_sig": "(DocumentPtr doc,const FileSearchPath &searchPath,const FilePath &outputFileName)"
    },
    "MaterialX::TextureBaker::writeDocumentPerMaterial": {
      "brief": "Set whether to write a separate document per material when calling bakeAllMaterials.",
      "detail": "By default separate documents are written.",
      "params": {},
      "returns": "",
      "args_sig": "(bool value)"
    },
    "MaterialX::TextureBaker::getValueStringFromColor": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const Color4 &color,const string &type)"
    },
    "MaterialX::TextureBaker::TextureBaker": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(unsigned int width,unsigned int height,Image::BaseType baseType,bool flipSavedImage)"
    },
    "MaterialX::TextureBaker::initializeFileTemplateMap": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(InputPtr input,NodePtr shader,const string &udim=EMPTY_STRING)"
    },
    "MaterialX::TextureBaker::findVarInTemplate": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &filename,const string &var,size_t start=0)"
    },
    "MaterialX::TextureBaker::generateTextureFilename": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const StringMap &fileTemplateMap)"
    },
    "MaterialX::TextureBaker::generateNewDocumentFromShader": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(NodePtr shader,const StringVec &udimSet)"
    },
    "MaterialX::TextureBaker::writeBakedImage": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const BakedImage &baked,ImagePtr image)"
    },
    "MaterialX::TextureBakerGlsl::create": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(unsigned int width=1024,unsigned int height=1024,Image::BaseType baseType=Image::BaseType::UINT8)"
    },
    "MaterialX::TextureBakerGlsl::TextureBakerGlsl": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(unsigned int width,unsigned int height,Image::BaseType baseType)"
    },
    "MaterialX::TinyObjLoader::TinyObjLoader": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::TinyObjLoader::~TinyObjLoader": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::TinyObjLoader::load": {
      "brief": "Load geometry from disk.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const FilePath &filePath,MeshList &meshList,bool texcoordVerticalFlip=false) override"
    },
    "MaterialX::TinyObjLoader::create": {
      "brief": "Create a new TinyObjLoader.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::Token::Token": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(ElementPtr parent,const string &name)"
    },
    "MaterialX::Token::~Token": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::TreeIterator::getElement": {
      "brief": "Return the current element in the traversal.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::TreeIterator::getElementDepth": {
      "brief": "Return the element depth of the current traversal, where the starting element represents a depth of zero.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::TreeIterator::setPruneSubtree": {
      "brief": "Set the prune subtree flag, which controls whether the current subtree is pruned from traversal.",
      "detail": "",
      "params": {
        "prune": "If set to true, then the current subtree will be pruned."
      },
      "returns": "",
      "args_sig": "(bool prune)"
    },
    "MaterialX::TreeIterator::getPruneSubtree": {
      "brief": "Return the prune subtree flag, which controls whether the current subtree is pruned from traversal.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::TreeIterator::begin": {
      "brief": "Interpret this object as an iteration range, and return its begin iterator.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(size_t holdCount=0)"
    },
    "MaterialX::TreeIterator::end": {
      "brief": "Return the sentinel end iterator for this class.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::TreeIterator::TreeIterator": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(ElementPtr elem)"
    },
    "MaterialX::TreeIterator::~TreeIterator": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()=default"
    },
    "MaterialX::TreeIterator::operator==": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const TreeIterator &rhs) const"
    },
    "MaterialX::TreeIterator::operator!=": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const TreeIterator &rhs) const"
    },
    "MaterialX::TreeIterator::operator*": {
      "brief": "Dereference this iterator, returning the current element in the traversal.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::TreeIterator::operator++": {
      "brief": "Iterate to the next element in the traversal.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::TypedElement::setType": {
      "brief": "Set the element's type string.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &type)"
    },
    "MaterialX::TypedElement::hasType": {
      "brief": "Return true if the given element has a type string.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::TypedElement::getType": {
      "brief": "Return the element's type string.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::TypedElement::isColorType": {
      "brief": "Return true if the element is of color type.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::TypedElement::isMultiOutputType": {
      "brief": "Return true if the element is of multi-output type.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::TypedElement::getTypeDef": {
      "brief": "Return the TypeDef declaring the type string of this element.",
      "detail": "If no matching TypeDef is found, then an empty shared pointer is returned.",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::TypedElement::TypedElement": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(ElementPtr parent,const string &category,const string &name)"
    },
    "MaterialX::TypedElement::~TypedElement": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::TypedValue::TypedValue": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const T &value)"
    },
    "MaterialX::TypedValue::~TypedValue": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::TypedValue::copy": {
      "brief": "Create a deep copy of the value.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const override"
    },
    "MaterialX::TypedValue::setData": {
      "brief": "Set stored data object.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const TypedValue< T > &value)"
    },
    "MaterialX::TypedValue::getData": {
      "brief": "Return stored data object.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::TypedValue::getTypeString": {
      "brief": "Return type string.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const override"
    },
    "MaterialX::TypedValue::getValueString": {
      "brief": "Return value string.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const override"
    },
    "MaterialX::TypedValue::isEqual": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(ConstValuePtr other) const override"
    },
    "MaterialX::TypedValue::createFromString": {
      "brief": "Create a new value of this type from a value string.",
      "detail": "",
      "params": {},
      "returns": "A shared pointer to a typed value, or an empty shared pointer if the conversion to the given data type cannot be performed.",
      "args_sig": "(const string &value)"
    },
    "MaterialX::TypeDef::setSemantic": {
      "brief": "Set the semantic string of the TypeDef.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &semantic)"
    },
    "MaterialX::TypeDef::hasSemantic": {
      "brief": "Return true if the given TypeDef has a semantic string.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::TypeDef::getSemantic": {
      "brief": "Return the semantic string of the TypeDef.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::TypeDef::setContext": {
      "brief": "Set the context string of the TypeDef.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &context)"
    },
    "MaterialX::TypeDef::hasContext": {
      "brief": "Return true if the given TypeDef has a context string.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::TypeDef::getContext": {
      "brief": "Return the context string of the TypeDef.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::TypeDef::addMember": {
      "brief": "Add a Member to the TypeDef.",
      "detail": "",
      "params": {
        "name": "The name of the new Member. If no name is specified, then a unique name will automatically be generated."
      },
      "returns": "A shared pointer to the new Member.",
      "args_sig": "(const string &name=EMPTY_STRING)"
    },
    "MaterialX::TypeDef::getMember": {
      "brief": "Return the Member, if any, with the given name.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &name) const"
    },
    "MaterialX::TypeDef::getMembers": {
      "brief": "Return a vector of all Member elements in the TypeDef.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::TypeDef::removeMember": {
      "brief": "Remove the Member, if any, with the given name.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &name)"
    },
    "MaterialX::TypeDef::TypeDef": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(ElementPtr parent,const string &name)"
    },
    "MaterialX::TypeDef::~TypeDef": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::TypeDesc::TypeDesc": {
      "brief": "Constructor.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(std::string_view name,uint8_t basetype,uint8_t semantic,uint16_t size,const DataBlock *data) noexcept"
    },
    "MaterialX::TypeDesc::typeId": {
      "brief": "Return the unique id assigned to this type.",
      "detail": "The id is a hash of the given type name.",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::TypeDesc::getName": {
      "brief": "Return the name of the type.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::TypeDesc::getBaseType": {
      "brief": "Return the basetype for the type.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::TypeDesc::getSemantic": {
      "brief": "Return the semantic for the type.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::TypeDesc::getSize": {
      "brief": "Return the number of elements the type is composed of.",
      "detail": "Will return 1 for scalar types and a size greater than 1 for aggregate type. For array types 0 is returned since the number of elements is undefined until an array is instantiated.",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::TypeDesc::isScalar": {
      "brief": "Return true if the type is a scalar type.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::TypeDesc::isAggregate": {
      "brief": "Return true if the type is an aggregate type.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::TypeDesc::isArray": {
      "brief": "Return true if the type is an array type.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::TypeDesc::isFloat2": {
      "brief": "Return true if the type is an aggregate of 2 floats.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::TypeDesc::isFloat3": {
      "brief": "Return true if the type is an aggregate of 3 floats.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::TypeDesc::isFloat4": {
      "brief": "Return true if the type is an aggregate of 4 floats.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::TypeDesc::isClosure": {
      "brief": "Return true if the type represents a closure.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::TypeDesc::isStruct": {
      "brief": "Return true if the type represents a struct.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::TypeDesc::getStructMembers": {
      "brief": "Return a pointer to the struct member description.",
      "detail": "Will return nullptr if this is not a struct type.",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::TypeDesc::operator==": {
      "brief": "Equality operator.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(TypeDesc rhs) const"
    },
    "MaterialX::TypeDesc::operator!=": {
      "brief": "Inequality operator.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(TypeDesc rhs) const"
    },
    "MaterialX::TypeDesc::operator<": {
      "brief": "Less-than operator.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(TypeDesc rhs) const"
    },
    "MaterialX::TypeDesc::createValueFromStrings": {
      "brief": "Create a Value from a string for a given typeDesc.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &value) const"
    },
    "MaterialX::TypeDesc::constexpr_hash": {
      "brief": "Simple constexpr hash function, good enough for the small set of short strings that are used for our data type names.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(std::string_view str,uint32_t n=0,uint32_t h=2166136261)"
    },
    "MaterialX::TypeDesc::DataBlock::DataBlock": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &name,const StructMemberDescVecPtr members=nullptr) noexcept"
    },
    "MaterialX::TypeDesc::DataBlock::getName": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::TypeDesc::DataBlock::getStructMembers": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::TypeSyntax::~TypeSyntax": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::TypeSyntax::getName": {
      "brief": "Returns the type name.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::TypeSyntax::getTypeAlias": {
      "brief": "Returns a type alias if needed to define the type in the target language.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::TypeSyntax::getTypeDefinition": {
      "brief": "Returns a type definition if needed to define the type in the target language.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::TypeSyntax::getDefaultValue": {
      "brief": "Returns the default value for this type.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(bool uniform) const"
    },
    "MaterialX::TypeSyntax::getMembers": {
      "brief": "Returns the syntax for accessing type members if the type can be swizzled.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::TypeSyntax::getValue": {
      "brief": "Returns a value formatted according to this type syntax.",
      "detail": "The value is constructed from the given value object.",
      "params": {},
      "returns": "",
      "args_sig": "(const Value &value,bool uniform) const =0"
    },
    "MaterialX::TypeSyntax::TypeSyntax": {
      "brief": "Protected constructor.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const Syntax *parent,const string &name,const string &defaultValue,const string &uniformDefaultValue,const string &typeAlias,const string &typeDefinition,const StringVec &members)"
    },
    "MaterialX::TypeSystem::create": {
      "brief": "Create a new type system.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::TypeSystem::registerType": {
      "brief": "Create and register a new type description.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &name,uint8_t basetype,uint8_t semantic,uint16_t size,StructMemberDescVecPtr members=nullptr)"
    },
    "MaterialX::TypeSystem::getType": {
      "brief": "Return a type description by name.",
      "detail": "If no type is found Type::NONE is returned.",
      "params": {},
      "returns": "",
      "args_sig": "(const string &name) const"
    },
    "MaterialX::TypeSystem::getTypes": {
      "brief": "Return all registered type descriptions.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::TypeSystem::TypeSystem": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::Unit::Unit": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(ElementPtr parent,const string &name)"
    },
    "MaterialX::Unit::~Unit": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::UnitConverter::UnitConverter": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::UnitConverter::~UnitConverter": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::UnitConverter::convert": {
      "brief": "Convert a given value in a given unit to a desired unit.",
      "detail": "",
      "params": {
        "input": "Input value to convert",
        "inputUnit": "Unit of input value",
        "outputUnit": "Unit for output value"
      },
      "returns": "",
      "args_sig": "(const Vector4 &input,const string &inputUnit,const string &outputUnit) const =0"
    },
    "MaterialX::UnitConverter::getUnitAsInteger": {
      "brief": "Given a unit name return a value that it can map to as an integer Returns -1 value if not found.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &) const"
    },
    "MaterialX::UnitConverter::getUnitFromInteger": {
      "brief": "Given an integer index return the unit name in the map used by the converter Returns Empty string if not found.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(int) const"
    },
    "MaterialX::UnitConverter::write": {
      "brief": "Create unit definitions in a document based on the converter.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(DocumentPtr doc) const =0"
    },
    "MaterialX::UnitConverterRegistry::~UnitConverterRegistry": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::UnitConverterRegistry::addUnitConverter": {
      "brief": "Add a unit converter for a given UnitDef.",
      "detail": "Returns false if a converter has already been registered for the given UnitDef",
      "params": {},
      "returns": "",
      "args_sig": "(UnitTypeDefPtr def,UnitConverterPtr converter)"
    },
    "MaterialX::UnitConverterRegistry::removeUnitConverter": {
      "brief": "Remove a unit converter for a given UnitDef.",
      "detail": "Returns false if a converter does not exist for the given UnitDef",
      "params": {},
      "returns": "",
      "args_sig": "(UnitTypeDefPtr def)"
    },
    "MaterialX::UnitConverterRegistry::getUnitConverter": {
      "brief": "Get a unit converter for a given UnitDef Returns any empty pointer if a converter does not exist for the given UnitDef.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(UnitTypeDefPtr def)"
    },
    "MaterialX::UnitConverterRegistry::clearUnitConverters": {
      "brief": "Clear all unit converters from the registry.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::UnitConverterRegistry::getUnitAsInteger": {
      "brief": "Given a unit name return a value that it can map to as an integer Returns -1 value if not found.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &unitName) const"
    },
    "MaterialX::UnitConverterRegistry::write": {
      "brief": "Create unit definitions in a document based on registered converters.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(DocumentPtr doc) const"
    },
    "MaterialX::UnitConverterRegistry::convertToUnit": {
      "brief": "Convert input values which have a source unit to a given target unit.",
      "detail": "Returns if any unit conversion occurred.",
      "params": {},
      "returns": "",
      "args_sig": "(DocumentPtr doc,const string &unitType,const string &targetUnit)"
    },
    "MaterialX::UnitConverterRegistry::create": {
      "brief": "Creator.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::UnitConverterRegistry::UnitConverterRegistry": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::UnitConverterRegistry::operator=": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const UnitConverterRegistry &)=delete"
    },
    "MaterialX::UnitDef::setUnitType": {
      "brief": "Set the element's unittype string.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &type)"
    },
    "MaterialX::UnitDef::hasUnitType": {
      "brief": "Return true if the given element has a unittype string.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::UnitDef::getUnitType": {
      "brief": "Return the element's type string.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::UnitDef::addUnit": {
      "brief": "Add a Unit to the UnitDef.",
      "detail": "",
      "params": {
        "name": "The name of the new Unit. An exception is thrown if the name provided is an empty string."
      },
      "returns": "A shared pointer to the new Unit.",
      "args_sig": "(const string &name)"
    },
    "MaterialX::UnitDef::getUnit": {
      "brief": "Return the Unit, if any, with the given name.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &name) const"
    },
    "MaterialX::UnitDef::getUnits": {
      "brief": "Return a vector of all Unit elements in the UnitDef.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::UnitDef::removeUnit": {
      "brief": "Remove the Unit, if any, with the given name.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &name)"
    },
    "MaterialX::UnitDef::UnitDef": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(ElementPtr parent,const string &name)"
    },
    "MaterialX::UnitDef::~UnitDef": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::UnitSystem::~UnitSystem": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::UnitSystem::getName": {
      "brief": "Return the UnitSystem name.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::UnitSystem::setUnitConverterRegistry": {
      "brief": "Assign unit converter registry replacing any previous assignment.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(UnitConverterRegistryPtr registry)"
    },
    "MaterialX::UnitSystem::getUnitConverterRegistry": {
      "brief": "Returns the currently assigned unit converter registry.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::UnitSystem::loadLibrary": {
      "brief": "assign document with unit implementations replacing any previously loaded content.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(DocumentPtr document)"
    },
    "MaterialX::UnitSystem::supportsTransform": {
      "brief": "Returns whether this unit system supports a provided transform.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const UnitTransform &transform) const"
    },
    "MaterialX::UnitSystem::createNode": {
      "brief": "Create a node to use to perform the given unit space transformation.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(ShaderGraph *parent,const UnitTransform &transform,const string &name,GenContext &context) const"
    },
    "MaterialX::UnitSystem::getNodeDef": {
      "brief": "Returns a nodedef for a given transform.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const UnitTransform &transform) const"
    },
    "MaterialX::UnitSystem::create": {
      "brief": "Create a new UnitSystem.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &target)"
    },
    "MaterialX::UnitSystem::UnitSystem": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &target)"
    },
    "MaterialX::UnitTypeDef::UnitTypeDef": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(ElementPtr parent,const string &name)"
    },
    "MaterialX::UnitTypeDef::~UnitTypeDef": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::UnitTypeDef::getUnitDefs": {
      "brief": "Find all UnitDefs for the UnitTypeDef.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::Value::isA": {
      "brief": "Return true if this value is of the given type.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::Value::asA": {
      "brief": "Return our underlying data as an object of the given type.",
      "detail": "If the given type doesn't match our own data type, then an exception is thrown.",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::Value::getTypeString": {
      "brief": "Return the type string for this value.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const =0"
    },
    "MaterialX::Value::getValueString": {
      "brief": "Return the value string for this value.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const =0"
    },
    "MaterialX::Value::isEqual": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(ConstValuePtr other) const =0"
    },
    "MaterialX::Value::setFloatFormat": {
      "brief": "Set float formatting for converting values to strings.",
      "detail": "Formats to use are FloatFormatFixed, FloatFormatScientific or FloatFormatDefault to set default format.",
      "params": {},
      "returns": "",
      "args_sig": "(FloatFormat format)"
    },
    "MaterialX::Value::setFloatPrecision": {
      "brief": "Set float precision for converting values to strings.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(int precision)"
    },
    "MaterialX::Value::getFloatFormat": {
      "brief": "Return the current float format.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::Value::getFloatPrecision": {
      "brief": "Return the current float precision.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::Value::Value": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::Value::~Value": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::Value::copy": {
      "brief": "Create a deep copy of the value.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const =0"
    },
    "MaterialX::Value::createValue": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const char *data)"
    },
    "MaterialX::Value::createValueFromStrings": {
      "brief": "Create a new value instance from value and type strings.",
      "detail": "",
      "params": {},
      "returns": "A shared pointer to a typed value, or an empty shared pointer if the conversion to the given data type cannot be performed.",
      "args_sig": "(const string &value,const string &type,ConstTypeDefPtr typeDef=nullptr)"
    },
    "MaterialX::ValueElement::setValueString": {
      "brief": "Set the value string of an element.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &value)"
    },
    "MaterialX::ValueElement::hasValueString": {
      "brief": "Return true if the given element has a value string.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::ValueElement::getValueString": {
      "brief": "Get the value string of a element.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::ValueElement::getResolvedValueString": {
      "brief": "Return the resolved value string of an element, applying any string substitutions that are defined at the element's scope.",
      "detail": "",
      "params": {
        "resolver": "An optional string resolver, which will be used to apply string substitutions. By default, a new string resolver will be created at this scope and applied to the return value."
      },
      "returns": "",
      "args_sig": "(StringResolverPtr resolver=nullptr) const"
    },
    "MaterialX::ValueElement::setInterfaceName": {
      "brief": "Set the interface name of an element.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &name)"
    },
    "MaterialX::ValueElement::hasInterfaceName": {
      "brief": "Return true if the given element has an interface name.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::ValueElement::getInterfaceName": {
      "brief": "Return the interface name of an element.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::ValueElement::setImplementationName": {
      "brief": "Set the implementation name of an element.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &name)"
    },
    "MaterialX::ValueElement::hasImplementationName": {
      "brief": "Return true if the given element has an implementation name.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::ValueElement::getImplementationName": {
      "brief": "Return the implementation name of an element.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::ValueElement::setValue": {
      "brief": "Set the typed value of an element from a C-style string.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const char *value,const string &type=EMPTY_STRING)"
    },
    "MaterialX::ValueElement::hasValue": {
      "brief": "Return true if the element possesses a typed value.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::ValueElement::getValue": {
      "brief": "Return the typed value of an element as a generic value object, which may be queried to access its data.",
      "detail": "",
      "params": {},
      "returns": "A shared pointer to the typed value of this element, or an empty shared pointer if no value is present.",
      "args_sig": "() const"
    },
    "MaterialX::ValueElement::getResolvedValue": {
      "brief": "Return the resolved value of an element as a generic value object, which may be queried to access its data.",
      "detail": "",
      "params": {
        "resolver": "An optional string resolver, which will be used to apply string substitutions. By default, a new string resolver will be created at this scope and applied to the return value."
      },
      "returns": "A shared pointer to the typed value of this element, or an empty shared pointer if no value is present.",
      "args_sig": "(StringResolverPtr resolver=nullptr) const"
    },
    "MaterialX::ValueElement::getDefaultValue": {
      "brief": "Return the default value for this element as a generic value object, which may be queried to access its data.",
      "detail": "",
      "params": {},
      "returns": "A shared pointer to a typed value, or an empty shared pointer if no default value was found.",
      "args_sig": "() const"
    },
    "MaterialX::ValueElement::setUnit": {
      "brief": "Set the unit string of an element.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &unit)"
    },
    "MaterialX::ValueElement::hasUnit": {
      "brief": "Return true if the given element has a unit string.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::ValueElement::getUnit": {
      "brief": "Return the unit string of an element.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::ValueElement::getActiveUnit": {
      "brief": "Return the unit defined by the associated NodeDef if this element is a child of a Node.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::ValueElement::setUnitType": {
      "brief": "Set the unit type of an element.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &unit)"
    },
    "MaterialX::ValueElement::hasUnitType": {
      "brief": "Return true if the given element has a unit type.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::ValueElement::getUnitType": {
      "brief": "Return the unit type of an element.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::ValueElement::setIsUniform": {
      "brief": "Set the uniform attribute flag on this element.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(bool value)"
    },
    "MaterialX::ValueElement::getIsUniform": {
      "brief": "The the uniform attribute flag for this element.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::ValueElement::isAttributeEquivalent": {
      "brief": "Return true if the attribute on a given element is equivalent based on the equivalence criteria provided.",
      "detail": "",
      "params": {
        "rhs": "Element to compare against",
        "attributeName": "Name of attribute to compare",
        "options": "Equivalence criteria",
        "message": "Optional text description of differences"
      },
      "returns": "True if the attribute on the elements are equivalent. False otherwise.",
      "args_sig": "(ConstElementPtr rhs,const string &attributeName,const ElementEquivalenceOptions &options,string *message=nullptr) const override"
    },
    "MaterialX::ValueElement::validate": {
      "brief": "Validate that the given element tree, including all descendants, is consistent with the MaterialX specification.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(string *message=nullptr) const override"
    },
    "MaterialX::ValueElement::ValueElement": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(ElementPtr parent,const string &category,const string &name)"
    },
    "MaterialX::ValueElement::~ValueElement": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::VariableBlock::VariableBlock": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &name,const string &instance)"
    },
    "MaterialX::VariableBlock::getName": {
      "brief": "Get the name of this block.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::VariableBlock::setName": {
      "brief": "Set the name of this block.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &name)"
    },
    "MaterialX::VariableBlock::getInstance": {
      "brief": "Get the instance name of this block.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::VariableBlock::setInstance": {
      "brief": "Set the instance name of this block.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &instance)"
    },
    "MaterialX::VariableBlock::empty": {
      "brief": "Return true if the block has no variables.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::VariableBlock::size": {
      "brief": "Return the number of variables in this block.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::VariableBlock::operator[]": {
      "brief": "Return a variable by name.",
      "detail": "Throws exception if no variable is found by the given name.",
      "params": {},
      "returns": "",
      "args_sig": "(const string &name) const"
    },
    "MaterialX::VariableBlock::getVariableOrder": {
      "brief": "Return a const reference to our variable order vector.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::VariableBlock::find": {
      "brief": "Find a port based on a predicate.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const ShaderPortPredicate &predicate)"
    },
    "MaterialX::VariableBlock::add": {
      "brief": "Add an existing shader port to this block.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(ShaderPortPtr port)"
    },
    "MaterialX::Variant::Variant": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(ElementPtr parent,const string &name)"
    },
    "MaterialX::Variant::~Variant": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::VariantAssign::setVariantSetString": {
      "brief": "Set the element's variant set string.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &variantSet)"
    },
    "MaterialX::VariantAssign::hasVariantSetString": {
      "brief": "Return true if the given element has a variant set string.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::VariantAssign::getVariantSetString": {
      "brief": "Return the element's variant set string.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::VariantAssign::setVariantString": {
      "brief": "Set the element's variant string.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &variant)"
    },
    "MaterialX::VariantAssign::hasVariantString": {
      "brief": "Return true if the given element has a variant string.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::VariantAssign::getVariantString": {
      "brief": "Return the element's variant string.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::VariantAssign::VariantAssign": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(ElementPtr parent,const string &name)"
    },
    "MaterialX::VariantAssign::~VariantAssign": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::VariantSet::addVariant": {
      "brief": "Add a Variant to the variant set.",
      "detail": "",
      "params": {
        "name": "The name of the new Variant. If no name is specified, then a unique name will automatically be generated."
      },
      "returns": "A shared pointer to the new Variant.",
      "args_sig": "(const string &name=EMPTY_STRING)"
    },
    "MaterialX::VariantSet::getVariant": {
      "brief": "Return the Variant, if any, with the given name.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &name) const"
    },
    "MaterialX::VariantSet::getVariants": {
      "brief": "Return a vector of all Variant elements in the look.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::VariantSet::removeVariant": {
      "brief": "Remove the Variant, if any, with the given name.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &name)"
    },
    "MaterialX::VariantSet::VariantSet": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(ElementPtr parent,const string &name)"
    },
    "MaterialX::VariantSet::~VariantSet": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::Vector2::Vector2": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(float x,float y)"
    },
    "MaterialX::Vector2::cross": {
      "brief": "Return the cross product of two vectors.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const Vector2 &rhs) const"
    },
    "MaterialX::Vector3::Vector3": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(float x,float y,float z)"
    },
    "MaterialX::Vector3::cross": {
      "brief": "Return the cross product of two vectors.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const Vector3 &rhs) const"
    },
    "MaterialX::Vector3d::Vector3d": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(double x,double y,double z)"
    },
    "MaterialX::Vector4::Vector4": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(float x,float y,float z,float w)"
    },
    "MaterialX::Vector4d::Vector4d": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(double x,double y,double z,double w)"
    },
    "MaterialX::VectorN::operator==": {
      "brief": "Return true if the given vector is identical to this one.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const V &rhs) const"
    },
    "MaterialX::VectorN::operator!=": {
      "brief": "Return true if the given vector differs from this one.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const V &rhs) const"
    },
    "MaterialX::VectorN::operator<": {
      "brief": "Compare two vectors lexicographically.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const V &rhs) const"
    },
    "MaterialX::VectorN::operator[]": {
      "brief": "Return the const scalar value at the given index.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(size_t i) const"
    },
    "MaterialX::VectorN::operator+": {
      "brief": "Unary plus of a vector. Returns the unaltered vector.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::VectorN::operator+=": {
      "brief": "Component-wise addition of two vectors.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const V &rhs)"
    },
    "MaterialX::VectorN::operator-": {
      "brief": "Unary negation of a vector.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::VectorN::operator-=": {
      "brief": "Component-wise subtraction of two vectors.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const V &rhs)"
    },
    "MaterialX::VectorN::operator*": {
      "brief": "Component-wise multiplication of a vector by a scalar.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(S s) const"
    },
    "MaterialX::VectorN::operator*=": {
      "brief": "Component-wise multiplication of a vector by a scalar.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(S s)"
    },
    "MaterialX::VectorN::operator/": {
      "brief": "Component-wise division of a vector by a scalar.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(S s) const"
    },
    "MaterialX::VectorN::operator/=": {
      "brief": "Component-wise division of a vector by a scalar.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(S s)"
    },
    "MaterialX::VectorN::getMagnitude": {
      "brief": "Return the magnitude of the vector.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::VectorN::getNormalized": {
      "brief": "Return a normalized vector.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::VectorN::dot": {
      "brief": "Return the dot product of two vectors.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const V &rhs) const"
    },
    "MaterialX::VectorN::begin": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::VectorN::end": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::VectorN::data": {
      "brief": "Return a const pointer to the underlying data array.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::VectorN::numElements": {
      "brief": "Return the number of scalar elements for the vector.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::VectorN::VectorN": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const S *begin,const S *end)"
    },
    "MaterialX::VectorN::Hash::operator()": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const V &v) const noexcept"
    },
    "MaterialX::Visibility::setViewerGeom": {
      "brief": "Set the viewer geom string of the element.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &geom)"
    },
    "MaterialX::Visibility::hasViewerGeom": {
      "brief": "Return true if the given element has a viewer geom string.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::Visibility::getViewerGeom": {
      "brief": "Return the viewer geom string of the element.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::Visibility::setViewerCollection": {
      "brief": "Set the viewer geom string of the element.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &collection)"
    },
    "MaterialX::Visibility::hasViewerCollection": {
      "brief": "Return true if the given element has a viewer collection string.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::Visibility::getViewerCollection": {
      "brief": "Return the viewer collection string of the element.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::Visibility::setVisibilityType": {
      "brief": "Set the visibility type string of the element.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &type)"
    },
    "MaterialX::Visibility::hasVisibilityType": {
      "brief": "Return true if the given element has a visibility type string.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::Visibility::getVisibilityType": {
      "brief": "Return the visibility type string of the element.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::Visibility::setVisible": {
      "brief": "Set the visible boolean of the element.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(bool visible)"
    },
    "MaterialX::Visibility::getVisible": {
      "brief": "Return the visible boolean of the element.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::Visibility::Visibility": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(ElementPtr parent,const string &name)"
    },
    "MaterialX::Visibility::~Visibility": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::VkResourceBindingContext::VkResourceBindingContext": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(size_t uniformBindingLocation)"
    },
    "MaterialX::VkResourceBindingContext::initialize": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() override"
    },
    "MaterialX::VkResourceBindingContext::emitDirectives": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(GenContext &context,ShaderStage &stage) override"
    },
    "MaterialX::VkResourceBindingContext::emitResourceBindings": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(GenContext &context,const VariableBlock &uniforms,ShaderStage &stage) override"
    },
    "MaterialX::VkResourceBindingContext::emitStructuredResourceBindings": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(GenContext &context,const VariableBlock &uniforms,ShaderStage &stage,const std::string &structInstanceName,const std::string &arraySuffix) override"
    },
    "MaterialX::VkResourceBindingContext::create": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(size_t uniformBindingLocation=0)"
    },
    "MaterialX::VkShaderGenerator::VkShaderGenerator": {
      "brief": "Constructor.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(TypeSystemPtr typeSystem)"
    },
    "MaterialX::VkShaderGenerator::getTarget": {
      "brief": "Return a unique identifier for the target this generator is for.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const override"
    },
    "MaterialX::VkShaderGenerator::getVersion": {
      "brief": "Return the version string for the GLSL version this generator is for.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const override"
    },
    "MaterialX::VkShaderGenerator::getVertexDataPrefix": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const VariableBlock &vertexData) const override"
    },
    "MaterialX::VkShaderGenerator::emitDirectives": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(GenContext &context,ShaderStage &stage) const override"
    },
    "MaterialX::VkShaderGenerator::emitInputs": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(GenContext &context,ShaderStage &stage) const override"
    },
    "MaterialX::VkShaderGenerator::emitOutputs": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(GenContext &context,ShaderStage &stage) const override"
    },
    "MaterialX::VkShaderGenerator::create": {
      "brief": "Creator function.",
      "detail": "If a TypeSystem is not provided it will be created internally. Optionally pass in an externally created TypeSystem here, if you want to keep type descriptions alive after the lifetime of the shader generator.",
      "params": {},
      "returns": "",
      "args_sig": "(TypeSystemPtr typeSystem=nullptr)"
    },
    "MaterialX::VkShaderGenerator::getResourceBindingContext": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(GenContext &) const override"
    },
    "MaterialX::VkSyntax::VkSyntax": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(TypeSystemPtr typeSystem)"
    },
    "MaterialX::VkSyntax::getInputQualifier": {
      "brief": "Returns a type qualifier to be used when declaring types for input variables.",
      "detail": "Default implementation returns empty string and derived syntax classes should override this method.",
      "params": {},
      "returns": "",
      "args_sig": "() const override"
    },
    "MaterialX::VkSyntax::create": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(TypeSystemPtr typeSystem)"
    },
    "MaterialX::WgslResourceBindingContext::WgslResourceBindingContext": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(size_t uniformBindingLocation)"
    },
    "MaterialX::WgslResourceBindingContext::emitResourceBindings": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(GenContext &context,const VariableBlock &uniforms,ShaderStage &stage) override"
    },
    "MaterialX::WgslResourceBindingContext::create": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(size_t uniformBindingLocation=0)"
    },
    "MaterialX::WgslShaderGenerator::WgslShaderGenerator": {
      "brief": "Constructor.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(TypeSystemPtr typeSystem)"
    },
    "MaterialX::WgslShaderGenerator::emitDirectives": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(GenContext &context,ShaderStage &stage) const override"
    },
    "MaterialX::WgslShaderGenerator::getLightDataTypevarString": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const override"
    },
    "MaterialX::WgslShaderGenerator::emitFunctionDefinitionParameter": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const ShaderPort *shaderPort,bool isOutput,GenContext &context,ShaderStage &stage) const override"
    },
    "MaterialX::WgslShaderGenerator::emitInput": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const ShaderInput *input,GenContext &context,ShaderStage &stage) const override"
    },
    "MaterialX::WgslShaderGenerator::create": {
      "brief": "Creator function.",
      "detail": "If a TypeSystem is not provided it will be created internally. Optionally pass in an externally created TypeSystem here, if you want to keep type descriptions alive after the lifetime of the shader generator.",
      "params": {},
      "returns": "",
      "args_sig": "(TypeSystemPtr typeSystem=nullptr)"
    },
    "MaterialX::WgslSyntax::WgslSyntax": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(TypeSystemPtr typeSystem)"
    },
    "MaterialX::WgslSyntax::create": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(TypeSystemPtr typeSystem)"
    },
    "MaterialX::WindowWrapper::create": {
      "brief": "Create a new WindowWrapper.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(ExternalWindowHandle externalHandle={},InternalWindowHandle internalHandle={},DisplayHandle display={})"
    },
    "MaterialX::WindowWrapper::~WindowWrapper": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::WindowWrapper::externalHandle": {
      "brief": "Return \"external\" handle.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::WindowWrapper::internalHandle": {
      "brief": "Return \"internal\" handle.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::WindowWrapper::isValid": {
      "brief": "Check that there is a valid OS handle set.",
      "detail": "It is sufficient to just check the internal handle.",
      "params": {},
      "returns": "",
      "args_sig": "() const"
    },
    "MaterialX::WindowWrapper::release": {
      "brief": "Release resources stored in wrapper.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::WindowWrapper::WindowWrapper": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(ExternalWindowHandle externalHandle,InternalWindowHandle internalHandle,DisplayHandle display)"
    },
    "MaterialX::XmlReadOptions::XmlReadOptions": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::XmlReadOptions::~XmlReadOptions": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()=default"
    },
    "MaterialX::XmlWriteOptions::XmlWriteOptions": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()"
    },
    "MaterialX::XmlWriteOptions::~XmlWriteOptions": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "()=default"
    },
    "MaterialX::ColorSpaceTransform::ColorSpaceTransform": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &ss,const string &ts,TypeDesc t)"
    },
    "MaterialX::ColorSpaceTransform::operator==": {
      "brief": "Comparison operator.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const ColorSpaceTransform &other) const"
    },
    "MaterialX::GlslProgram::Input::Input": {
      "brief": "Program input constructor.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(int inputLocation,int inputType,int inputSize,const string &inputPath)"
    },
    "MaterialX::ImageSamplingKeyHasher::operator()": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const ImageSamplingProperties &k) const"
    },
    "MaterialX::ShaderMetadata::ShaderMetadata": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &n,TypeDesc t,ValuePtr v=nullptr)"
    },
    "MaterialX::ShaderStage::Scope::Scope": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(Syntax::Punctuation p)"
    },
    "MaterialX::TypeDesc::Hasher::operator()": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const TypeDesc &t) const"
    },
    "MaterialX::UnitTransform::UnitTransform": {
      "brief": "",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const string &ss,const string &ts,TypeDesc t,const string &unittype)"
    },
    "MaterialX::UnitTransform::operator==": {
      "brief": "Comparison operator.",
      "detail": "",
      "params": {},
      "returns": "",
      "args_sig": "(const UnitTransform &rhs) const"
    }
  }
}